
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>common: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/chenjianyu/collections/container/common/errors.go (0.0%)</option>
				
				<option value="file1">github.com/chenjianyu/collections/container/common/utils.go (34.9%)</option>
				
				<option value="file2">github.com/chenjianyu/collections/container/list/arraylist.go (81.0%)</option>
				
				<option value="file3">github.com/chenjianyu/collections/container/list/linkedlist.go (71.5%)</option>
				
				<option value="file4">github.com/chenjianyu/collections/container/map/common.go (16.0%)</option>
				
				<option value="file5">github.com/chenjianyu/collections/container/map/concurrenthashmap.go (89.5%)</option>
				
				<option value="file6">github.com/chenjianyu/collections/container/map/copyonwritemap.go (94.0%)</option>
				
				<option value="file7">github.com/chenjianyu/collections/container/map/hashmap.go (29.3%)</option>
				
				<option value="file8">github.com/chenjianyu/collections/container/map/treemap.go (77.3%)</option>
				
				<option value="file9">github.com/chenjianyu/collections/container/multimap/arraylistmultimap.go (62.9%)</option>
				
				<option value="file10">github.com/chenjianyu/collections/container/multimap/hashmultimap.go (62.9%)</option>
				
				<option value="file11">github.com/chenjianyu/collections/container/multimap/immutablelistmultimap.go (41.1%)</option>
				
				<option value="file12">github.com/chenjianyu/collections/container/multimap/immutablemultimap.go (42.9%)</option>
				
				<option value="file13">github.com/chenjianyu/collections/container/multimap/immutablesetmultimap.go (46.9%)</option>
				
				<option value="file14">github.com/chenjianyu/collections/container/multimap/linkedhashmultimap.go (49.7%)</option>
				
				<option value="file15">github.com/chenjianyu/collections/container/multimap/treemultimap.go (47.3%)</option>
				
				<option value="file16">github.com/chenjianyu/collections/container/multiset/concurrenthashmultiset.go (64.1%)</option>
				
				<option value="file17">github.com/chenjianyu/collections/container/multiset/hashmultiset.go (78.3%)</option>
				
				<option value="file18">github.com/chenjianyu/collections/container/multiset/immutablemultiset.go (13.2%)</option>
				
				<option value="file19">github.com/chenjianyu/collections/container/multiset/linkedhashmultiset.go (62.9%)</option>
				
				<option value="file20">github.com/chenjianyu/collections/container/multiset/treemultiset.go (65.3%)</option>
				
				<option value="file21">github.com/chenjianyu/collections/container/queue/linkedlist.go (13.3%)</option>
				
				<option value="file22">github.com/chenjianyu/collections/container/queue/priorityqueue.go (85.9%)</option>
				
				<option value="file23">github.com/chenjianyu/collections/container/range/immutable_range_map.go (4.7%)</option>
				
				<option value="file24">github.com/chenjianyu/collections/container/range/immutable_range_set.go (4.5%)</option>
				
				<option value="file25">github.com/chenjianyu/collections/container/range/range.go (8.5%)</option>
				
				<option value="file26">github.com/chenjianyu/collections/container/range/range_impl.go (35.0%)</option>
				
				<option value="file27">github.com/chenjianyu/collections/container/range/tree_range_map.go (13.4%)</option>
				
				<option value="file28">github.com/chenjianyu/collections/container/range/tree_range_set.go (10.9%)</option>
				
				<option value="file29">github.com/chenjianyu/collections/container/set/concurrentskiplistset.go (87.9%)</option>
				
				<option value="file30">github.com/chenjianyu/collections/container/set/hashset.go (95.9%)</option>
				
				<option value="file31">github.com/chenjianyu/collections/container/set/linkedhashset.go (98.3%)</option>
				
				<option value="file32">github.com/chenjianyu/collections/container/set/treeset.go (3.4%)</option>
				
				<option value="file33">github.com/chenjianyu/collections/container/stack/arraystack.go (85.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package common provides common error types for the container library
package common

import (
        "errors"
        "fmt"
)

// Common error variables
var (
        ErrIndexOutOfBounds   = errors.New("index out of bounds")
        ErrEmptyContainer     = errors.New("container is empty")
        ErrFullContainer      = errors.New("container is full")
        ErrInvalidRange       = errors.New("invalid range")
        ErrNegativeCount      = errors.New("count cannot be negative")
        ErrImmutableOperation = errors.New("operation not allowed on immutable collection")
        ErrKeyNotFound        = errors.New("key not found")
        ErrElementNotFound    = errors.New("element not found")
        ErrDuplicateKey       = errors.New("duplicate key")
        ErrInvalidArgument    = errors.New("invalid argument")
        ErrConcurrentAccess   = errors.New("concurrent access violation")
)

// Error factory functions for specific error scenarios

// IndexOutOfBoundsError creates a specific index out of bounds error
func IndexOutOfBoundsError(index, size int) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: index %d, size %d", ErrIndexOutOfBounds, index, size)
}</span>

// InvalidRangeError creates a specific invalid range error
func InvalidRangeError(start, end int) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: start %d, end %d", ErrInvalidRange, start, end)
}</span>

// NegativeCountError creates a specific negative count error
func NegativeCountError(count int) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %d", ErrNegativeCount, count)
}</span>

// ImmutableOperationError creates a specific immutable operation error
func ImmutableOperationError(operation, suggestion string) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %s - use %s instead", ErrImmutableOperation, operation, suggestion)
}</span>

// KeyNotFoundError creates a specific key not found error
func KeyNotFoundError(key interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %v", ErrKeyNotFound, key)
}</span>

// ElementNotFoundError creates a specific element not found error
func ElementNotFoundError(element interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %v", ErrElementNotFound, element)
}</span>

// DuplicateKeyError creates a specific duplicate key error
func DuplicateKeyError(key interface{}) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %v", ErrDuplicateKey, key)
}</span>

// InvalidArgumentError creates a specific invalid argument error
func InvalidArgumentError(argument string, reason string) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %s - %s", ErrInvalidArgument, argument, reason)
}</span>

// ConcurrentAccessError creates a specific concurrent access error
func ConcurrentAccessError(operation string) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %s", ErrConcurrentAccess, operation)
}</span>

// Container-specific error factory functions

// EmptyContainerError creates a specific empty container error with container type
func EmptyContainerError(containerType string) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %s", ErrEmptyContainer, containerType)
}</span>

// FullContainerError creates a specific full container error with container type and capacity
func FullContainerError(containerType string, capacity int) error <span class="cov0" title="0">{
        return fmt.Errorf("%w: %s (capacity: %d)", ErrFullContainer, containerType, capacity)
}</pre>
		
		<pre class="file" id="file1" style="display: none">// Package common provides common utilities and interfaces for the container library
package common

import (
        "fmt"
        "hash/fnv"
        "reflect"
        "strings"
)

// Equal compares two values for equality
// Uses reflect.DeepEqual for deep comparison
func Equal(a, b interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(a, b)
}</span>

// Hash calculates the hash code of a value
// Uses FNV-1a algorithm to hash the string representation of the value
func Hash(v interface{}) uint64 <span class="cov8" title="1">{
        h := fnv.New64a()
        h.Write([]byte(fmt.Sprintf("%v", v)))
        return h.Sum64()
}</span>

// Compare compares two values
// Returns:
//   - negative number: a &lt; b
//   - zero: a == b
//   - positive number: a &gt; b
func Compare(a, b interface{}) int <span class="cov8" title="1">{
        // Handle nil values
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if a == nil </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="1">if b == nil </span><span class="cov0" title="0">{
                return 1
        }</span>

        // Try type assertion for comparable types
        <span class="cov8" title="1">switch va := a.(type) </span>{
        case int:<span class="cov0" title="0">
                if vb, ok := b.(int); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case int8:<span class="cov0" title="0">
                if vb, ok := b.(int8); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case int16:<span class="cov0" title="0">
                if vb, ok := b.(int16); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case int32:<span class="cov0" title="0">
                if vb, ok := b.(int32); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case int64:<span class="cov0" title="0">
                if vb, ok := b.(int64); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case uint:<span class="cov0" title="0">
                if vb, ok := b.(uint); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case uint8:<span class="cov0" title="0">
                if vb, ok := b.(uint8); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case uint16:<span class="cov0" title="0">
                if vb, ok := b.(uint16); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case uint32:<span class="cov0" title="0">
                if vb, ok := b.(uint32); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case uint64:<span class="cov0" title="0">
                if vb, ok := b.(uint64); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case float32:<span class="cov0" title="0">
                if vb, ok := b.(float32); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case float64:<span class="cov0" title="0">
                if vb, ok := b.(float64); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        case string:<span class="cov0" title="0">
                if vb, ok := b.(string); ok </span><span class="cov0" title="0">{
                        if va &lt; vb </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        }

        // Check if both implement fmt.Stringer
        <span class="cov8" title="1">if sa, ok := a.(fmt.Stringer); ok </span><span class="cov8" title="1">{
                if sb, ok := b.(fmt.Stringer); ok </span><span class="cov8" title="1">{
                        return strings.Compare(sa.String(), sb.String())
                }</span>
        }

        // For types that cannot be directly compared, use hash values for comparison
        <span class="cov8" title="1">hashA := Hash(a)
        hashB := Hash(b)
        if hashA &lt; hashB </span><span class="cov8" title="1">{
                return -1
        }</span> else<span class="cov8" title="1"> if hashA &gt; hashB </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// CompareGeneric compares two comparable values using generics
// Returns:
//   - negative number: a &lt; b
//   - zero: a == b
//   - positive number: a &gt; b
func CompareGeneric[T comparable](a, b T) int <span class="cov8" title="1">{
        // Use type assertion to handle specific types
        switch va := any(a).(type) </span>{
        case int:<span class="cov8" title="1">
                vb := any(b).(int)
                if va &lt; vb </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if va &gt; vb </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int8:<span class="cov0" title="0">
                vb := any(b).(int8)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int16:<span class="cov0" title="0">
                vb := any(b).(int16)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int32:<span class="cov0" title="0">
                vb := any(b).(int32)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int64:<span class="cov0" title="0">
                vb := any(b).(int64)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint:<span class="cov8" title="1">
                vb := any(b).(uint)
                if va &lt; vb </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint8:<span class="cov8" title="1">
                vb := any(b).(uint8)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov8" title="1"> if va &gt; vb </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint16:<span class="cov8" title="1">
                vb := any(b).(uint16)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov8" title="1"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case uint32:<span class="cov8" title="1">
                vb := any(b).(uint32)
                if va &lt; vb </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint64:<span class="cov8" title="1">
                vb := any(b).(uint64)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov8" title="1"> if va &gt; vb </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case float32:<span class="cov8" title="1">
                vb := any(b).(float32)
                if va &lt; vb </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case float64:<span class="cov8" title="1">
                vb := any(b).(float64)
                if va &lt; vb </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if va &gt; vb </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case string:<span class="cov8" title="1">
                vb := any(b).(string)
                if va &lt; vb </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if va &gt; vb </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        default:<span class="cov8" title="1">
                // For other comparable types, check equality first
                if a == b </span><span class="cov8" title="1">{
                        return 0
                }</span>
                // For non-comparable types or when equality fails, use hash values for comparison
                <span class="cov8" title="1">hashA := Hash(a)
                hashB := Hash(b)
                if hashA &lt; hashB </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov8" title="1"> if hashA &gt; hashB </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
}

// Pair represents a key-value pair
type Pair[K, V any] struct {
        Key   K
        Value V
}

// NewPair creates a new key-value pair
func NewPair[K, V any](key K, value V) Pair[K, V] <span class="cov8" title="1">{
        return Pair[K, V]{Key: key, Value: value}
}</span>

// String returns the string representation of the Pair
func (p Pair[K, V]) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("(%v, %v)", p.Key, p.Value)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package list provides implementations of list data structures
package list

import (
        "fmt"
        "strings"

        "github.com/chenjianyu/collections/container/common"
)

// ArrayList is a List implementation based on dynamic arrays
type ArrayList[E any] struct {
        elements []E
}

// New creates a new ArrayList
func New[E any]() *ArrayList[E] <span class="cov8" title="1">{
        return &amp;ArrayList[E]{elements: make([]E, 0)}
}</span>

// WithCapacity creates an ArrayList with the specified initial capacity
func WithCapacity[E any](capacity int) *ArrayList[E] <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov0" title="0">{
                capacity = 0
        }</span>
        <span class="cov8" title="1">return &amp;ArrayList[E]{elements: make([]E, 0, capacity)}</span>
}

// FromSlice creates a new ArrayList from a slice
func FromSlice[E any](slice []E) *ArrayList[E] <span class="cov8" title="1">{
        elements := make([]E, len(slice))
        copy(elements, slice)
        return &amp;ArrayList[E]{elements: elements}
}</span>

// Add adds an element to the end of the list
func (list *ArrayList[E]) Add(element E) bool <span class="cov8" title="1">{
        list.elements = append(list.elements, element)
        return true
}</span>

// Insert inserts an element at the specified position
func (list *ArrayList[E]) Insert(index int, element E) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt; len(list.elements) </span><span class="cov8" title="1">{
                return common.IndexOutOfBoundsError(index, len(list.elements))
        }</span>

        // Add to the end
        <span class="cov8" title="1">if index == len(list.elements) </span><span class="cov8" title="1">{
                list.elements = append(list.elements, element)
                return nil
        }</span>

        // Insert in the middle
        <span class="cov8" title="1">list.elements = append(list.elements, *new(E)) // Extend the slice
        copy(list.elements[index+1:], list.elements[index:])
        list.elements[index] = element
        return nil</span>
}

// Get retrieves the element at the specified index
func (list *ArrayList[E]) Get(index int) (E, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(list.elements) </span><span class="cov8" title="1">{
                return *new(E), common.IndexOutOfBoundsError(index, len(list.elements))
        }</span>
        <span class="cov8" title="1">return list.elements[index], nil</span>
}

// Set replaces the element at the specified index
func (list *ArrayList[E]) Set(index int, element E) (E, bool) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(list.elements) </span><span class="cov8" title="1">{
                return *new(E), false
        }</span>
        <span class="cov8" title="1">oldElement := list.elements[index]
        list.elements[index] = element
        return oldElement, true</span>
}

// RemoveAt removes the element at the specified index
func (list *ArrayList[E]) RemoveAt(index int) (E, bool) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(list.elements) </span><span class="cov8" title="1">{
                return *new(E), false
        }</span>
        <span class="cov8" title="1">element := list.elements[index]
        // Move elements to fill the gap
        copy(list.elements[index:], list.elements[index+1:])
        // Shrink the slice
        list.elements = list.elements[:len(list.elements)-1]
        return element, true</span>
}

// Remove removes the first occurrence of the specified element
func (list *ArrayList[E]) Remove(element E) bool <span class="cov8" title="1">{
        index := list.IndexOf(element)
        if index &gt;= 0 </span><span class="cov8" title="1">{
                _, removed := list.RemoveAt(index)
                return removed
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Contains checks if the list contains the specified element
func (list *ArrayList[E]) Contains(element E) bool <span class="cov8" title="1">{
        return list.IndexOf(element) &gt;= 0
}</span>

// IndexOf returns the index of the first occurrence of the specified element in the list
func (list *ArrayList[E]) IndexOf(element E) int <span class="cov8" title="1">{
        for i, e := range list.elements </span><span class="cov8" title="1">{
                if common.Equal(e, element) </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// LastIndexOf returns the index of the last occurrence of the specified element in the list
func (list *ArrayList[E]) LastIndexOf(element E) int <span class="cov8" title="1">{
        for i := len(list.elements) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if common.Equal(list.elements[i], element) </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// Size returns the number of elements in the list
func (list *ArrayList[E]) Size() int <span class="cov8" title="1">{
        return len(list.elements)
}</span>

// IsEmpty checks if the list is empty
func (list *ArrayList[E]) IsEmpty() bool <span class="cov8" title="1">{
        return len(list.elements) == 0
}</span>

// Clear empties the list
func (list *ArrayList[E]) Clear() <span class="cov8" title="1">{
        list.elements = list.elements[:0]
}</span>

// ToSlice returns a slice containing all elements in the list
func (list *ArrayList[E]) ToSlice() []E <span class="cov8" title="1">{
        result := make([]E, len(list.elements))
        copy(result, list.elements)
        return result
}</span>

// SubList returns a view of the specified range in the list
func (list *ArrayList[E]) SubList(fromIndex, toIndex int) (List[E], error) <span class="cov8" title="1">{
        if fromIndex &lt; 0 || toIndex &gt; len(list.elements) || fromIndex &gt; toIndex </span><span class="cov8" title="1">{
                return nil, common.InvalidRangeError(fromIndex, toIndex)
        }</span>

        <span class="cov8" title="1">subElements := make([]E, toIndex-fromIndex)
        copy(subElements, list.elements[fromIndex:toIndex])
        return &amp;ArrayList[E]{elements: subElements}, nil</span>
}

// ForEach executes the given operation on each element in the list
func (list *ArrayList[E]) ForEach(f func(E)) <span class="cov8" title="1">{
        for _, element := range list.elements </span><span class="cov8" title="1">{
                f(element)
        }</span>
}

// String returns the string representation of the list
func (list *ArrayList[E]) String() string <span class="cov8" title="1">{
        if len(list.elements) == 0 </span><span class="cov8" title="1">{
                return "[]"
        }</span>

        <span class="cov8" title="1">var builder strings.Builder
        builder.WriteString("[")
        for i, element := range list.elements </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("%v", element))</span>
        }
        <span class="cov8" title="1">builder.WriteString("]")
        return builder.String()</span>
}

// Iterator returns an iterator for traversing the elements in the list
func (list *ArrayList[E]) Iterator() common.Iterator[E] <span class="cov0" title="0">{
        return &amp;arrayListIterator[E]{list: list, cursor: 0, lastRet: -1}
}</span>

// arrayListIterator is the iterator implementation for ArrayList
type arrayListIterator[E any] struct {
        list    *ArrayList[E]
        cursor  int // Index of the next element
        lastRet int // Index of the last returned element, -1 if none
}

// HasNext checks if the iterator has a next element
func (it *arrayListIterator[E]) HasNext() bool <span class="cov0" title="0">{
        return it.cursor &lt; len(it.list.elements)
}</span>

// Next returns the next element in the iterator
func (it *arrayListIterator[E]) Next() (E, bool) <span class="cov0" title="0">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                return *new(E), false
        }</span>

        <span class="cov0" title="0">element := it.list.elements[it.cursor]
        it.lastRet = it.cursor
        it.cursor++
        return element, true</span>
}

// Remove removes the last element returned by the iterator
func (it *arrayListIterator[E]) Remove() bool <span class="cov0" title="0">{
        if it.lastRet &lt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">_, removed := it.list.RemoveAt(it.lastRet)
        if removed </span><span class="cov0" title="0">{
                it.cursor = it.lastRet
                it.lastRet = -1
        }</span>
        <span class="cov0" title="0">return removed</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package list provides implementations of list data structures
package list

import (
        "fmt"
        "strings"

        "github.com/chenjianyu/collections/container/common"
)

// Node is a node in the doubly linked list
type Node[E any] struct {
        data E
        prev *Node[E]
        next *Node[E]
}

// LinkedList is a List implementation based on doubly linked list
type LinkedList[E any] struct {
        head *Node[E]
        tail *Node[E]
        size int
}

// NewLinkedList creates a new LinkedList
func NewLinkedList[E any]() *LinkedList[E] <span class="cov8" title="1">{
        return &amp;LinkedList[E]{}
}</span>

// LinkedListFromSlice creates a new LinkedList from a slice
func LinkedListFromSlice[E any](slice []E) *LinkedList[E] <span class="cov8" title="1">{
        list := NewLinkedList[E]()
        for _, element := range slice </span><span class="cov8" title="1">{
                list.Add(element)
        }</span>
        <span class="cov8" title="1">return list</span>
}

// Size returns the number of elements in the list
func (list *LinkedList[E]) Size() int <span class="cov8" title="1">{
        return list.size
}</span>

// IsEmpty checks if the list is empty
func (list *LinkedList[E]) IsEmpty() bool <span class="cov8" title="1">{
        return list.size == 0
}</span>

// Clear empties the list
func (list *LinkedList[E]) Clear() <span class="cov8" title="1">{
        list.head = nil
        list.tail = nil
        list.size = 0
}</span>

// Contains checks if the list contains the specified element
func (list *LinkedList[E]) Contains(element E) bool <span class="cov8" title="1">{
        return list.IndexOf(element) != -1
}</span>

// ForEach executes the given operation on each element in the list
func (list *LinkedList[E]) ForEach(f func(E)) <span class="cov8" title="1">{
        current := list.head
        for current != nil </span><span class="cov8" title="1">{
                f(current.data)
                current = current.next
        }</span>
}

// String returns the string representation of the list
func (list *LinkedList[E]) String() string <span class="cov8" title="1">{
        if list.IsEmpty() </span><span class="cov8" title="1">{
                return "[]"
        }</span>

        <span class="cov8" title="1">var builder strings.Builder
        builder.WriteString("[")
        current := list.head
        first := true
        for current != nil </span><span class="cov8" title="1">{
                if !first </span><span class="cov8" title="1">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("%v", current.data))
                first = false
                current = current.next</span>
        }
        <span class="cov8" title="1">builder.WriteString("]")
        return builder.String()</span>
}

// Add adds an element to the end of the list
func (list *LinkedList[E]) Add(element E) bool <span class="cov8" title="1">{
        list.AddLast(element)
        return true
}</span>

// Insert inserts an element at the specified position
func (list *LinkedList[E]) Insert(index int, element E) error <span class="cov8" title="1">{
        if index &lt; 0 || index &gt; list.size </span><span class="cov8" title="1">{
                return common.IndexOutOfBoundsError(index, list.size)
        }</span>

        <span class="cov8" title="1">if index == 0 </span><span class="cov8" title="1">{
                list.AddFirst(element)
                return nil
        }</span>

        <span class="cov8" title="1">if index == list.size </span><span class="cov8" title="1">{
                list.AddLast(element)
                return nil
        }</span>

        <span class="cov8" title="1">node := list.getNodeAt(index)
        newNode := &amp;Node[E]{data: element}

        newNode.prev = node.prev
        newNode.next = node
        node.prev.next = newNode
        node.prev = newNode

        list.size++
        return nil</span>
}

// Get retrieves the element at the specified index
func (list *LinkedList[E]) Get(index int) (E, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= list.size </span><span class="cov8" title="1">{
                return *new(E), common.IndexOutOfBoundsError(index, list.size)
        }</span>

        <span class="cov8" title="1">node := list.getNodeAt(index)
        return node.data, nil</span>
}

// Set replaces the element at the specified index
func (list *LinkedList[E]) Set(index int, element E) (E, bool) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= list.size </span><span class="cov8" title="1">{
                return *new(E), false
        }</span>

        <span class="cov8" title="1">node := list.getNodeAt(index)
        oldData := node.data
        node.data = element
        return oldData, true</span>
}

// RemoveAt removes the element at the specified index
func (list *LinkedList[E]) RemoveAt(index int) (E, bool) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= list.size </span><span class="cov8" title="1">{
                return *new(E), false
        }</span>

        <span class="cov8" title="1">if index == 0 </span><span class="cov0" title="0">{
                return list.RemoveFirst()
        }</span>

        <span class="cov8" title="1">if index == list.size-1 </span><span class="cov0" title="0">{
                return list.RemoveLast()
        }</span>

        <span class="cov8" title="1">node := list.getNodeAt(index)
        data := node.data

        node.prev.next = node.next
        node.next.prev = node.prev

        list.size--
        return data, true</span>
}

// Remove removes the first occurrence of the specified element
func (list *LinkedList[E]) Remove(element E) bool <span class="cov8" title="1">{
        current := list.head
        for current != nil </span><span class="cov8" title="1">{
                if common.Equal(current.data, element) </span><span class="cov8" title="1">{
                        if current.prev != nil </span><span class="cov8" title="1">{
                                current.prev.next = current.next
                        }</span> else<span class="cov0" title="0"> {
                                list.head = current.next
                        }</span>

                        <span class="cov8" title="1">if current.next != nil </span><span class="cov8" title="1">{
                                current.next.prev = current.prev
                        }</span> else<span class="cov0" title="0"> {
                                list.tail = current.prev
                        }</span>

                        <span class="cov8" title="1">list.size--
                        return true</span>
                }
                <span class="cov8" title="1">current = current.next</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IndexOf returns the index of the first occurrence of the specified element in the list
func (list *LinkedList[E]) IndexOf(element E) int <span class="cov8" title="1">{
        current := list.head
        index := 0
        for current != nil </span><span class="cov8" title="1">{
                if common.Equal(current.data, element) </span><span class="cov8" title="1">{
                        return index
                }</span>
                <span class="cov8" title="1">current = current.next
                index++</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// LastIndexOf returns the index of the last occurrence of the specified element in the list
func (list *LinkedList[E]) LastIndexOf(element E) int <span class="cov8" title="1">{
        current := list.tail
        index := list.size - 1
        for current != nil </span><span class="cov8" title="1">{
                if common.Equal(current.data, element) </span><span class="cov8" title="1">{
                        return index
                }</span>
                <span class="cov8" title="1">current = current.prev
                index--</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// SubList returns a view of the specified range in the list
func (list *LinkedList[E]) SubList(fromIndex, toIndex int) (List[E], error) <span class="cov8" title="1">{
        if fromIndex &lt; 0 || toIndex &gt; list.size || fromIndex &gt; toIndex </span><span class="cov8" title="1">{
                return nil, common.InvalidRangeError(fromIndex, toIndex)
        }</span>

        <span class="cov8" title="1">subList := NewLinkedList[E]()
        current := list.getNodeAt(fromIndex)
        for i := fromIndex; i &lt; toIndex; i++ </span><span class="cov8" title="1">{
                subList.Add(current.data)
                current = current.next
        }</span>
        <span class="cov8" title="1">return subList, nil</span>
}

// ToSlice returns a slice containing all elements in the list
func (list *LinkedList[E]) ToSlice() []E <span class="cov8" title="1">{
        result := make([]E, list.size)
        current := list.head
        index := 0
        for current != nil </span><span class="cov8" title="1">{
                result[index] = current.data
                current = current.next
                index++
        }</span>
        <span class="cov8" title="1">return result</span>
}

// AddFirst adds an element to the beginning of the list
func (list *LinkedList[E]) AddFirst(element E) <span class="cov8" title="1">{
        newNode := &amp;Node[E]{data: element}

        if list.head == nil </span><span class="cov0" title="0">{
                list.head = newNode
                list.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                newNode.next = list.head
                list.head.prev = newNode
                list.head = newNode
        }</span>

        <span class="cov8" title="1">list.size++</span>
}

// AddLast adds an element to the end of the list
func (list *LinkedList[E]) AddLast(element E) <span class="cov8" title="1">{
        newNode := &amp;Node[E]{data: element}

        if list.tail == nil </span><span class="cov8" title="1">{
                list.head = newNode
                list.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                newNode.prev = list.tail
                list.tail.next = newNode
                list.tail = newNode
        }</span>

        <span class="cov8" title="1">list.size++</span>
}

// RemoveFirst removes and returns the first element of the list
func (list *LinkedList[E]) RemoveFirst() (E, bool) <span class="cov0" title="0">{
        if list.head == nil </span><span class="cov0" title="0">{
                return *new(E), false
        }</span>

        <span class="cov0" title="0">data := list.head.data

        if list.head == list.tail </span><span class="cov0" title="0">{
                list.head = nil
                list.tail = nil
        }</span> else<span class="cov0" title="0"> {
                list.head = list.head.next
                list.head.prev = nil
        }</span>

        <span class="cov0" title="0">list.size--
        return data, true</span>
}

// RemoveLast removes and returns the last element of the list
func (list *LinkedList[E]) RemoveLast() (E, bool) <span class="cov0" title="0">{
        if list.tail == nil </span><span class="cov0" title="0">{
                return *new(E), false
        }</span>

        <span class="cov0" title="0">data := list.tail.data

        if list.head == list.tail </span><span class="cov0" title="0">{
                list.head = nil
                list.tail = nil
        }</span> else<span class="cov0" title="0"> {
                list.tail = list.tail.prev
                list.tail.next = nil
        }</span>

        <span class="cov0" title="0">list.size--
        return data, true</span>
}

// GetFirst returns the first element of the list without removing it
func (list *LinkedList[E]) GetFirst() (E, error) <span class="cov0" title="0">{
        if list.head == nil </span><span class="cov0" title="0">{
                return *new(E), common.EmptyContainerError("LinkedList")
        }</span>
        <span class="cov0" title="0">return list.head.data, nil</span>
}

// GetLast returns the last element of the list without removing it
func (list *LinkedList[E]) GetLast() (E, error) <span class="cov0" title="0">{
        if list.tail == nil </span><span class="cov0" title="0">{
                return *new(E), common.EmptyContainerError("LinkedList")
        }</span>
        <span class="cov0" title="0">return list.tail.data, nil</span>
}

// Head returns the head node
func (list *LinkedList[E]) Head() *Node[E] <span class="cov0" title="0">{
        return list.head
}</span>

// Tail returns the tail node
func (list *LinkedList[E]) Tail() *Node[E] <span class="cov0" title="0">{
        return list.tail
}</span>

// getNodeAt retrieves the node at the specified index (internal method)
func (list *LinkedList[E]) getNodeAt(index int) *Node[E] <span class="cov8" title="1">{
        // Search from the head
        if index &lt; list.size/2 </span><span class="cov8" title="1">{
                current := list.head
                for i := 0; i &lt; index; i++ </span><span class="cov8" title="1">{
                        current = current.next
                }</span>
                <span class="cov8" title="1">return current</span>
        } else<span class="cov8" title="1"> {
                // Search from the tail
                current := list.tail
                for i := list.size - 1; i &gt; index; i-- </span><span class="cov8" title="1">{
                        current = current.prev
                }</span>
                <span class="cov8" title="1">return current</span>
        }
}

// Iterator returns an iterator for traversing the elements in the list
func (list *LinkedList[E]) Iterator() common.Iterator[E] <span class="cov0" title="0">{
        return &amp;linkedListIterator[E]{list: list, current: list.head, lastReturned: nil}
}</span>

// linkedListIterator is the iterator implementation for LinkedList
type linkedListIterator[E any] struct {
        list         *LinkedList[E]
        current      *Node[E]
        lastReturned *Node[E]
}

// HasNext checks if the iterator has a next element
func (it *linkedListIterator[E]) HasNext() bool <span class="cov0" title="0">{
        return it.current != nil
}</span>

// Next returns the next element in the iterator
func (it *linkedListIterator[E]) Next() (E, bool) <span class="cov0" title="0">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                return *new(E), false
        }</span>

        <span class="cov0" title="0">data := it.current.data
        it.lastReturned = it.current
        it.current = it.current.next
        return data, true</span>
}

// Remove removes the last element returned by the iterator
func (it *linkedListIterator[E]) Remove() bool <span class="cov0" title="0">{
        if it.lastReturned == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Update the linked list structure
        <span class="cov0" title="0">if it.lastReturned.prev != nil </span><span class="cov0" title="0">{
                it.lastReturned.prev.next = it.lastReturned.next
        }</span> else<span class="cov0" title="0"> {
                it.list.head = it.lastReturned.next
        }</span>

        <span class="cov0" title="0">if it.lastReturned.next != nil </span><span class="cov0" title="0">{
                it.lastReturned.next.prev = it.lastReturned.prev
        }</span> else<span class="cov0" title="0"> {
                it.list.tail = it.lastReturned.prev
        }</span>

        <span class="cov0" title="0">it.list.size--
        it.lastReturned = nil
        return true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package maps

import (
        "fmt"
        "hash"
        "hash/fnv"
        "reflect"
)

// color represents the color of red-black tree nodes
type color bool

const (
        red   color = true
        black color = false
)

// Pair represents a key-value pair
type Pair[K comparable, V any] struct {
        Key   K
        Value V
}

// NewPair creates a new key-value pair
func NewPair[K comparable, V any](key K, value V) Pair[K, V] <span class="cov8" title="1">{
        return Pair[K, V]{Key: key, Value: value}
}</span>

// String returns the string representation of the pair
func (p Pair[K, V]) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("(%v, %v)", p.Key, p.Value)
}</span>

// Hash calculates the hash value of any type
func Hash(v interface{}) uint64 <span class="cov8" title="1">{
        h := fnv.New64a()
        hashValue(reflect.ValueOf(v), h)
        return h.Sum64()
}</span>

// hashValue recursively calculates hash value
func hashValue(v reflect.Value, h hash.Hash64) <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Bool:<span class="cov0" title="0">
                if v.Bool() </span><span class="cov0" title="0">{
                        h.Write([]byte{1})
                }</span> else<span class="cov0" title="0"> {
                        h.Write([]byte{0})
                }</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                writeInt64(h, v.Int())</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                writeUint64(h, v.Uint())</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                writeUint64(h, v.Uint())</span>
        case reflect.String:<span class="cov8" title="1">
                h.Write([]byte(v.String()))</span>
        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        hashValue(v.Index(i), h)
                }</span>
        case reflect.Struct:<span class="cov0" title="0">
                for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                        hashValue(v.Field(i), h)
                }</span>
        case reflect.Ptr:<span class="cov0" title="0">
                if !v.IsNil() </span><span class="cov0" title="0">{
                        hashValue(v.Elem(), h)
                }</span>
        case reflect.Interface:<span class="cov0" title="0">
                if !v.IsNil() </span><span class="cov0" title="0">{
                        hashValue(v.Elem(), h)
                }</span>
        default:<span class="cov0" title="0">
                // For other types, use their string representation
                h.Write([]byte(fmt.Sprintf("%v", v.Interface())))</span>
        }
}

// writeInt64 writes int64 value to hash
func writeInt64(h hash.Hash64, val int64) <span class="cov8" title="1">{
        bytes := make([]byte, 8)
        for i := 0; i &lt; 8; i++ </span><span class="cov8" title="1">{
                bytes[i] = byte(val &gt;&gt; (8 * i))
        }</span>
        <span class="cov8" title="1">h.Write(bytes)</span>
}

// writeUint64 writes uint64 value to hash
func writeUint64(h hash.Hash64, val uint64) <span class="cov0" title="0">{
        bytes := make([]byte, 8)
        for i := 0; i &lt; 8; i++ </span><span class="cov0" title="0">{
                bytes[i] = byte(val &gt;&gt; (8 * i))
        }</span>
        <span class="cov0" title="0">h.Write(bytes)</span>
}

// Equal checks if two values are equal
func Equal(a, b interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(a, b)
}</span>

// Compare compares two comparable values
func Compare[T comparable](a, b T) int <span class="cov8" title="1">{
        // Use type assertion to handle specific types
        switch va := any(a).(type) </span>{
        case int:<span class="cov8" title="1">
                vb := any(b).(int)
                if va &lt; vb </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if va &gt; vb </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int8:<span class="cov0" title="0">
                vb := any(b).(int8)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int16:<span class="cov0" title="0">
                vb := any(b).(int16)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int32:<span class="cov0" title="0">
                vb := any(b).(int32)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int64:<span class="cov0" title="0">
                vb := any(b).(int64)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint:<span class="cov0" title="0">
                vb := any(b).(uint)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint8:<span class="cov0" title="0">
                vb := any(b).(uint8)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint16:<span class="cov0" title="0">
                vb := any(b).(uint16)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint32:<span class="cov0" title="0">
                vb := any(b).(uint32)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint64:<span class="cov0" title="0">
                vb := any(b).(uint64)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case float32:<span class="cov0" title="0">
                vb := any(b).(float32)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case float64:<span class="cov0" title="0">
                vb := any(b).(float64)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case string:<span class="cov0" title="0">
                vb := any(b).(string)
                if va &lt; vb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if va &gt; vb </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        default:<span class="cov0" title="0">
                // For other comparable types, check equality first
                if a == b </span><span class="cov0" title="0">{
                        return 0
                }</span>
                // For non-comparable types or when equality fails, use hash values for comparison
                <span class="cov0" title="0">hashA := Hash(a)
                hashB := Hash(b)
                if hashA &lt; hashB </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if hashA &gt; hashB </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package maps

import (
        "fmt"
        "reflect"
        "strings"
        "sync"
)

// ConcurrentHashMap is a thread-safe hash map implementation
// using segmented locking strategy, similar to Java's ConcurrentHashMap
type ConcurrentHashMap[K comparable, V any] struct {
        segments     []*segment[K, V]
        segmentMask  uint32
        segmentCount int
}

// segment represents a segment of ConcurrentHashMap
type segment[K comparable, V any] struct {
        buckets []bucket[K, V]
        mutex   sync.RWMutex
        size    int
}

// bucket represents a hash bucket, using linked list to resolve conflicts
type bucket[K, V any] struct {
        key   K
        value V
        next  *bucket[K, V]
}

// Default number of segments, must be a power of 2
const defaultSegments = 16

// Default initial bucket count per segment
const defaultBuckets = 16

// Load factor threshold for concurrent hash map
const concurrentLoadFactor = 0.75

// NewConcurrentHashMap creates a new ConcurrentHashMap
func NewConcurrentHashMap[K comparable, V any]() *ConcurrentHashMap[K, V] <span class="cov8" title="1">{
        return NewConcurrentHashMapWithCapacity[K, V](defaultSegments * defaultBuckets)
}</span>

// NewConcurrentHashMapWithCapacity creates a ConcurrentHashMap with specified initial capacity
func NewConcurrentHashMapWithCapacity[K comparable, V any](capacity int) *ConcurrentHashMap[K, V] <span class="cov8" title="1">{
        if capacity &lt;= 0 </span><span class="cov0" title="0">{
                capacity = defaultSegments * defaultBuckets
        }</span>

        <span class="cov8" title="1">segmentCount := defaultSegments
        bucketsPerSegment := capacity / segmentCount
        if bucketsPerSegment &lt; defaultBuckets </span><span class="cov8" title="1">{
                bucketsPerSegment = defaultBuckets
        }</span>

        <span class="cov8" title="1">segments := make([]*segment[K, V], segmentCount)
        for i := range segments </span><span class="cov8" title="1">{
                segments[i] = &amp;segment[K, V]{
                        buckets: make([]bucket[K, V], bucketsPerSegment),
                }
        }</span>

        <span class="cov8" title="1">return &amp;ConcurrentHashMap[K, V]{
                segments:     segments,
                segmentCount: segmentCount,
                segmentMask:  uint32(segmentCount - 1),
        }</span>
}

// ConcurrentHashMapFromMap creates ConcurrentHashMap from existing map
func ConcurrentHashMapFromMap[K comparable, V any](m map[K]V) *ConcurrentHashMap[K, V] <span class="cov8" title="1">{
        chm := NewConcurrentHashMapWithCapacity[K, V](len(m))
        for k, v := range m </span><span class="cov8" title="1">{
                chm.Put(k, v)
        }</span>
        <span class="cov8" title="1">return chm</span>
}

// Put associates the specified value with the specified key in this map
func (chm *ConcurrentHashMap[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        hash := chm.hash(key)
        segmentIndex := hash &amp; chm.segmentMask
        segment := chm.segments[segmentIndex]

        segment.mutex.Lock()
        defer segment.mutex.Unlock()

        bucketIndex := hash % uint32(len(segment.buckets))
        bucketPtr := &amp;segment.buckets[bucketIndex]

        // Check if key already exists
        for current := bucketPtr.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                if chm.keyEquals(current.key, key) </span><span class="cov8" title="1">{
                        current.value = value
                        return
                }</span>
        }

        // Add new node
        <span class="cov8" title="1">newNode := &amp;bucket[K, V]{
                key:   key,
                value: value,
                next:  bucketPtr.next,
        }
        bucketPtr.next = newNode
        segment.size++

        // Check if resize is needed
        if float64(segment.size) &gt; float64(len(segment.buckets))*concurrentLoadFactor </span><span class="cov8" title="1">{
                chm.resizeSegment(segment)
        }</span>
}

// Get returns the value to which the specified key is mapped
func (chm *ConcurrentHashMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        hash := chm.hash(key)
        segmentIndex := hash &amp; chm.segmentMask
        segment := chm.segments[segmentIndex]

        segment.mutex.RLock()
        defer segment.mutex.RUnlock()

        bucketIndex := hash % uint32(len(segment.buckets))
        bucketPtr := &amp;segment.buckets[bucketIndex]

        for current := bucketPtr.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                if chm.keyEquals(current.key, key) </span><span class="cov8" title="1">{
                        return current.value, true
                }</span>
        }

        <span class="cov8" title="1">var zero V
        return zero, false</span>
}

// Remove removes the mapping for the specified key from this map if present
func (chm *ConcurrentHashMap[K, V]) Remove(key K) (V, bool) <span class="cov8" title="1">{
        hash := chm.hash(key)
        segmentIndex := hash &amp; chm.segmentMask
        segment := chm.segments[segmentIndex]

        segment.mutex.Lock()
        defer segment.mutex.Unlock()

        bucketIndex := hash % uint32(len(segment.buckets))
        bucketPtr := &amp;segment.buckets[bucketIndex]

        // If head node is the one to delete
        if bucketPtr.next != nil &amp;&amp; chm.keyEquals(bucketPtr.next.key, key) </span><span class="cov8" title="1">{
                removed := bucketPtr.next.value
                bucketPtr.next = bucketPtr.next.next
                segment.size--
                return removed, true
        }</span>

        // Find the node to delete
        <span class="cov8" title="1">for current := bucketPtr.next; current != nil &amp;&amp; current.next != nil; current = current.next </span><span class="cov0" title="0">{
                if chm.keyEquals(current.next.key, key) </span><span class="cov0" title="0">{
                        removed := current.next.value
                        current.next = current.next.next
                        segment.size--
                        return removed, true
                }</span>
        }

        <span class="cov8" title="1">var zero V
        return zero, false</span>
}

// ContainsKey returns true if this map contains a mapping for the specified key
func (chm *ConcurrentHashMap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        _, exists := chm.Get(key)
        return exists
}</span>

// ContainsValue returns true if this map maps one or more keys to the specified value
func (chm *ConcurrentHashMap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        for _, segment := range chm.segments </span><span class="cov8" title="1">{
                segment.mutex.RLock()
                for _, bkt := range segment.buckets </span><span class="cov8" title="1">{
                        for current := bkt.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                                if chm.valueEquals(current.value, value) </span><span class="cov8" title="1">{
                                        segment.mutex.RUnlock()
                                        return true
                                }</span>
                        }
                }
                <span class="cov8" title="1">segment.mutex.RUnlock()</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Size returns the number of key-value mappings in this map
func (chm *ConcurrentHashMap[K, V]) Size() int <span class="cov8" title="1">{
        totalSize := 0
        for _, segment := range chm.segments </span><span class="cov8" title="1">{
                segment.mutex.RLock()
                totalSize += segment.size
                segment.mutex.RUnlock()
        }</span>
        <span class="cov8" title="1">return totalSize</span>
}

// IsEmpty returns true if this map contains no key-value mappings
func (chm *ConcurrentHashMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return chm.Size() == 0
}</span>

// Clear removes all mappings from this map
func (chm *ConcurrentHashMap[K, V]) Clear() <span class="cov8" title="1">{
        for _, segment := range chm.segments </span><span class="cov8" title="1">{
                segment.mutex.Lock()
                for i := range segment.buckets </span><span class="cov8" title="1">{
                        segment.buckets[i] = bucket[K, V]{}
                }</span>
                <span class="cov8" title="1">segment.size = 0
                segment.mutex.Unlock()</span>
        }
}

// Keys returns a collection view of the keys contained in this map
func (chm *ConcurrentHashMap[K, V]) Keys() []K <span class="cov8" title="1">{
        var keys []K
        for _, segment := range chm.segments </span><span class="cov8" title="1">{
                segment.mutex.RLock()
                for _, bkt := range segment.buckets </span><span class="cov8" title="1">{
                        for current := bkt.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                                keys = append(keys, current.key)
                        }</span>
                }
                <span class="cov8" title="1">segment.mutex.RUnlock()</span>
        }
        <span class="cov8" title="1">return keys</span>
}

// Values returns a collection view of the values contained in this map
func (chm *ConcurrentHashMap[K, V]) Values() []V <span class="cov8" title="1">{
        var values []V
        for _, segment := range chm.segments </span><span class="cov8" title="1">{
                segment.mutex.RLock()
                for _, bkt := range segment.buckets </span><span class="cov8" title="1">{
                        for current := bkt.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                                values = append(values, current.value)
                        }</span>
                }
                <span class="cov8" title="1">segment.mutex.RUnlock()</span>
        }
        <span class="cov8" title="1">return values</span>
}

// ForEach performs the given action for each key-value pair in this map
func (chm *ConcurrentHashMap[K, V]) ForEach(action func(K, V)) <span class="cov8" title="1">{
        for _, segment := range chm.segments </span><span class="cov8" title="1">{
                segment.mutex.RLock()
                for _, bkt := range segment.buckets </span><span class="cov8" title="1">{
                        for current := bkt.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                                action(current.key, current.value)
                        }</span>
                }
                <span class="cov8" title="1">segment.mutex.RUnlock()</span>
        }
}

// String returns a string representation of this map
func (chm *ConcurrentHashMap[K, V]) String() string <span class="cov8" title="1">{
        var builder strings.Builder
        builder.WriteString("{")
        first := true
        chm.ForEach(func(key K, value V) </span><span class="cov8" title="1">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("%v=%v", key, value))
                first = false</span>
        })
        <span class="cov8" title="1">builder.WriteString("}")
        return builder.String()</span>
}

// Advanced operation methods

// PutIfAbsent adds key-value pair only if key doesn't exist
// It returns the old value and whether the key was inserted.
// If key exists: returns (old_value, false)
// If key doesn't exist: returns (zero_value, true)
func (chm *ConcurrentHashMap[K, V]) PutIfAbsent(key K, value V) (V, bool) <span class="cov8" title="1">{
        hash := chm.hash(key)
        segmentIndex := hash &amp; chm.segmentMask
        segment := chm.segments[segmentIndex]

        segment.mutex.Lock()
        defer segment.mutex.Unlock()

        bucketIndex := hash % uint32(len(segment.buckets))
        bucketPtr := &amp;segment.buckets[bucketIndex]

        // Check if key already exists
        for current := bucketPtr.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                if chm.keyEquals(current.key, key) </span><span class="cov8" title="1">{
                        return current.value, false // Key exists, not inserted
                }</span>
        }

        // Add new node
        <span class="cov8" title="1">newNode := &amp;bucket[K, V]{
                key:   key,
                value: value,
                next:  bucketPtr.next,
        }
        bucketPtr.next = newNode
        segment.size++

        // Check if resize is needed
        if float64(segment.size) &gt; float64(len(segment.buckets))*concurrentLoadFactor </span><span class="cov0" title="0">{
                chm.resizeSegment(segment)
        }</span>

        <span class="cov8" title="1">var zero V
        return zero, true</span> // Key was inserted
}

// Replace replaces the value for existing key only
func (chm *ConcurrentHashMap[K, V]) Replace(key K, value V) (V, bool) <span class="cov8" title="1">{
        hash := chm.hash(key)
        segmentIndex := hash &amp; chm.segmentMask
        segment := chm.segments[segmentIndex]

        segment.mutex.Lock()
        defer segment.mutex.Unlock()

        bucketIndex := hash % uint32(len(segment.buckets))
        bucket := &amp;segment.buckets[bucketIndex]

        for current := bucket.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                if chm.keyEquals(current.key, key) </span><span class="cov8" title="1">{
                        oldValue := current.value
                        current.value = value
                        return oldValue, true
                }</span>
        }

        <span class="cov8" title="1">var zero V
        return zero, false</span>
}

// ReplaceIf replaces the value only if current value equals expected value
func (chm *ConcurrentHashMap[K, V]) ReplaceIf(key K, oldValue, newValue V) bool <span class="cov8" title="1">{
        hash := chm.hash(key)
        segmentIndex := hash &amp; chm.segmentMask
        segment := chm.segments[segmentIndex]

        segment.mutex.Lock()
        defer segment.mutex.Unlock()

        bucketIndex := hash % uint32(len(segment.buckets))
        bucket := &amp;segment.buckets[bucketIndex]

        for current := bucket.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                if chm.keyEquals(current.key, key) </span><span class="cov8" title="1">{
                        if chm.valueEquals(current.value, oldValue) </span><span class="cov8" title="1">{
                                current.value = newValue
                                return true
                        }</span>
                        <span class="cov8" title="1">return false</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// PutAll copies all elements from another Map
func (chm *ConcurrentHashMap[K, V]) PutAll(other *ConcurrentHashMap[K, V]) <span class="cov8" title="1">{
        other.ForEach(func(key K, value V) </span><span class="cov8" title="1">{
                chm.Put(key, value)
        }</span>)
}

// PutAllFromMap copies all elements from Go native map
func (chm *ConcurrentHashMap[K, V]) PutAllFromMap(m map[K]V) <span class="cov8" title="1">{
        for key, value := range m </span><span class="cov8" title="1">{
                chm.Put(key, value)
        }</span>
}

// ToMap converts to Go native map
func (chm *ConcurrentHashMap[K, V]) ToMap() map[K]V <span class="cov8" title="1">{
        result := make(map[K]V)
        chm.ForEach(func(key K, value V) </span><span class="cov8" title="1">{
                result[key] = value
        }</span>)
        <span class="cov8" title="1">return result</span>
}

// Snapshot gets a snapshot of current data
func (chm *ConcurrentHashMap[K, V]) Snapshot() map[K]V <span class="cov8" title="1">{
        return chm.ToMap()
}</span>

// ComputeIfAbsent computes and adds value if key doesn't exist
func (chm *ConcurrentHashMap[K, V]) ComputeIfAbsent(key K, mappingFunction func(K) V) V <span class="cov8" title="1">{
        hash := chm.hash(key)
        segmentIndex := hash &amp; chm.segmentMask
        segment := chm.segments[segmentIndex]

        segment.mutex.Lock()
        defer segment.mutex.Unlock()

        bucketIndex := hash % uint32(len(segment.buckets))
        bucketPtr := &amp;segment.buckets[bucketIndex]

        // Check again (double-checked locking pattern)
        for current := bucketPtr.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                if chm.keyEquals(current.key, key) </span><span class="cov8" title="1">{
                        return current.value
                }</span>
        }

        // Compute new value and add
        <span class="cov8" title="1">newValue := mappingFunction(key)
        newNode := &amp;bucket[K, V]{
                key:   key,
                value: newValue,
                next:  bucketPtr.next,
        }
        bucketPtr.next = newNode
        segment.size++

        // Check if resize is needed
        if float64(segment.size) &gt; float64(len(segment.buckets))*concurrentLoadFactor </span><span class="cov0" title="0">{
                chm.resizeSegment(segment)
        }</span>

        <span class="cov8" title="1">return newValue</span>
}

// ComputeIfPresent recomputes value if key exists
func (chm *ConcurrentHashMap[K, V]) ComputeIfPresent(key K, remappingFunction func(K, V) V) (V, bool) <span class="cov8" title="1">{
        hash := chm.hash(key)
        segmentIndex := hash &amp; chm.segmentMask
        segment := chm.segments[segmentIndex]

        segment.mutex.Lock()
        defer segment.mutex.Unlock()

        bucketIndex := hash % uint32(len(segment.buckets))
        bucket := &amp;segment.buckets[bucketIndex]

        for current := bucket.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                if chm.keyEquals(current.key, key) </span><span class="cov8" title="1">{
                        newValue := remappingFunction(key, current.value)
                        current.value = newValue
                        return newValue, true
                }</span>
        }

        <span class="cov8" title="1">var zero V
        return zero, false</span>
}

// Internal helper methods

// hash computes hash value for key
func (chm *ConcurrentHashMap[K, V]) hash(key K) uint32 <span class="cov8" title="1">{
        // Use reflection to get byte representation of key
        v := reflect.ValueOf(key)
        switch v.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                s := v.String()
                h := uint32(0)
                for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                        h = h*31 + uint32(s[i])
                }</span>
                <span class="cov8" title="1">return h</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return uint32(v.Int())</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return uint32(v.Uint())</span>
        default:<span class="cov0" title="0">
                // For other types, use their string representation
                s := fmt.Sprintf("%v", key)
                h := uint32(0)
                for i := 0; i &lt; len(s); i++ </span><span class="cov0" title="0">{
                        h = h*31 + uint32(s[i])
                }</span>
                <span class="cov0" title="0">return h</span>
        }
}

// keyEquals compares two keys for equality
func (chm *ConcurrentHashMap[K, V]) keyEquals(a, b K) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(a, b)
}</span>

// valueEquals compares two values for equality
func (chm *ConcurrentHashMap[K, V]) valueEquals(a, b V) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(a, b)
}</span>

// resizeSegment resizes the specified segment
func (chm *ConcurrentHashMap[K, V]) resizeSegment(segment *segment[K, V]) <span class="cov8" title="1">{
        oldBuckets := segment.buckets
        newSize := len(oldBuckets) * 2
        newBuckets := make([]bucket[K, V], newSize)

        // Rehash all elements from old buckets to new buckets
        for _, oldBucket := range oldBuckets </span><span class="cov8" title="1">{
                for current := oldBucket.next; current != nil; current = current.next </span><span class="cov8" title="1">{
                        hash := chm.hash(current.key)
                        bucketIndex := hash % uint32(newSize)
                        newNode := &amp;bucket[K, V]{
                                key:   current.key,
                                value: current.value,
                                next:  newBuckets[bucketIndex].next,
                        }
                        newBuckets[bucketIndex].next = newNode
                }</span>
        }

        // Replace old buckets with new buckets
        <span class="cov8" title="1">segment.buckets = newBuckets</span>
}

// nextPowerOfTwo returns the smallest power of 2 greater than or equal to n
func nextPowerOfTwo(n int) int <span class="cov0" title="0">{
        if n &lt;= 1 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">n--
        n |= n &gt;&gt; 1
        n |= n &gt;&gt; 2
        n |= n &gt;&gt; 4
        n |= n &gt;&gt; 8
        n |= n &gt;&gt; 16
        return n + 1</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package maps

import (
        "fmt"
        "github.com/chenjianyu/collections/container/common"
        "strings"
        "sync"
)

// CopyOnWriteMap is a thread-safe map implementation using copy-on-write strategy
// Suitable for scenarios with more reads than writes
type CopyOnWriteMap[K comparable, V any] struct {
        mu   sync.RWMutex
        data map[K]V
}

// NewCopyOnWriteMap creates a new CopyOnWriteMap
func NewCopyOnWriteMap[K comparable, V any]() *CopyOnWriteMap[K, V] <span class="cov8" title="1">{
        return NewCopyOnWriteMapWithCapacity[K, V](0)
}</span>

// NewCopyOnWriteMapWithCapacity creates a new CopyOnWriteMap with initial capacity
func NewCopyOnWriteMapWithCapacity[K comparable, V any](capacity int) *CopyOnWriteMap[K, V] <span class="cov8" title="1">{
        return &amp;CopyOnWriteMap[K, V]{
                data: make(map[K]V, capacity),
        }
}</span>

// CopyOnWriteMapFromMap creates a new CopyOnWriteMap from a Go map
func CopyOnWriteMapFromMap[K comparable, V any](source map[K]V) *CopyOnWriteMap[K, V] <span class="cov8" title="1">{
        m := NewCopyOnWriteMapWithCapacity[K, V](len(source))
        for k, v := range source </span><span class="cov8" title="1">{
                m.Put(k, v)
        }</span>
        <span class="cov8" title="1">return m</span>
}

// Put associates the specified value with the specified key in this map
func (m *CopyOnWriteMap[K, V]) Put(key K, value V) (V, bool) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        oldValue, existed := m.data[key]

        // Copy-on-write: create a new map copy
        newData := make(map[K]V, len(m.data)+1)
        for k, v := range m.data </span><span class="cov8" title="1">{
                newData[k] = v
        }</span>
        <span class="cov8" title="1">newData[key] = value
        m.data = newData

        return oldValue, existed</span>
}

// Get returns the value mapped to the specified key
func (m *CopyOnWriteMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        value, exists := m.data[key]
        return value, exists
}</span>

// Remove if exists, removes mapping relationship for the key from this map
func (m *CopyOnWriteMap[K, V]) Remove(key K) (V, bool) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        oldValue, existed := m.data[key]
        if !existed </span><span class="cov8" title="1">{
                return oldValue, false
        }</span>

        // Copy-on-write: create a new map copy
        <span class="cov8" title="1">newData := make(map[K]V, len(m.data)-1)
        for k, v := range m.data </span><span class="cov8" title="1">{
                if k != key </span><span class="cov8" title="1">{
                        newData[k] = v
                }</span>
        }
        <span class="cov8" title="1">m.data = newData

        return oldValue, true</span>
}

// ContainsKey if this map contains mapping relationship for the specified key, returns true
func (m *CopyOnWriteMap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        _, exists := m.data[key]
        return exists
}</span>

// ContainsValue if this map maps one or more keys to the specified value, returns true
func (m *CopyOnWriteMap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for _, v := range m.data </span><span class="cov8" title="1">{
                if Equal(v, value) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Size returns the number of key-value mapping relationships in this map
func (m *CopyOnWriteMap[K, V]) Size() int <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return len(m.data)
}</span>

// IsEmpty if this map does not contain key-value mapping relationships, returns true
func (m *CopyOnWriteMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return m.Size() == 0
}</span>

// Clear removes all mapping relationships from this map
func (m *CopyOnWriteMap[K, V]) Clear() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.data = make(map[K]V)
}</span>

// Keys returns the keys contained in this map
func (m *CopyOnWriteMap[K, V]) Keys() []K <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        keys := make([]K, 0, len(m.data))
        for k := range m.data </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys</span>
}

// Values returns the values contained in this map
func (m *CopyOnWriteMap[K, V]) Values() []V <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        values := make([]V, 0, len(m.data))
        for _, v := range m.data </span><span class="cov8" title="1">{
                values = append(values, v)
        }</span>
        <span class="cov8" title="1">return values</span>
}

// Entries returns the mapping relationships contained in this map
func (m *CopyOnWriteMap[K, V]) Entries() []Pair[K, V] <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        entries := make([]Pair[K, V], 0, len(m.data))
        for k, v := range m.data </span><span class="cov0" title="0">{
                entries = append(entries, NewPair(k, v))
        }</span>
        <span class="cov0" title="0">return entries</span>
}

// ForEach executes the given operation for each entry in this map
func (m *CopyOnWriteMap[K, V]) ForEach(f func(K, V)) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for k, v := range m.data </span><span class="cov8" title="1">{
                f(k, v)
        }</span>
}

// String returns the string representation of the map
func (m *CopyOnWriteMap[K, V]) String() string <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if len(m.data) == 0 </span><span class="cov8" title="1">{
                return "{}"
        }</span>

        <span class="cov8" title="1">var builder strings.Builder
        builder.WriteString("{")
        first := true
        for k, v := range m.data </span><span class="cov8" title="1">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("%v=%v", k, v))
                first = false</span>
        }
        <span class="cov8" title="1">builder.WriteString("}")
        return builder.String()</span>
}

// PutAll copies all mapping relationships from the specified map to this map
func (m *CopyOnWriteMap[K, V]) PutAll(other Map[K, V]) <span class="cov8" title="1">{
        other.ForEach(func(k K, v V) </span><span class="cov8" title="1">{
                m.Put(k, v)
        }</span>)
}

// PutAllFromMap copies all mappings from a Go map to this map
func (m *CopyOnWriteMap[K, V]) PutAllFromMap(source map[K]V) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        newData := make(map[K]V, len(m.data)+len(source))
        for k, v := range m.data </span><span class="cov8" title="1">{
                newData[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range source </span><span class="cov8" title="1">{
                newData[k] = v
        }</span>
        <span class="cov8" title="1">m.data = newData</span>
}

// ToMap returns a copy of the map as a Go map
func (m *CopyOnWriteMap[K, V]) ToMap() map[K]V <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        copy := make(map[K]V, len(m.data))
        for k, v := range m.data </span><span class="cov8" title="1">{
                copy[k] = v
        }</span>
        <span class="cov8" title="1">return copy</span>
}

// Snapshot returns a snapshot of the current map
func (m *CopyOnWriteMap[K, V]) Snapshot() map[K]V <span class="cov8" title="1">{
        return m.ToMap()
}</span>

// PutIfAbsent puts the value if the key is not present
func (m *CopyOnWriteMap[K, V]) PutIfAbsent(key K, value V) (V, bool) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        oldValue, exists := m.data[key]
        if exists </span><span class="cov8" title="1">{
                return oldValue, false
        }</span>
        <span class="cov8" title="1">newData := make(map[K]V, len(m.data)+1)
        for k, v := range m.data </span><span class="cov0" title="0">{
                newData[k] = v
        }</span>
        <span class="cov8" title="1">newData[key] = value
        m.data = newData
        return oldValue, true</span>
}

// Replace replaces the value for the key if present
func (m *CopyOnWriteMap[K, V]) Replace(key K, value V) (V, bool) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        oldValue, exists := m.data[key]
        if !exists </span><span class="cov8" title="1">{
                return oldValue, false
        }</span>
        <span class="cov8" title="1">newData := make(map[K]V, len(m.data))
        for k, v := range m.data </span><span class="cov8" title="1">{
                newData[k] = v
        }</span>
        <span class="cov8" title="1">newData[key] = value
        m.data = newData
        return oldValue, true</span>
}

// ReplaceIf replaces the value for the key if it matches the old value
func (m *CopyOnWriteMap[K, V]) ReplaceIf(key K, oldValue V, newValue V) bool <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        current, exists := m.data[key]
        if !exists || !common.Equal(current, oldValue) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">newData := make(map[K]V, len(m.data))
        for k, v := range m.data </span><span class="cov8" title="1">{
                newData[k] = v
        }</span>
        <span class="cov8" title="1">newData[key] = newValue
        m.data = newData
        return true</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package maps

import (
        "fmt"
        "strings"
        "sync"
)

// Use existing color type as node color
// color type is already defined in treeset.go

// Linked list node threshold, convert to red-black tree when list length exceeds this value
const treeifyThreshold = 8

// Red-black tree node threshold, convert to linked list when tree node count is less than this value
const untreeifyThreshold = 6

// Minimum treeify capacity, when hash table capacity is less than this value, prioritize expansion over treeification
const minTreeifyCapacity = 64

// Initial hash table size
const initialCapacity = 16

// Load factor, expand when element count exceeds capacity multiplied by load factor
const loadFactor = 0.75

// LinkedHashMapNode is a linked list/red-black tree node
type LinkedHashMapNode[K comparable, V any] struct {
        key   K
        value V
        hash  uint64

        // Linked list pointers
        next *LinkedHashMapNode[K, V]

        // Red-black tree pointers
        left   *LinkedHashMapNode[K, V]
        right  *LinkedHashMapNode[K, V]
        parent *LinkedHashMapNode[K, V]
        color  color

        // Mark whether node is a tree node
        isTreeNode bool
}

// LinkedHashMap is a Map implementation based on separate chaining and red-black trees
type LinkedHashMap[K comparable, V any] struct {
        table     []*LinkedHashMapNode[K, V] // Hash bucket array
        size      int                        // Element count
        threshold int                        // Resize threshold
        mutex     sync.RWMutex               // Read-write lock for thread safety
}

// NewLinkedHashMap creates a new LinkedHashMap
func NewLinkedHashMap[K comparable, V any]() *LinkedHashMap[K, V] <span class="cov8" title="1">{
        capacity := initialCapacity
        return &amp;LinkedHashMap[K, V]{
                table:     make([]*LinkedHashMapNode[K, V], capacity),
                size:      0,
                threshold: int(float64(capacity) * loadFactor),
        }
}</span>

// NewLinkedHashMapWithCapacity creates a LinkedHashMap with specified initial capacity
func NewLinkedHashMapWithCapacity[K comparable, V any](capacity int) *LinkedHashMap[K, V] <span class="cov8" title="1">{
        if capacity &lt; initialCapacity </span><span class="cov8" title="1">{
                capacity = initialCapacity
        }</span> else<span class="cov0" title="0"> {
                // Ensure capacity is a power of 2
                capacity = tableSizeFor(capacity)
        }</span>

        <span class="cov8" title="1">return &amp;LinkedHashMap[K, V]{
                table:     make([]*LinkedHashMapNode[K, V], capacity),
                size:      0,
                threshold: int(float64(capacity) * loadFactor),
        }</span>
}

// tableSizeFor returns the smallest power of 2 greater than or equal to cap
func tableSizeFor(cap int) int <span class="cov0" title="0">{
        n := cap - 1
        n |= n &gt;&gt; 1
        n |= n &gt;&gt; 2
        n |= n &gt;&gt; 4
        n |= n &gt;&gt; 8
        n |= n &gt;&gt; 16
        n |= n &gt;&gt; 32
        return n + 1
}</span>

// hash calculates the hash value of the key
func (m *LinkedHashMap[K, V]) hash(key K) uint64 <span class="cov8" title="1">{
        return Hash(key)
}</span>

// Put associates the specified value with the specified key in this map
func (m *LinkedHashMap[K, V]) Put(key K, value V) (V, bool) <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        var oldValue V
        existed := false

        hashValue := m.hash(key)
        index := int(hashValue % uint64(len(m.table)))

        // If bucket is empty, create new node
        if m.table[index] == nil </span><span class="cov8" title="1">{
                m.table[index] = &amp;LinkedHashMapNode[K, V]{
                        key:   key,
                        value: value,
                        hash:  hashValue,
                }
                m.size++

                // Check if resize is needed
                m.checkResize()

                return oldValue, existed
        }</span>

        // If it's a tree node, use tree search and insertion
        <span class="cov8" title="1">if m.table[index].isTreeNode </span><span class="cov0" title="0">{
                return m.putTreeVal(index, key, value, hashValue)
        }</span>

        // Linked list search and insertion
        <span class="cov8" title="1">p := m.table[index]
        var prev *LinkedHashMapNode[K, V]
        count := 0

        // Traverse the linked list
        for p != nil </span><span class="cov8" title="1">{
                count++

                // If same key is found, update value
                if p.hash == hashValue &amp;&amp; Equal(p.key, key) </span><span class="cov8" title="1">{
                        oldValue = p.value
                        p.value = value
                        return oldValue, true
                }</span>

                <span class="cov8" title="1">prev = p
                p = p.next</span>
        }

        // No same key found, add new node to end of list
        <span class="cov8" title="1">newNode := &amp;LinkedHashMapNode[K, V]{
                key:   key,
                value: value,
                hash:  hashValue,
        }
        prev.next = newNode
        m.size++

        // Check if linked list needs to be converted to red-black tree
        if count &gt;= treeifyThreshold-1 </span><span class="cov0" title="0">{
                m.treeifyBin(index)
        }</span>

        // Check if resize is needed
        <span class="cov8" title="1">m.checkResize()

        return oldValue, existed</span>
}

// putTreeVal inserts or updates node in red-black tree
func (m *LinkedHashMap[K, V]) putTreeVal(index int, key K, value V, hash uint64) (V, bool) <span class="cov0" title="0">{
        var oldValue V
        existed := false

        root := m.table[index]
        p := root

        // Tree search
        for p != nil </span><span class="cov0" title="0">{
                cmp := 0
                if p.hash &gt; hash </span><span class="cov0" title="0">{
                        cmp = -1
                }</span> else<span class="cov0" title="0"> if p.hash &lt; hash </span><span class="cov0" title="0">{
                        cmp = 1
                }</span> else<span class="cov0" title="0"> if Equal(key, p.key) </span><span class="cov0" title="0">{
                        // Found same key, update value
                        oldValue = p.value
                        p.value = value
                        return oldValue, true
                }</span> else<span class="cov0" title="0"> {
                        // Same hash but different key, use key comparison
                        cmp = Compare(key, p.key)
                }</span>

                // Decide left or right based on comparison result
                <span class="cov0" title="0">if cmp &lt; 0 </span><span class="cov0" title="0">{
                        if p.left == nil </span><span class="cov0" title="0">{
                                // Insert as left child
                                p.left = &amp;LinkedHashMapNode[K, V]{
                                        key:        key,
                                        value:      value,
                                        hash:       hash,
                                        isTreeNode: true,
                                        parent:     p,
                                        color:      red,
                                }
                                m.size++
                                m.balanceInsertion(root, p.left)
                                return oldValue, existed
                        }</span>
                        <span class="cov0" title="0">p = p.left</span>
                } else<span class="cov0" title="0"> {
                        if p.right == nil </span><span class="cov0" title="0">{
                                // Insert as right child
                                p.right = &amp;LinkedHashMapNode[K, V]{
                                        key:        key,
                                        value:      value,
                                        hash:       hash,
                                        isTreeNode: true,
                                        parent:     p,
                                        color:      red,
                                }
                                m.size++
                                m.balanceInsertion(root, p.right)
                                return oldValue, existed
                        }</span>
                        <span class="cov0" title="0">p = p.right</span>
                }
        }

        // If tree is empty, create root node
        <span class="cov0" title="0">m.table[index] = &amp;LinkedHashMapNode[K, V]{
                key:        key,
                value:      value,
                hash:       hash,
                isTreeNode: true,
                color:      black, // Root node is black
        }
        m.size++

        return oldValue, existed</span>
}

// balanceInsertion after insertion
func (m *LinkedHashMap[K, V]) balanceInsertion(root *LinkedHashMapNode[K, V], x *LinkedHashMapNode[K, V]) *LinkedHashMapNode[K, V] <span class="cov0" title="0">{
        // Red-black tree balancing adjustment
        x.color = red

        for x != nil &amp;&amp; x != root &amp;&amp; x.parent.color == red </span><span class="cov0" title="0">{
                if parentOf(x) == leftOf(parentOf(parentOf(x))) </span><span class="cov0" title="0">{
                        y := rightOf(parentOf(parentOf(x)))
                        if colorOf(y) == red </span><span class="cov0" title="0">{
                                setColor(parentOf(x), black)
                                setColor(y, black)
                                setColor(parentOf(parentOf(x)), red)
                                x = parentOf(parentOf(x))
                        }</span> else<span class="cov0" title="0"> {
                                if x == rightOf(parentOf(x)) </span><span class="cov0" title="0">{
                                        x = parentOf(x)
                                        root = m.rotateLeft(root, x)
                                }</span>
                                <span class="cov0" title="0">setColor(parentOf(x), black)
                                setColor(parentOf(parentOf(x)), red)
                                root = m.rotateRight(root, parentOf(parentOf(x)))</span>
                        }
                } else<span class="cov0" title="0"> {
                        y := leftOf(parentOf(parentOf(x)))
                        if colorOf(y) == red </span><span class="cov0" title="0">{
                                setColor(parentOf(x), black)
                                setColor(y, black)
                                setColor(parentOf(parentOf(x)), red)
                                x = parentOf(parentOf(x))
                        }</span> else<span class="cov0" title="0"> {
                                if x == leftOf(parentOf(x)) </span><span class="cov0" title="0">{
                                        x = parentOf(x)
                                        root = m.rotateRight(root, x)
                                }</span>
                                <span class="cov0" title="0">setColor(parentOf(x), black)
                                setColor(parentOf(parentOf(x)), red)
                                root = m.rotateLeft(root, parentOf(parentOf(x)))</span>
                        }
                }
        }

        <span class="cov0" title="0">root.color = black
        return root</span>
}

// rotateLeft left rotation
func (m *LinkedHashMap[K, V]) rotateLeft(root *LinkedHashMapNode[K, V], p *LinkedHashMapNode[K, V]) *LinkedHashMapNode[K, V] <span class="cov0" title="0">{
        if p != nil </span><span class="cov0" title="0">{
                r := p.right
                p.right = r.left
                if r.left != nil </span><span class="cov0" title="0">{
                        r.left.parent = p
                }</span>
                <span class="cov0" title="0">r.parent = p.parent

                if p.parent == nil </span><span class="cov0" title="0">{
                        root = r
                }</span> else<span class="cov0" title="0"> if p == p.parent.left </span><span class="cov0" title="0">{
                        p.parent.left = r
                }</span> else<span class="cov0" title="0"> {
                        p.parent.right = r
                }</span>

                <span class="cov0" title="0">r.left = p
                p.parent = r</span>
        }
        <span class="cov0" title="0">return root</span>
}

// rotateRight right rotation
func (m *LinkedHashMap[K, V]) rotateRight(root *LinkedHashMapNode[K, V], p *LinkedHashMapNode[K, V]) *LinkedHashMapNode[K, V] <span class="cov0" title="0">{
        if p != nil </span><span class="cov0" title="0">{
                l := p.left
                p.left = l.right
                if l.right != nil </span><span class="cov0" title="0">{
                        l.right.parent = p
                }</span>
                <span class="cov0" title="0">l.parent = p.parent

                if p.parent == nil </span><span class="cov0" title="0">{
                        root = l
                }</span> else<span class="cov0" title="0"> if p == p.parent.right </span><span class="cov0" title="0">{
                        p.parent.right = l
                }</span> else<span class="cov0" title="0"> {
                        p.parent.left = l
                }</span>

                <span class="cov0" title="0">l.right = p
                p.parent = l</span>
        }
        <span class="cov0" title="0">return root</span>
}

// parentOf get node's parent
func parentOf[K comparable, V any](p *LinkedHashMapNode[K, V]) *LinkedHashMapNode[K, V] <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return p.parent</span>
}

// leftOf get node's left child
func leftOf[K comparable, V any](p *LinkedHashMapNode[K, V]) *LinkedHashMapNode[K, V] <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return p.left</span>
}

// rightOf get node's right child
func rightOf[K comparable, V any](p *LinkedHashMapNode[K, V]) *LinkedHashMapNode[K, V] <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return p.right</span>
}

// colorOf get node's color
func colorOf[K comparable, V any](p *LinkedHashMapNode[K, V]) color <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return black
        }</span>
        <span class="cov0" title="0">return p.color</span>
}

// setColor set node's color
func setColor[K comparable, V any](p *LinkedHashMapNode[K, V], c color) <span class="cov0" title="0">{
        if p != nil </span><span class="cov0" title="0">{
                p.color = c
        }</span>
}

// treeifyBin convert specified index's list to red-black tree
func (m *LinkedHashMap[K, V]) treeifyBin(index int) <span class="cov0" title="0">{
        // If hash table capacity is less than minimum treeify capacity, prioritize expansion
        if len(m.table) &lt; minTreeifyCapacity </span><span class="cov0" title="0">{
                m.resize()
                return
        }</span>

        // Convert list to red-black tree
        <span class="cov0" title="0">root := m.table[index]
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Mark all nodes as tree nodes
        <span class="cov0" title="0">p := root
        for p != nil </span><span class="cov0" title="0">{
                p.isTreeNode = true
                p = p.next
        }</span>

        // Build red-black tree
        <span class="cov0" title="0">root = m.buildTree(root)
        m.table[index] = root</span>
}

// buildTree build red-black tree from list
func (m *LinkedHashMap[K, V]) buildTree(head *LinkedHashMapNode[K, V]) *LinkedHashMapNode[K, V] <span class="cov0" title="0">{
        var root *LinkedHashMapNode[K, V]

        // Traverse list, insert each node to red-black tree
        p := head
        for p != nil </span><span class="cov0" title="0">{
                next := p.next
                p.left = nil
                p.right = nil

                if root == nil </span><span class="cov0" title="0">{
                        p.parent = nil
                        p.color = black
                        root = p
                }</span> else<span class="cov0" title="0"> {
                        k := p.key
                        h := p.hash
                        dir := 0

                        // Find insert position
                        cur := root
                        for </span><span class="cov0" title="0">{
                                ph := cur.hash
                                pk := cur.key
                                if h &lt; ph </span><span class="cov0" title="0">{
                                        dir = -1
                                }</span> else<span class="cov0" title="0"> if h &gt; ph </span><span class="cov0" title="0">{
                                        dir = 1
                                }</span> else<span class="cov0" title="0"> if Equal(k, pk) </span><span class="cov0" title="0">{
                                        dir = 0
                                }</span> else<span class="cov0" title="0"> {
                                        dir = Compare(k, pk)
                                }</span>

                                <span class="cov0" title="0">if dir &lt; 0 </span><span class="cov0" title="0">{
                                        if cur.left == nil </span><span class="cov0" title="0">{
                                                cur.left = p
                                                break</span>
                                        }
                                        <span class="cov0" title="0">cur = cur.left</span>
                                } else<span class="cov0" title="0"> {
                                        if cur.right == nil </span><span class="cov0" title="0">{
                                                cur.right = p
                                                break</span>
                                        }
                                        <span class="cov0" title="0">cur = cur.right</span>
                                }
                        }

                        <span class="cov0" title="0">p.parent = cur
                        p.color = red

                        // Balance red-black tree
                        root = m.balanceInsertion(root, p)</span>
                }

                <span class="cov0" title="0">p = next</span>
        }

        <span class="cov0" title="0">return root</span>
}

// checkResize check if resize is needed
func (m *LinkedHashMap[K, V]) checkResize() <span class="cov8" title="1">{
        if m.size &gt; m.threshold </span><span class="cov8" title="1">{
                m.resize()
        }</span>
}

// resize resize hash table
func (m *LinkedHashMap[K, V]) resize() <span class="cov8" title="1">{
        oldCap := len(m.table)
        oldTab := m.table

        // Compute new capacity
        newCap := oldCap * 2
        if newCap &lt; initialCapacity </span><span class="cov0" title="0">{
                newCap = initialCapacity
        }</span>

        // Create new table
        <span class="cov8" title="1">newTab := make([]*LinkedHashMapNode[K, V], newCap)
        m.table = newTab
        m.threshold = int(float64(newCap) * loadFactor)

        // If old table is empty, directly return
        if oldCap == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Reallocate old table elements to new table
        <span class="cov8" title="1">for i := 0; i &lt; oldCap; i++ </span><span class="cov8" title="1">{
                e := oldTab[i]
                if e == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Clear old table reference
                <span class="cov8" title="1">oldTab[i] = nil

                // If it's a single node
                if e.next == nil </span><span class="cov8" title="1">{
                        newIdx := int(e.hash % uint64(newCap))
                        newTab[newIdx] = e
                        continue</span>
                }

                // If it's a tree node
                <span class="cov8" title="1">if e.isTreeNode </span><span class="cov0" title="0">{
                        m.splitTreeBin(newTab, e, i, oldCap)
                        continue</span>
                }

                // If it's a list, split into two lists
                // One list placed at original position, one list placed at original position+oldCap
                <span class="cov8" title="1">var loHead, loTail, hiHead, hiTail *LinkedHashMapNode[K, V]

                // Traverse list
                for e != nil </span><span class="cov8" title="1">{
                        next := e.next

                        // Decide where to put the node
                        if (e.hash &amp; uint64(oldCap)) == 0 </span><span class="cov8" title="1">{
                                // Place at original position
                                if loTail == nil </span><span class="cov8" title="1">{
                                        loHead = e
                                }</span> else<span class="cov8" title="1"> {
                                        loTail.next = e
                                }</span>
                                <span class="cov8" title="1">loTail = e</span>
                        } else<span class="cov0" title="0"> {
                                // Place at original position+oldCap
                                if hiTail == nil </span><span class="cov0" title="0">{
                                        hiHead = e
                                }</span> else<span class="cov0" title="0"> {
                                        hiTail.next = e
                                }</span>
                                <span class="cov0" title="0">hiTail = e</span>
                        }

                        <span class="cov8" title="1">e = next</span>
                }

                // Update list reference
                <span class="cov8" title="1">if loTail != nil </span><span class="cov8" title="1">{
                        loTail.next = nil
                        newTab[i] = loHead
                }</span>

                <span class="cov8" title="1">if hiTail != nil </span><span class="cov0" title="0">{
                        hiTail.next = nil
                        newTab[i+oldCap] = hiHead
                }</span>
        }
}

// splitTreeBin split tree node
func (m *LinkedHashMap[K, V]) splitTreeBin(newTab []*LinkedHashMapNode[K, V], root *LinkedHashMapNode[K, V], index, oldCap int) <span class="cov0" title="0">{
        // Convert tree node back to list
        if len(newTab) &lt;= untreeifyThreshold </span><span class="cov0" title="0">{
                var head, tail *LinkedHashMapNode[K, V]

                // Traverse tree, build list
                m.treeToList(root, &amp;head, &amp;tail)

                // Split list
                var loHead, loTail, hiHead, hiTail *LinkedHashMapNode[K, V]
                p := head

                for p != nil </span><span class="cov0" title="0">{
                        next := p.next
                        p.left = nil
                        p.right = nil
                        p.parent = nil
                        p.isTreeNode = false

                        // Decide where to put the node
                        if (p.hash &amp; uint64(oldCap)) == 0 </span><span class="cov0" title="0">{
                                // Place at original position
                                if loTail == nil </span><span class="cov0" title="0">{
                                        loHead = p
                                }</span> else<span class="cov0" title="0"> {
                                        loTail.next = p
                                }</span>
                                <span class="cov0" title="0">loTail = p</span>
                        } else<span class="cov0" title="0"> {
                                // Place at original position+oldCap
                                if hiTail == nil </span><span class="cov0" title="0">{
                                        hiHead = p
                                }</span> else<span class="cov0" title="0"> {
                                        hiTail.next = p
                                }</span>
                                <span class="cov0" title="0">hiTail = p</span>
                        }

                        <span class="cov0" title="0">p = next</span>
                }

                // Update list reference
                <span class="cov0" title="0">if loTail != nil </span><span class="cov0" title="0">{
                        loTail.next = nil
                        newTab[index] = loHead
                }</span>

                <span class="cov0" title="0">if hiTail != nil </span><span class="cov0" title="0">{
                        hiTail.next = nil
                        newTab[index+oldCap] = hiHead
                }</span>
        } else<span class="cov0" title="0"> {
                // Split tree
                var loTree, hiTree *LinkedHashMapNode[K, V]

                // Traverse tree, build two new trees
                m.splitTree(root, &amp;loTree, &amp;hiTree, oldCap)

                // Update tree reference
                if loTree != nil </span><span class="cov0" title="0">{
                        newTab[index] = loTree
                }</span>

                <span class="cov0" title="0">if hiTree != nil </span><span class="cov0" title="0">{
                        newTab[index+oldCap] = hiTree
                }</span>
        }
}

// treeToList convert tree to list
func (m *LinkedHashMap[K, V]) treeToList(root *LinkedHashMapNode[K, V], head, tail **LinkedHashMapNode[K, V]) <span class="cov0" title="0">{
        // In-order traverse tree, build list
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Recursive left sub-tree
        <span class="cov0" title="0">m.treeToList(root.left, head, tail)

        // Handle current node
        root.left = nil
        root.right = nil
        root.parent = nil
        root.isTreeNode = false

        if *tail == nil </span><span class="cov0" title="0">{
                *head = root
        }</span> else<span class="cov0" title="0"> {
                (*tail).next = root
        }</span>
        <span class="cov0" title="0">*tail = root

        // Recursive right sub-tree
        m.treeToList(root.right, head, tail)</span>
}

// splitTree split tree
func (m *LinkedHashMap[K, V]) splitTree(root *LinkedHashMapNode[K, V], loTree, hiTree **LinkedHashMapNode[K, V], oldCap int) <span class="cov0" title="0">{
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Save sub-node reference
        <span class="cov0" title="0">left := root.left
        right := root.right

        // Clean current node reference
        root.left = nil
        root.right = nil
        root.parent = nil

        // Decide where to put the node
        if (root.hash &amp; uint64(oldCap)) == 0 </span><span class="cov0" title="0">{
                // Place at original position
                if *loTree == nil </span><span class="cov0" title="0">{
                        *loTree = root
                        root.color = black
                }</span> else<span class="cov0" title="0"> {
                        // Simple insert to loTree, no balancing
                        m.insertNodeSimple(loTree, root)
                }</span>
        } else<span class="cov0" title="0"> {
                // Place at original position+oldCap
                if *hiTree == nil </span><span class="cov0" title="0">{
                        *hiTree = root
                        root.color = black
                }</span> else<span class="cov0" title="0"> {
                        // Simple insert to hiTree, no balancing
                        m.insertNodeSimple(hiTree, root)
                }</span>
        }

        // Recursive handle sub-tree
        <span class="cov0" title="0">m.splitTree(left, loTree, hiTree, oldCap)
        m.splitTree(right, loTree, hiTree, oldCap)</span>
}

// insertNodeSimple simple insert node to tree, no balancing
func (m *LinkedHashMap[K, V]) insertNodeSimple(root **LinkedHashMapNode[K, V], node *LinkedHashMapNode[K, V]) <span class="cov0" title="0">{
        p := *root
        for </span><span class="cov0" title="0">{
                cmp := 0
                if node.hash &lt; p.hash </span><span class="cov0" title="0">{
                        cmp = -1
                }</span> else<span class="cov0" title="0"> if node.hash &gt; p.hash </span><span class="cov0" title="0">{
                        cmp = 1
                }</span> else<span class="cov0" title="0"> {
                        cmp = Compare(node.key, p.key)
                }</span>

                <span class="cov0" title="0">if cmp &lt; 0 </span><span class="cov0" title="0">{
                        if p.left == nil </span><span class="cov0" title="0">{
                                p.left = node
                                node.parent = p
                                node.color = red
                                break</span>
                        }
                        <span class="cov0" title="0">p = p.left</span>
                } else<span class="cov0" title="0"> {
                        if p.right == nil </span><span class="cov0" title="0">{
                                p.right = node
                                node.parent = p
                                node.color = red
                                break</span>
                        }
                        <span class="cov0" title="0">p = p.right</span>
                }
        }
}

// Get return value mapped to the key
func (m *LinkedHashMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        hashValue := m.hash(key)
        index := int(hashValue % uint64(len(m.table)))

        // If bucket is empty, return zero value
        if m.table[index] == nil </span><span class="cov8" title="1">{
                return *new(V), false
        }</span>

        // If it's a tree node, use tree search
        <span class="cov8" title="1">if m.table[index].isTreeNode </span><span class="cov0" title="0">{
                return m.getTreeVal(m.table[index], key, hashValue)
        }</span>

        // Linked list search
        <span class="cov8" title="1">p := m.table[index]
        for p != nil </span><span class="cov8" title="1">{
                if p.hash == hashValue &amp;&amp; Equal(p.key, key) </span><span class="cov8" title="1">{
                        return p.value, true
                }</span>
                <span class="cov8" title="1">p = p.next</span>
        }

        <span class="cov8" title="1">return *new(V), false</span>
}

// getTreeVal search node in red-black tree
func (m *LinkedHashMap[K, V]) getTreeVal(root *LinkedHashMapNode[K, V], key K, hash uint64) (V, bool) <span class="cov0" title="0">{
        p := root

        // Tree search
        for p != nil </span><span class="cov0" title="0">{
                cmp := 0
                if p.hash &gt; hash </span><span class="cov0" title="0">{
                        cmp = -1
                }</span> else<span class="cov0" title="0"> if p.hash &lt; hash </span><span class="cov0" title="0">{
                        cmp = 1
                }</span> else<span class="cov0" title="0"> if Equal(key, p.key) </span><span class="cov0" title="0">{
                        // Find same key, return value
                        return p.value, true
                }</span> else<span class="cov0" title="0"> {
                        // Hash same but different key, use key comparison
                        cmp = Compare(key, p.key)
                }</span>

                // Decide left or right based on comparison result
                <span class="cov0" title="0">if cmp &lt; 0 </span><span class="cov0" title="0">{
                        p = p.left
                }</span> else<span class="cov0" title="0"> {
                        p = p.right
                }</span>
        }

        <span class="cov0" title="0">return *new(V), false</span>
}

// Remove if exists, removes mapping relationship for the key
func (m *LinkedHashMap[K, V]) Remove(key K) (V, bool) <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        hashValue := m.hash(key)
        index := int(hashValue % uint64(len(m.table)))

        // If bucket is empty, return zero value
        if m.table[index] == nil </span><span class="cov0" title="0">{
                return *new(V), false
        }</span>

        // If it's a tree node, use tree delete
        <span class="cov8" title="1">if m.table[index].isTreeNode </span><span class="cov0" title="0">{
                return m.removeTreeNode(index, key, hashValue)
        }</span>

        // Linked list delete
        <span class="cov8" title="1">p := m.table[index]
        var prev *LinkedHashMapNode[K, V]

        for p != nil </span><span class="cov8" title="1">{
                if p.hash == hashValue &amp;&amp; Equal(p.key, key) </span><span class="cov8" title="1">{
                        // Find node to delete
                        oldValue := p.value

                        if prev == nil </span><span class="cov8" title="1">{
                                // Delete list head
                                m.table[index] = p.next
                        }</span> else<span class="cov0" title="0"> {
                                // Delete list middle or tail
                                prev.next = p.next
                        }</span>

                        <span class="cov8" title="1">m.size--
                        return oldValue, true</span>
                }

                <span class="cov0" title="0">prev = p
                p = p.next</span>
        }

        <span class="cov0" title="0">return *new(V), false</span>
}

// removeTreeNode remove node from red-black tree
func (m *LinkedHashMap[K, V]) removeTreeNode(index int, key K, hash uint64) (V, bool) <span class="cov0" title="0">{
        root := m.table[index]
        p := root

        // Find node to delete
        for p != nil </span><span class="cov0" title="0">{
                cmp := 0
                if p.hash &gt; hash </span><span class="cov0" title="0">{
                        cmp = -1
                }</span> else<span class="cov0" title="0"> if p.hash &lt; hash </span><span class="cov0" title="0">{
                        cmp = 1
                }</span> else<span class="cov0" title="0"> if Equal(key, p.key) </span><span class="cov0" title="0">{
                        // Find node to delete
                        break</span>
                } else<span class="cov0" title="0"> {
                        // Hash same but different key, use key comparison
                        cmp = Compare(key, p.key)
                }</span>

                // Decide left or right based on comparison result
                <span class="cov0" title="0">if cmp &lt; 0 </span><span class="cov0" title="0">{
                        p = p.left
                }</span> else<span class="cov0" title="0"> {
                        p = p.right
                }</span>
        }

        // If node is not found, return zero value
        <span class="cov0" title="0">if p == nil </span><span class="cov0" title="0">{
                return *new(V), false
        }</span>

        <span class="cov0" title="0">oldValue := p.value

        // Delete node
        if p.left != nil &amp;&amp; p.right != nil </span><span class="cov0" title="0">{
                // If node has two children, find successor
                s := p.right
                for s.left != nil </span><span class="cov0" title="0">{
                        s = s.left
                }</span>

                // Replace current node value with successor value
                <span class="cov0" title="0">p.key = s.key
                p.value = s.value
                p.hash = s.hash

                // Delete successor
                if s.parent == p </span><span class="cov0" title="0">{
                        p.right = s.right
                        if s.right != nil </span><span class="cov0" title="0">{
                                s.right.parent = p
                        }</span>
                } else<span class="cov0" title="0"> {
                        s.parent.left = s.right
                        if s.right != nil </span><span class="cov0" title="0">{
                                s.right.parent = s.parent
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // If node has at most one child
                replacement := p.left
                if p.left == nil </span><span class="cov0" title="0">{
                        replacement = p.right
                }</span>

                // Replace node with child node
                <span class="cov0" title="0">if p.parent == nil </span><span class="cov0" title="0">{
                        // If it's a root node
                        m.table[index] = replacement
                }</span> else<span class="cov0" title="0"> if p == p.parent.left </span><span class="cov0" title="0">{
                        p.parent.left = replacement
                }</span> else<span class="cov0" title="0"> {
                        p.parent.right = replacement
                }</span>

                <span class="cov0" title="0">if replacement != nil </span><span class="cov0" title="0">{
                        replacement.parent = p.parent
                }</span>
        }

        // Balance red-black tree
        <span class="cov0" title="0">if p.color == black </span><span class="cov0" title="0">{
                m.balanceDeletion(root, p)
        }</span>

        <span class="cov0" title="0">m.size--

        // If tree is too small, convert to list
        if m.size &lt;= untreeifyThreshold </span><span class="cov0" title="0">{
                m.untreeify(index)
        }</span>

        <span class="cov0" title="0">return oldValue, true</span>
}

// balanceDeletion after deletion
func (m *LinkedHashMap[K, V]) balanceDeletion(root *LinkedHashMapNode[K, V], x *LinkedHashMapNode[K, V]) *LinkedHashMapNode[K, V] <span class="cov0" title="0">{
        // Red-black tree delete balancing adjustment
        for x != root &amp;&amp; colorOf(x) == black </span><span class="cov0" title="0">{
                if x == leftOf(parentOf(x)) </span><span class="cov0" title="0">{
                        sib := rightOf(parentOf(x))

                        if colorOf(sib) == red </span><span class="cov0" title="0">{
                                setColor(sib, black)
                                setColor(parentOf(x), red)
                                root = m.rotateLeft(root, parentOf(x))
                                sib = rightOf(parentOf(x))
                        }</span>

                        <span class="cov0" title="0">if colorOf(leftOf(sib)) == black &amp;&amp; colorOf(rightOf(sib)) == black </span><span class="cov0" title="0">{
                                setColor(sib, red)
                                x = parentOf(x)
                        }</span> else<span class="cov0" title="0"> {
                                if colorOf(rightOf(sib)) == black </span><span class="cov0" title="0">{
                                        setColor(leftOf(sib), black)
                                        setColor(sib, red)
                                        root = m.rotateRight(root, sib)
                                        sib = rightOf(parentOf(x))
                                }</span>
                                <span class="cov0" title="0">setColor(sib, colorOf(parentOf(x)))
                                setColor(parentOf(x), black)
                                setColor(rightOf(sib), black)
                                root = m.rotateLeft(root, parentOf(x))
                                x = root</span>
                        }
                } else<span class="cov0" title="0"> {
                        sib := leftOf(parentOf(x))

                        if colorOf(sib) == red </span><span class="cov0" title="0">{
                                setColor(sib, black)
                                setColor(parentOf(x), red)
                                root = m.rotateRight(root, parentOf(x))
                                sib = leftOf(parentOf(x))
                        }</span>

                        <span class="cov0" title="0">if colorOf(rightOf(sib)) == black &amp;&amp; colorOf(leftOf(sib)) == black </span><span class="cov0" title="0">{
                                setColor(sib, red)
                                x = parentOf(x)
                        }</span> else<span class="cov0" title="0"> {
                                if colorOf(leftOf(sib)) == black </span><span class="cov0" title="0">{
                                        setColor(rightOf(sib), black)
                                        setColor(sib, red)
                                        root = m.rotateLeft(root, sib)
                                        sib = leftOf(parentOf(x))
                                }</span>
                                <span class="cov0" title="0">setColor(sib, colorOf(parentOf(x)))
                                setColor(parentOf(x), black)
                                setColor(leftOf(sib), black)
                                root = m.rotateRight(root, parentOf(x))
                                x = root</span>
                        }
                }
        }

        <span class="cov0" title="0">setColor(x, black)
        return root</span>
}

// untreeify convert specified index's red-black tree to list
func (m *LinkedHashMap[K, V]) untreeify(index int) <span class="cov0" title="0">{
        root := m.table[index]
        if root == nil || !root.isTreeNode </span><span class="cov0" title="0">{
                return
        }</span>

        // Convert tree to list
        <span class="cov0" title="0">var head, tail *LinkedHashMapNode[K, V]
        m.treeToList(root, &amp;head, &amp;tail)

        // Update list reference
        m.table[index] = head</span>
}

// ContainsKey if this mapping contains the key's mapping, returns true
func (m *LinkedHashMap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        _, found := m.Get(key)
        return found
}</span>

// ContainsValue if this mapping maps one or more keys to the specified value, returns true
func (m *LinkedHashMap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.traverseAllWithEarlyExit(func(node *LinkedHashMapNode[K, V]) bool </span><span class="cov8" title="1">{
                return Equal(node.value, value)
        }</span>)
}

// Size returns the number of key-value mapping relationships in this mapping
func (m *LinkedHashMap[K, V]) Size() int <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()
        return m.size
}</span>

// IsEmpty if this mapping does not contain key-value mapping relationships, returns true
func (m *LinkedHashMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return m.Size() == 0
}</span>

// Clear removes all mapping relationships from this mapping
func (m *LinkedHashMap[K, V]) Clear() <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        // Clear hash table, help GC recycle memory
        for i := range m.table </span><span class="cov8" title="1">{
                if m.table[i] != nil </span><span class="cov8" title="1">{
                        m.clearNode(m.table[i])
                        m.table[i] = nil
                }</span>
        }

        <span class="cov8" title="1">m.size = 0</span>
}

// clearNode recursively clean up nodes to help GC
func (m *LinkedHashMap[K, V]) clearNode(node *LinkedHashMapNode[K, V]) <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // If it's a tree node, recursively clean up child nodes
        <span class="cov8" title="1">if node.isTreeNode </span><span class="cov0" title="0">{
                m.clearNode(node.left)
                m.clearNode(node.right)
                node.left = nil
                node.right = nil
                node.parent = nil
        }</span>

        // Clean list node
        <span class="cov8" title="1">for node.next != nil </span><span class="cov0" title="0">{
                next := node.next
                node.next = nil
                node = next
        }</span>
}

// Keys returns the keys contained in this mapping
func (m *LinkedHashMap[K, V]) Keys() []K <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        keys := make([]K, 0, m.size)
        m.traverseAll(func(node *LinkedHashMapNode[K, V]) </span><span class="cov8" title="1">{
                keys = append(keys, node.key)
        }</span>)

        <span class="cov8" title="1">return keys</span>
}

// Values returns the values contained in this mapping
func (m *LinkedHashMap[K, V]) Values() []V <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values := make([]V, 0, m.size)
        m.traverseAll(func(node *LinkedHashMapNode[K, V]) </span><span class="cov8" title="1">{
                values = append(values, node.value)
        }</span>)

        <span class="cov8" title="1">return values</span>
}

// inOrderTraversal in-order traverse red-black tree
func (m *LinkedHashMap[K, V]) inOrderTraversal(root *LinkedHashMapNode[K, V], f func(*LinkedHashMapNode[K, V])) <span class="cov0" title="0">{
        if root == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.inOrderTraversal(root.left, f)
        f(root)
        m.inOrderTraversal(root.right, f)</span>
}

// traverseAll traverse all nodes, including linked list and tree nodes
func (m *LinkedHashMap[K, V]) traverseAll(f func(*LinkedHashMapNode[K, V])) <span class="cov8" title="1">{
        // Traverse hash table
        for _, e := range m.table </span><span class="cov8" title="1">{
                p := e
                for p != nil </span><span class="cov8" title="1">{
                        f(p)
                        if p.isTreeNode </span><span class="cov0" title="0">{
                                // If it's a tree node, use in-order traverse other nodes
                                m.inOrderTraversal(p, func(node *LinkedHashMapNode[K, V]) </span><span class="cov0" title="0">{
                                        if node != p </span><span class="cov0" title="0">{ // Avoid repeat processing root node
                                                f(node)
                                        }</span>
                                })
                                <span class="cov0" title="0">break</span>
                        }
                        <span class="cov8" title="1">p = p.next</span>
                }
        }
}

// traverseAllWithEarlyExit traverse all nodes, support early exit
func (m *LinkedHashMap[K, V]) traverseAllWithEarlyExit(f func(*LinkedHashMapNode[K, V]) bool) bool <span class="cov8" title="1">{
        // Traverse hash table
        for _, e := range m.table </span><span class="cov8" title="1">{
                p := e
                for p != nil </span><span class="cov8" title="1">{
                        if f(p) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">if p.isTreeNode </span><span class="cov0" title="0">{
                                // If it's a tree node, use in-order traverse other nodes
                                found := false
                                m.inOrderTraversalWithEarlyExit(p, func(node *LinkedHashMapNode[K, V]) bool </span><span class="cov0" title="0">{
                                        if node != p </span><span class="cov0" title="0">{ // Avoid repeat processing root node
                                                return f(node)
                                        }</span>
                                        <span class="cov0" title="0">return false</span>
                                }, &amp;found)
                                <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                        <span class="cov8" title="1">p = p.next</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// inOrderTraversalWithEarlyExit in-order traverse red-black tree, support early exit
func (m *LinkedHashMap[K, V]) inOrderTraversalWithEarlyExit(root *LinkedHashMapNode[K, V], f func(*LinkedHashMapNode[K, V]) bool, found *bool) <span class="cov0" title="0">{
        if root == nil || *found </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">m.inOrderTraversalWithEarlyExit(root.left, f, found)
        if !*found &amp;&amp; f(root) </span><span class="cov0" title="0">{
                *found = true
                return
        }</span>
        <span class="cov0" title="0">m.inOrderTraversalWithEarlyExit(root.right, f, found)</span>
}

// ForEach execute the action for each entry
func (m *LinkedHashMap[K, V]) ForEach(f func(K, V)) <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        m.traverseAll(func(node *LinkedHashMapNode[K, V]) </span><span class="cov8" title="1">{
                f(node.key, node.value)
        }</span>)
}

// PutAll put all mapping relationships from the specified mapping to this mapping
func (m *LinkedHashMap[K, V]) PutAll(other Map[K, V]) <span class="cov8" title="1">{
        other.ForEach(func(k K, v V) </span><span class="cov8" title="1">{
                m.Put(k, v)
        }</span>)
}

// String returns the string representation of the mapping
func (m *LinkedHashMap[K, V]) String() string <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.size == 0 </span><span class="cov8" title="1">{
                return "{}"
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.WriteString("{")

        first := true
        m.traverseAll(func(node *LinkedHashMapNode[K, V]) </span><span class="cov8" title="1">{
                if !first </span><span class="cov8" title="1">{
                        sb.WriteString(", ")
                }</span>
                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%v=%v", node.key, node.value))
                first = false</span>
        })

        <span class="cov8" title="1">sb.WriteString("}")
        return sb.String()</span>
}

// Entries returns the mapping relationships contained in this mapping
func (m *LinkedHashMap[K, V]) Entries() []Pair[K, V] <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        entries := make([]Pair[K, V], 0, m.size)
        m.traverseAll(func(node *LinkedHashMapNode[K, V]) </span><span class="cov8" title="1">{
                entries = append(entries, NewPair(node.key, node.value))
        }</span>)

        <span class="cov8" title="1">return entries</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package maps

import (
        "fmt"
        "strings"
)

// TreeMap is an ordered Map implementation based on red-black tree
type TreeMap[K comparable, V any] struct {
        comparator func(a, b K) int // Key comparator function
        root       *mapNode[K, V]   // Root node
        size       int              // Element count
}

// mapNode is a red-black tree node
type mapNode[K comparable, V any] struct {
        key    K
        value  V
        color  color
        left   *mapNode[K, V]
        right  *mapNode[K, V]
        parent *mapNode[K, V]
}

// NewTreeMap creates a new TreeMap using default comparator
func NewTreeMap[K comparable, V any]() *TreeMap[K, V] <span class="cov8" title="1">{
        return &amp;TreeMap[K, V]{
                comparator: func(a, b K) int </span><span class="cov8" title="1">{
                        return Compare(a, b)
                }</span>,
        }
}

// NewTreeMapWithComparator creates a new TreeMap using specified comparator
func NewTreeMapWithComparator[K comparable, V any](comparator func(a, b K) int) *TreeMap[K, V] <span class="cov8" title="1">{
        return &amp;TreeMap[K, V]{
                comparator: comparator,
        }
}</span>

// isRedMap checks if node is red
func isRedMap[K comparable, V any](node *mapNode[K, V]) bool <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return node.color == red</span>
}

// rotateLeft left rotation
func (m *TreeMap[K, V]) rotateLeft(h *mapNode[K, V]) *mapNode[K, V] <span class="cov8" title="1">{
        x := h.right
        h.right = x.left
        if x.left != nil </span><span class="cov0" title="0">{
                x.left.parent = h
        }</span>
        <span class="cov8" title="1">x.parent = h.parent
        if h.parent == nil </span><span class="cov8" title="1">{
                m.root = x
        }</span> else<span class="cov8" title="1"> if h == h.parent.left </span><span class="cov8" title="1">{
                h.parent.left = x
        }</span> else<span class="cov0" title="0"> {
                h.parent.right = x
        }</span>
        <span class="cov8" title="1">x.left = h
        h.parent = x
        x.color = h.color
        h.color = red
        return x</span>
}

// rotateRight right rotation
func (m *TreeMap[K, V]) rotateRight(h *mapNode[K, V]) *mapNode[K, V] <span class="cov8" title="1">{
        x := h.left
        h.left = x.right
        if x.right != nil </span><span class="cov8" title="1">{
                x.right.parent = h
        }</span>
        <span class="cov8" title="1">x.parent = h.parent
        if h.parent == nil </span><span class="cov8" title="1">{
                m.root = x
        }</span> else<span class="cov8" title="1"> if h == h.parent.right </span><span class="cov0" title="0">{
                h.parent.right = x
        }</span> else<span class="cov8" title="1"> {
                h.parent.left = x
        }</span>
        <span class="cov8" title="1">x.right = h
        h.parent = x
        x.color = h.color
        h.color = red
        return x</span>
}

// flipColors color flip
func (m *TreeMap[K, V]) flipColors(h *mapNode[K, V]) <span class="cov8" title="1">{
        h.color = red
        if h.left != nil </span><span class="cov8" title="1">{
                h.left.color = black
        }</span>
        <span class="cov8" title="1">if h.right != nil </span><span class="cov8" title="1">{
                h.right.color = black
        }</span>
}

// put insert or update node
func (m *TreeMap[K, V]) put(h *mapNode[K, V], key K, value V) (*mapNode[K, V], V, bool) <span class="cov8" title="1">{
        var oldValue V
        existed := false

        if h == nil </span><span class="cov8" title="1">{
                m.size++
                return &amp;mapNode[K, V]{
                        key:   key,
                        value: value,
                        color: red,
                }, oldValue, existed
        }</span>

        <span class="cov8" title="1">cmp := m.comparator(key, h.key)
        if cmp &lt; 0 </span><span class="cov8" title="1">{
                h.left, oldValue, existed = m.put(h.left, key, value)
                if h.left != nil </span><span class="cov8" title="1">{
                        h.left.parent = h
                }</span>
        } else<span class="cov8" title="1"> if cmp &gt; 0 </span><span class="cov8" title="1">{
                h.right, oldValue, existed = m.put(h.right, key, value)
                if h.right != nil </span><span class="cov8" title="1">{
                        h.right.parent = h
                }</span>
        } else<span class="cov8" title="1"> {
                // Key already exists, update value
                oldValue = h.value
                h.value = value
                existed = true
                return h, oldValue, existed
        }</span>

        // Red-black tree balancing adjustment
        <span class="cov8" title="1">if isRedMap(h.right) &amp;&amp; !isRedMap(h.left) </span><span class="cov8" title="1">{
                h = m.rotateLeft(h)
        }</span>
        <span class="cov8" title="1">if isRedMap(h.left) &amp;&amp; isRedMap(h.left.left) </span><span class="cov8" title="1">{
                h = m.rotateRight(h)
        }</span>
        <span class="cov8" title="1">if isRedMap(h.left) &amp;&amp; isRedMap(h.right) </span><span class="cov8" title="1">{
                m.flipColors(h)
        }</span>

        <span class="cov8" title="1">return h, oldValue, existed</span>
}

// Put associates the specified value with the specified key in this map
func (m *TreeMap[K, V]) Put(key K, value V) (V, bool) <span class="cov8" title="1">{
        var oldValue V
        var existed bool
        m.root, oldValue, existed = m.put(m.root, key, value)
        if m.root != nil </span><span class="cov8" title="1">{
                m.root.color = black
                m.root.parent = nil
        }</span>
        <span class="cov8" title="1">return oldValue, existed</span>
}

// findMin find minimum node
func (m *TreeMap[K, V]) findMin(h *mapNode[K, V]) *mapNode[K, V] <span class="cov8" title="1">{
        if h == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for h.left != nil </span><span class="cov0" title="0">{
                h = h.left
        }</span>
        <span class="cov8" title="1">return h</span>
}

// moveRedLeft make left child or its sibling red
func (m *TreeMap[K, V]) moveRedLeft(h *mapNode[K, V]) *mapNode[K, V] <span class="cov0" title="0">{
        m.flipColors(h)
        if h.right != nil &amp;&amp; isRedMap(h.right.left) </span><span class="cov0" title="0">{
                h.right = m.rotateRight(h.right)
                h = m.rotateLeft(h)
                m.flipColors(h)
        }</span>
        <span class="cov0" title="0">return h</span>
}

// moveRedRight make right child or its sibling red
func (m *TreeMap[K, V]) moveRedRight(h *mapNode[K, V]) *mapNode[K, V] <span class="cov8" title="1">{
        m.flipColors(h)
        if h.left != nil &amp;&amp; isRedMap(h.left.left) </span><span class="cov0" title="0">{
                h = m.rotateRight(h)
                m.flipColors(h)
        }</span>
        <span class="cov8" title="1">return h</span>
}

// balance balance node
func (m *TreeMap[K, V]) balance(h *mapNode[K, V]) *mapNode[K, V] <span class="cov8" title="1">{
        if isRedMap(h.right) </span><span class="cov0" title="0">{
                h = m.rotateLeft(h)
        }</span>
        <span class="cov8" title="1">if isRedMap(h.left) &amp;&amp; isRedMap(h.left.left) </span><span class="cov0" title="0">{
                h = m.rotateRight(h)
        }</span>
        <span class="cov8" title="1">if isRedMap(h.left) &amp;&amp; isRedMap(h.right) </span><span class="cov0" title="0">{
                m.flipColors(h)
        }</span>
        <span class="cov8" title="1">return h</span>
}

// removeMin remove minimum node
func (m *TreeMap[K, V]) removeMin(h *mapNode[K, V], decreaseSize bool) *mapNode[K, V] <span class="cov8" title="1">{
        if h.left == nil </span><span class="cov8" title="1">{
                // Only decrease size when this is a standalone delete operation
                // When called from remove method, size will be handled in remove method
                if decreaseSize </span><span class="cov0" title="0">{
                        m.size--
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">if !isRedMap(h.left) &amp;&amp; !isRedMap(h.left.left) </span><span class="cov0" title="0">{
                h = m.moveRedLeft(h)
        }</span>

        <span class="cov0" title="0">h.left = m.removeMin(h.left, decreaseSize)
        if h.left != nil </span><span class="cov0" title="0">{
                h.left.parent = h
        }</span>

        <span class="cov0" title="0">return m.balance(h)</span>
}

// remove remove node
func (m *TreeMap[K, V]) remove(h *mapNode[K, V], key K) (*mapNode[K, V], V, bool) <span class="cov8" title="1">{
        var oldValue V
        found := false

        if h == nil </span><span class="cov0" title="0">{
                return nil, oldValue, found
        }</span>

        <span class="cov8" title="1">cmp := m.comparator(key, h.key)
        if cmp &lt; 0 </span><span class="cov0" title="0">{
                if h.left != nil </span><span class="cov0" title="0">{
                        if !isRedMap(h.left) &amp;&amp; !isRedMap(h.left.left) </span><span class="cov0" title="0">{
                                h = m.moveRedLeft(h)
                        }</span>
                        // Key is in left subtree
                        <span class="cov0" title="0">h.left, oldValue, found = m.remove(h.left, key)
                        if h.left != nil </span><span class="cov0" title="0">{
                                h.left.parent = h
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                if isRedMap(h.left) </span><span class="cov0" title="0">{
                        h = m.rotateRight(h)
                }</span>
                <span class="cov8" title="1">if cmp == 0 &amp;&amp; h.right == nil </span><span class="cov8" title="1">{
                        // Key is in right subtree
                        oldValue = h.value
                        found = true
                        m.size--
                        return nil, oldValue, found
                }</span>
                <span class="cov8" title="1">if h.right != nil </span><span class="cov8" title="1">{
                        if !isRedMap(h.right) &amp;&amp; !isRedMap(h.right.left) </span><span class="cov8" title="1">{
                                h = m.moveRedRight(h)
                        }</span>
                        <span class="cov8" title="1">cmp = m.comparator(key, h.key) // Recalculate comparison result
                        if cmp == 0 </span><span class="cov8" title="1">{
                                // Found node to delete
                                oldValue = h.value
                                found = true
                                m.size--

                                min := m.findMin(h.right)
                                h.key = min.key
                                h.value = min.value

                                // Delete minimum node from right subtree, but don't decrease size (since we just moved the node)
                                h.right = m.removeMin(h.right, false)
                                if h.right != nil </span><span class="cov0" title="0">{
                                        h.right.parent = h
                                }</span>
                        } else<span class="cov0" title="0"> {
                                h.right, oldValue, found = m.remove(h.right, key)
                                if h.right != nil </span><span class="cov0" title="0">{
                                        h.right.parent = h
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if h == nil </span><span class="cov0" title="0">{
                return nil, oldValue, found
        }</span>

        <span class="cov8" title="1">if h.left == nil &amp;&amp; h.right == nil </span><span class="cov0" title="0">{
                // No right subtree, directly return left subtree
                return nil, oldValue, found
        }</span>

        <span class="cov8" title="1">if h.left == nil </span><span class="cov0" title="0">{
                // No left subtree, directly return right subtree
                return h.right, oldValue, found
        }</span>

        // Has two subtrees, replace current node with minimum node from right subtree
        <span class="cov8" title="1">return m.balance(h), oldValue, found</span>
}

// removeMinWithoutSizeChange remove minimum node but don't change size
func (m *TreeMap[K, V]) removeMinWithoutSizeChange(h *mapNode[K, V]) *mapNode[K, V] <span class="cov0" title="0">{
        if h.left == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if !isRedMap(h.left) &amp;&amp; !isRedMap(h.left.left) </span><span class="cov0" title="0">{
                h = m.moveRedLeft(h)
        }</span>

        <span class="cov0" title="0">h.left = m.removeMinWithoutSizeChange(h.left)
        if h.left != nil </span><span class="cov0" title="0">{
                h.left.parent = h
        }</span>

        <span class="cov0" title="0">return m.balance(h)</span>
}

// Remove if exists, removes mapping relationship for the key from this map
func (m *TreeMap[K, V]) Remove(key K) (V, bool) <span class="cov8" title="1">{
        var oldValue V
        found := false

        if m.root == nil </span><span class="cov8" title="1">{
                return oldValue, found
        }</span>

        <span class="cov8" title="1">m.root, oldValue, found = m.remove(m.root, key)
        if m.root != nil </span><span class="cov8" title="1">{
                m.root.color = black
                m.root.parent = nil
        }</span>

        <span class="cov8" title="1">return oldValue, found</span>
}

// find find node
func (m *TreeMap[K, V]) find(h *mapNode[K, V], key K) *mapNode[K, V] <span class="cov8" title="1">{
        for h != nil </span><span class="cov8" title="1">{
                cmp := m.comparator(key, h.key)
                if cmp &lt; 0 </span><span class="cov8" title="1">{
                        h = h.left
                }</span> else<span class="cov8" title="1"> if cmp &gt; 0 </span><span class="cov8" title="1">{
                        h = h.right
                }</span> else<span class="cov8" title="1"> {
                        return h
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Get returns the value mapped to the specified key
func (m *TreeMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        node := m.find(m.root, key)
        if node != nil </span><span class="cov8" title="1">{
                return node.value, true
        }</span>
        <span class="cov8" title="1">return *new(V), false</span>
}

// ContainsKey if this map contains mapping relationship for the specified key, returns true
func (m *TreeMap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        _, found := m.Get(key)
        return found
}</span>

// Size returns the number of key-value mapping relationships in this map
func (m *TreeMap[K, V]) Size() int <span class="cov8" title="1">{
        return m.size
}</span>

// IsEmpty if this map does not contain key-value mapping relationships, returns true
func (m *TreeMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return m.size == 0
}</span>

// Clear removes all mapping relationships from this map
func (m *TreeMap[K, V]) Clear() <span class="cov8" title="1">{
        m.root = nil
        m.size = 0
}</span>

// inOrderTraversalMap in-order traversal
func (m *TreeMap[K, V]) inOrderTraversalMap(node *mapNode[K, V], visit func(K, V)) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m.inOrderTraversalMap(node.left, visit)
        visit(node.key, node.value)
        m.inOrderTraversalMap(node.right, visit)</span>
}

func (m *TreeMap[K, V]) inOrderTraversalMapKeys(node *mapNode[K, V], keys *[]K) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m.inOrderTraversalMapKeys(node.left, keys)
        *keys = append(*keys, node.key)
        m.inOrderTraversalMapKeys(node.right, keys)</span>
}

func (m *TreeMap[K, V]) inOrderTraversalMapValues(node *mapNode[K, V], values *[]V) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m.inOrderTraversalMapValues(node.left, values)
        *values = append(*values, node.value)
        m.inOrderTraversalMapValues(node.right, values)</span>
}

func (m *TreeMap[K, V]) inOrderTraversalMapEntries(node *mapNode[K, V], entries *[]Pair[K, V]) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m.inOrderTraversalMapEntries(node.left, entries)
        *entries = append(*entries, NewPair(node.key, node.value))
        m.inOrderTraversalMapEntries(node.right, entries)</span>
}

// Keys returns the keys contained in this map (in order)
func (m *TreeMap[K, V]) Keys() []K <span class="cov8" title="1">{
        keys := make([]K, 0, m.size)
        m.inOrderTraversalMapKeys(m.root, &amp;keys)
        return keys
}</span>

// Values returns the values contained in this map (in key order)
func (m *TreeMap[K, V]) Values() []V <span class="cov8" title="1">{
        values := make([]V, 0, m.size)
        m.inOrderTraversalMapValues(m.root, &amp;values)
        return values
}</span>

// Entries returns the mapping relationships contained in this map (in key order)
func (m *TreeMap[K, V]) Entries() []Pair[K, V] <span class="cov8" title="1">{
        entries := make([]Pair[K, V], 0, m.size)
        m.inOrderTraversalMapEntries(m.root, &amp;entries)
        return entries
}</span>

// ForEach executes the given operation for each entry in this map (in key order)
func (m *TreeMap[K, V]) ForEach(f func(K, V)) <span class="cov8" title="1">{
        m.inOrderTraversalMap(m.root, f)
}</span>

// ContainsValue if this map maps one or more keys to the specified value, returns true
func (m *TreeMap[K, V]) ContainsValue(value V) bool <span class="cov0" title="0">{
        found := false
        m.inOrderTraversalMap(m.root, func(k K, v V) </span><span class="cov0" title="0">{
                if !found &amp;&amp; Equal(v, value) </span><span class="cov0" title="0">{
                        found = true
                }</span>
        })
        <span class="cov0" title="0">return found</span>
}

// String returns the string representation of the map
func (m *TreeMap[K, V]) String() string <span class="cov8" title="1">{
        if m.IsEmpty() </span><span class="cov8" title="1">{
                return "{}"
        }</span>

        <span class="cov8" title="1">var builder strings.Builder
        builder.WriteString("{")
        first := true
        m.inOrderTraversalMap(m.root, func(k K, v V) </span><span class="cov8" title="1">{
                if !first </span><span class="cov8" title="1">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("%v=%v", k, v))
                first = false</span>
        })
        <span class="cov8" title="1">builder.WriteString("}")
        return builder.String()</span>
}

// PutAll copies all mapping relationships from the specified map to this map
func (m *TreeMap[K, V]) PutAll(other Map[K, V]) <span class="cov0" title="0">{
        other.ForEach(func(k K, v V) </span><span class="cov0" title="0">{
                m.Put(k, v)
        }</span>)
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package multimap

import (
        "fmt"
        "strings"
        "sync"

        "github.com/chenjianyu/collections/container/list"
)

// ArrayListMultimap is a multimap implementation that uses ArrayList to store multiple values for a key
type ArrayListMultimap[K comparable, V comparable] struct {
        data   map[K]list.List[V]
        size   int
        mutex  sync.RWMutex
}

// NewArrayListMultimap creates a new ArrayListMultimap
func NewArrayListMultimap[K comparable, V comparable]() *ArrayListMultimap[K, V] <span class="cov8" title="1">{
        return &amp;ArrayListMultimap[K, V]{
                data: make(map[K]list.List[V]),
                size: 0,
        }
}</span>

// Put adds a key-value mapping to this multimap
func (m *ArrayListMultimap[K, V]) Put(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov8" title="1">{
                values = list.New[V]()
                m.data[key] = values
        }</span>

        <span class="cov8" title="1">result := values.Add(value)
        if result </span><span class="cov8" title="1">{
                m.size++
        }</span>

        <span class="cov8" title="1">return result</span>
}

// PutAll adds all key-value mappings from the specified multimap to this multimap
func (m *ArrayListMultimap[K, V]) PutAll(multimap Multimap[K, V]) bool <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        changed := false
        multimap.ForEach(func(key K, value V) </span><span class="cov0" title="0">{
                values, exists := m.data[key]
                if !exists </span><span class="cov0" title="0">{
                        values = list.New[V]()
                        m.data[key] = values
                }</span>

                <span class="cov0" title="0">result := values.Add(value)
                if result </span><span class="cov0" title="0">{
                        m.size++
                        changed = true
                }</span>
        })

        <span class="cov0" title="0">return changed</span>
}

// ReplaceValues replaces all values for a key with the specified collection of values
func (m *ArrayListMultimap[K, V]) ReplaceValues(key K, values []V) []V <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        oldValues, exists := m.data[key]
        if exists </span><span class="cov8" title="1">{
                oldValuesSlice := oldValues.ToSlice()
                m.size -= oldValues.Size()
                delete(m.data, key)

                if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        newValues := list.New[V]()
                        for _, value := range values </span><span class="cov8" title="1">{
                                newValues.Add(value)
                        }</span>
                        <span class="cov8" title="1">m.data[key] = newValues
                        m.size += newValues.Size()</span>
                }

                <span class="cov8" title="1">return oldValuesSlice</span>
        } else<span class="cov0" title="0"> if len(values) &gt; 0 </span><span class="cov0" title="0">{
                newValues := list.New[V]()
                for _, value := range values </span><span class="cov0" title="0">{
                        newValues.Add(value)
                }</span>
                <span class="cov0" title="0">m.data[key] = newValues
                m.size += newValues.Size()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Remove removes a key-value mapping from this multimap
func (m *ArrayListMultimap[K, V]) Remove(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">result := values.Remove(value)
        if result </span><span class="cov8" title="1">{
                m.size--
                if values.IsEmpty() </span><span class="cov0" title="0">{
                        delete(m.data, key)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// RemoveAll removes all values associated with a key
func (m *ArrayListMultimap[K, V]) RemoveAll(key K) []V <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">result := values.ToSlice()
        m.size -= values.Size()
        delete(m.data, key)

        return result</span>
}

// ContainsKey returns true if this multimap contains at least one key-value mapping with the specified key
func (m *ArrayListMultimap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        _, exists := m.data[key]
        return exists
}</span>

// ContainsValue returns true if this multimap contains at least one key-value mapping with the specified value
func (m *ArrayListMultimap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        for _, values := range m.data </span><span class="cov8" title="1">{
                if values.Contains(value) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ContainsEntry returns true if this multimap contains the specified key-value mapping
func (m *ArrayListMultimap[K, V]) ContainsEntry(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return values.Contains(value)</span>
}

// Get returns all values associated with the specified key
func (m *ArrayListMultimap[K, V]) Get(key K) []V <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return values.ToSlice()</span>
}

// Keys returns all distinct keys in this multimap
func (m *ArrayListMultimap[K, V]) Keys() []K <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        keys := make([]K, 0, len(m.data))
        for key := range m.data </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>

        <span class="cov8" title="1">return keys</span>
}

// Values returns all values in this multimap
func (m *ArrayListMultimap[K, V]) Values() []V <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values := make([]V, 0, m.size)
        for _, valueList := range m.data </span><span class="cov8" title="1">{
                values = append(values, valueList.ToSlice()...)
        }</span>

        <span class="cov8" title="1">return values</span>
}

// Entries returns all key-value pairs in this multimap
func (m *ArrayListMultimap[K, V]) Entries() []Entry[K, V] <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        entries := make([]Entry[K, V], 0, m.size)
        for key, valueList := range m.data </span><span class="cov8" title="1">{
                for _, value := range valueList.ToSlice() </span><span class="cov8" title="1">{
                        entries = append(entries, Entry[K, V]{Key: key, Value: value})
                }</span>
        }

        <span class="cov8" title="1">return entries</span>
}

// KeySet returns a set view of the distinct keys in this multimap
func (m *ArrayListMultimap[K, V]) KeySet() []K <span class="cov0" title="0">{
        return m.Keys()
}</span>

// AsMap returns a map view of this multimap, mapping each key to its collection of values
func (m *ArrayListMultimap[K, V]) AsMap() map[K][]V <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make(map[K][]V, len(m.data))
        for key, valueList := range m.data </span><span class="cov0" title="0">{
                result[key] = valueList.ToSlice()
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ForEach executes the given function for each key-value pair in this multimap
func (m *ArrayListMultimap[K, V]) ForEach(f func(K, V)) <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        for key, valueList := range m.data </span><span class="cov8" title="1">{
                for _, value := range valueList.ToSlice() </span><span class="cov8" title="1">{
                        f(key, value)
                }</span>
        }
}

// Size returns the number of key-value mappings in this multimap
func (m *ArrayListMultimap[K, V]) Size() int <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.size
}</span>

// IsEmpty returns true if this multimap contains no key-value mappings
func (m *ArrayListMultimap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.size == 0
}</span>

// Clear removes all key-value mappings from this multimap
func (m *ArrayListMultimap[K, V]) Clear() <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.data = make(map[K]list.List[V])
        m.size = 0
}</span>

// Contains returns true if this multimap contains the specified element
func (m *ArrayListMultimap[K, V]) Contains(key K) bool <span class="cov0" title="0">{
        return m.ContainsKey(key)
}</span>

// String returns a string representation of this multimap
func (m *ArrayListMultimap[K, V]) String() string <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.IsEmpty() </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("{")

        first := true
        for key, valueList := range m.data </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">first = false

                builder.WriteString(fmt.Sprintf("%v=[%v]", key, formatValues(valueList.ToSlice())))</span>
        }

        <span class="cov0" title="0">builder.WriteString("}")
        return builder.String()</span>
}

// formatValues formats a slice of values as a comma-separated string
func formatValues[V comparable](values []V) string <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var builder strings.Builder
        for i, value := range values </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">builder.WriteString(fmt.Sprintf("%v", value))</span>
        }

        <span class="cov0" title="0">return builder.String()</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package multimap

import (
        "fmt"
        "strings"
        "sync"

        "github.com/chenjianyu/collections/container/set"
)

// HashMultimap is a multimap implementation that uses HashSet to store multiple values for a key
type HashMultimap[K comparable, V comparable] struct {
        data   map[K]set.Set[V]
        size   int
        mutex  sync.RWMutex
}

// NewHashMultimap creates a new HashMultimap
func NewHashMultimap[K comparable, V comparable]() *HashMultimap[K, V] <span class="cov8" title="1">{
        return &amp;HashMultimap[K, V]{
                data: make(map[K]set.Set[V]),
                size: 0,
        }
}</span>

// Put adds a key-value mapping to this multimap
func (m *HashMultimap[K, V]) Put(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov8" title="1">{
                values = set.New[V]()
                m.data[key] = values
        }</span>

        <span class="cov8" title="1">result := values.Add(value)
        if result </span><span class="cov8" title="1">{
                m.size++
        }</span>

        <span class="cov8" title="1">return result</span>
}

// PutAll adds all key-value mappings from the specified multimap to this multimap
func (m *HashMultimap[K, V]) PutAll(multimap Multimap[K, V]) bool <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        changed := false
        multimap.ForEach(func(key K, value V) </span><span class="cov0" title="0">{
                values, exists := m.data[key]
                if !exists </span><span class="cov0" title="0">{
                        values = set.New[V]()
                        m.data[key] = values
                }</span>

                <span class="cov0" title="0">result := values.Add(value)
                if result </span><span class="cov0" title="0">{
                        m.size++
                        changed = true
                }</span>
        })

        <span class="cov0" title="0">return changed</span>
}

// ReplaceValues replaces all values for a key with the specified collection of values
func (m *HashMultimap[K, V]) ReplaceValues(key K, values []V) []V <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        oldValues, exists := m.data[key]
        if exists </span><span class="cov8" title="1">{
                oldValuesSlice := oldValues.ToSlice()
                m.size -= oldValues.Size()
                delete(m.data, key)

                if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        newValues := set.New[V]()
                        for _, value := range values </span><span class="cov8" title="1">{
                                newValues.Add(value)
                        }</span>
                        <span class="cov8" title="1">m.data[key] = newValues
                        m.size += newValues.Size()</span>
                }

                <span class="cov8" title="1">return oldValuesSlice</span>
        } else<span class="cov0" title="0"> if len(values) &gt; 0 </span><span class="cov0" title="0">{
                newValues := set.New[V]()
                for _, value := range values </span><span class="cov0" title="0">{
                        newValues.Add(value)
                }</span>
                <span class="cov0" title="0">m.data[key] = newValues
                m.size += newValues.Size()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Remove removes a key-value mapping from this multimap
func (m *HashMultimap[K, V]) Remove(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">result := values.Remove(value)
        if result </span><span class="cov8" title="1">{
                m.size--
                if values.IsEmpty() </span><span class="cov0" title="0">{
                        delete(m.data, key)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// RemoveAll removes all values associated with a key
func (m *HashMultimap[K, V]) RemoveAll(key K) []V <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">result := values.ToSlice()
        m.size -= values.Size()
        delete(m.data, key)

        return result</span>
}

// ContainsKey returns true if this multimap contains at least one key-value mapping with the specified key
func (m *HashMultimap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        _, exists := m.data[key]
        return exists
}</span>

// ContainsValue returns true if this multimap contains at least one key-value mapping with the specified value
func (m *HashMultimap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        for _, values := range m.data </span><span class="cov8" title="1">{
                if values.Contains(value) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ContainsEntry returns true if this multimap contains the specified key-value mapping
func (m *HashMultimap[K, V]) ContainsEntry(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return values.Contains(value)</span>
}

// Get returns all values associated with the specified key
func (m *HashMultimap[K, V]) Get(key K) []V <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return values.ToSlice()</span>
}

// Keys returns all distinct keys in this multimap
func (m *HashMultimap[K, V]) Keys() []K <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        keys := make([]K, 0, len(m.data))
        for key := range m.data </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>

        <span class="cov8" title="1">return keys</span>
}

// Values returns all values in this multimap
func (m *HashMultimap[K, V]) Values() []V <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values := make([]V, 0, m.size)
        for _, valueSet := range m.data </span><span class="cov8" title="1">{
                values = append(values, valueSet.ToSlice()...)
        }</span>

        <span class="cov8" title="1">return values</span>
}

// Entries returns all key-value pairs in this multimap
func (m *HashMultimap[K, V]) Entries() []Entry[K, V] <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        entries := make([]Entry[K, V], 0, m.size)
        for key, valueSet := range m.data </span><span class="cov8" title="1">{
                for _, value := range valueSet.ToSlice() </span><span class="cov8" title="1">{
                        entries = append(entries, Entry[K, V]{Key: key, Value: value})
                }</span>
        }

        <span class="cov8" title="1">return entries</span>
}

// KeySet returns a set view of the distinct keys in this multimap
func (m *HashMultimap[K, V]) KeySet() []K <span class="cov0" title="0">{
        return m.Keys()
}</span>

// AsMap returns a map view of this multimap, mapping each key to its collection of values
func (m *HashMultimap[K, V]) AsMap() map[K][]V <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make(map[K][]V, len(m.data))
        for key, valueSet := range m.data </span><span class="cov0" title="0">{
                result[key] = valueSet.ToSlice()
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ForEach executes the given function for each key-value pair in this multimap
func (m *HashMultimap[K, V]) ForEach(f func(K, V)) <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        for key, valueSet := range m.data </span><span class="cov0" title="0">{
                for _, value := range valueSet.ToSlice() </span><span class="cov0" title="0">{
                        f(key, value)
                }</span>
        }
}

// Size returns the number of key-value mappings in this multimap
func (m *HashMultimap[K, V]) Size() int <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.size
}</span>

// IsEmpty returns true if this multimap contains no key-value mappings
func (m *HashMultimap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.size == 0
}</span>

// Clear removes all key-value mappings from this multimap
func (m *HashMultimap[K, V]) Clear() <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.data = make(map[K]set.Set[V])
        m.size = 0
}</span>

// Contains returns true if this multimap contains the specified element
func (m *HashMultimap[K, V]) Contains(key K) bool <span class="cov0" title="0">{
        return m.ContainsKey(key)
}</span>

// String returns a string representation of this multimap
func (m *HashMultimap[K, V]) String() string <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.IsEmpty() </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("{")

        first := true
        for key, valueSet := range m.data </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">first = false

                builder.WriteString(fmt.Sprintf("%v=[%v]", key, formatValues(valueSet.ToSlice())))</span>
        }

        <span class="cov0" title="0">builder.WriteString("}")
        return builder.String()</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package multimap

import (
        "fmt"
        "strings"
        "log"
        "github.com/chenjianyu/collections/container/common"
)

// ImmutableListMultimap is an immutable implementation of a multimap that preserves duplicate values and insertion order
type ImmutableListMultimap[K comparable, V comparable] struct {
        entries []Entry[K, V]
        data    map[K][]V
}

// NewImmutableListMultimap creates a new ImmutableListMultimap from the given entries
func NewImmutableListMultimap[K comparable, V comparable](entries []Entry[K, V]) *ImmutableListMultimap[K, V] <span class="cov8" title="1">{
        data := make(map[K][]V)
        
        // Group values by key while preserving order and duplicates
        for _, entry := range entries </span><span class="cov8" title="1">{
                data[entry.Key] = append(data[entry.Key], entry.Value)
        }</span>
        
        <span class="cov8" title="1">return &amp;ImmutableListMultimap[K, V]{
                entries: append([]Entry[K, V]{}, entries...), // Create a copy of entries
                data:    data,
        }</span>
}

// ListOf creates a new ImmutableListMultimap from the given key-value pairs
func ListOf[K comparable, V comparable](pairs ...interface{}) *ImmutableListMultimap[K, V] <span class="cov8" title="1">{
        if len(pairs)%2 != 0 </span><span class="cov0" title="0">{
                err := common.ImmutableOperationError("ListOf requires an even number of arguments", "provide key-value pairs")
                log.Printf("Warning: %v", err)
                return NewImmutableListMultimap([]Entry[K, V]{})
        }</span>
        
        <span class="cov8" title="1">entries := make([]Entry[K, V], 0, len(pairs)/2)
        
        for i := 0; i &lt; len(pairs); i += 2 </span><span class="cov8" title="1">{
                key, ok1 := pairs[i].(K)
                value, ok2 := pairs[i+1].(V)
                
                if !ok1 || !ok2 </span><span class="cov0" title="0">{
                        err := common.ImmutableOperationError("invalid type for key or value", "ensure correct types")
                        log.Printf("Warning: %v", err)
                        return NewImmutableListMultimap([]Entry[K, V]{})
                }</span>
                
                <span class="cov8" title="1">entries = append(entries, Entry[K, V]{Key: key, Value: value})</span>
        }
        
        <span class="cov8" title="1">return NewImmutableListMultimap(entries)</span>
}

// FromArrayListMultimap creates a new ImmutableListMultimap from the given ArrayListMultimap
func FromArrayListMultimap[K comparable, V comparable](multimap *ArrayListMultimap[K, V]) *ImmutableListMultimap[K, V] <span class="cov8" title="1">{
        return NewImmutableListMultimap(multimap.Entries())
}</span>

// FromMultimap creates a new ImmutableListMultimap from any multimap
func FromMultimapToList[K comparable, V comparable](multimap Multimap[K, V]) *ImmutableListMultimap[K, V] <span class="cov0" title="0">{
        return NewImmutableListMultimap(multimap.Entries())
}</span>

// Put logs an error and returns false as ImmutableListMultimap is immutable
func (m *ImmutableListMultimap[K, V]) Put(key K, value V) bool <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Put", "use builder pattern")
        log.Printf("Warning: %v", err)
        return false
}</span>

// PutAll logs an error and returns false as ImmutableListMultimap is immutable
func (m *ImmutableListMultimap[K, V]) PutAll(multimap Multimap[K, V]) bool <span class="cov0" title="0">{
        err := common.ImmutableOperationError("PutAll", "use builder pattern")
        log.Printf("Warning: %v", err)
        return false
}</span>

// ReplaceValues logs an error and returns nil as ImmutableListMultimap is immutable
func (m *ImmutableListMultimap[K, V]) ReplaceValues(key K, values []V) []V <span class="cov0" title="0">{
        err := common.ImmutableOperationError("ReplaceValues", "use builder pattern")
        log.Printf("Warning: %v", err)
        return nil
}</span>

// Remove logs an error and returns false as ImmutableListMultimap is immutable
func (m *ImmutableListMultimap[K, V]) Remove(key K, value V) bool <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Remove", "use builder pattern")
        log.Printf("Warning: %v", err)
        return false
}</span>

// RemoveAll logs an error and returns nil as ImmutableListMultimap is immutable
func (m *ImmutableListMultimap[K, V]) RemoveAll(key K) []V <span class="cov0" title="0">{
        err := common.ImmutableOperationError("RemoveAll", "use builder pattern")
        log.Printf("Warning: %v", err)
        return nil
}</span>

// ContainsKey returns true if this multimap contains at least one key-value mapping with the specified key
func (m *ImmutableListMultimap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        _, exists := m.data[key]
        return exists
}</span>

// ContainsValue returns true if this multimap contains at least one key-value mapping with the specified value
func (m *ImmutableListMultimap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        for _, values := range m.data </span><span class="cov8" title="1">{
                for _, v := range values </span><span class="cov8" title="1">{
                        if v == value </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// ContainsEntry returns true if this multimap contains the specified key-value mapping
func (m *ImmutableListMultimap[K, V]) ContainsEntry(key K, value V) bool <span class="cov8" title="1">{
        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                if v == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

// Get returns all values associated with the specified key, preserving duplicates and order
func (m *ImmutableListMultimap[K, V]) Get(key K) []V <span class="cov8" title="1">{
        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Return a copy to maintain immutability
        <span class="cov8" title="1">result := make([]V, len(values))
        copy(result, values)
        return result</span>
}

// Keys returns all keys in this multimap, including duplicates for each value
func (m *ImmutableListMultimap[K, V]) Keys() []K <span class="cov0" title="0">{
        keys := make([]K, 0, len(m.entries))
        for _, entry := range m.entries </span><span class="cov0" title="0">{
                keys = append(keys, entry.Key)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Values returns all values in this multimap in insertion order
func (m *ImmutableListMultimap[K, V]) Values() []V <span class="cov0" title="0">{
        values := make([]V, 0, len(m.entries))
        for _, entry := range m.entries </span><span class="cov0" title="0">{
                values = append(values, entry.Value)
        }</span>
        <span class="cov0" title="0">return values</span>
}

// Entries returns all key-value pairs in this multimap in insertion order
func (m *ImmutableListMultimap[K, V]) Entries() []Entry[K, V] <span class="cov0" title="0">{
        // Return a copy to maintain immutability
        result := make([]Entry[K, V], len(m.entries))
        copy(result, m.entries)
        return result
}</span>

// KeySet returns a set view of the distinct keys in this multimap
func (m *ImmutableListMultimap[K, V]) KeySet() []K <span class="cov0" title="0">{
        keys := make([]K, 0, len(m.data))
        for key := range m.data </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// AsMap returns a map view of this multimap, mapping each key to its collection of values
func (m *ImmutableListMultimap[K, V]) AsMap() map[K][]V <span class="cov0" title="0">{
        // Return a deep copy to maintain immutability
        result := make(map[K][]V, len(m.data))
        for key, values := range m.data </span><span class="cov0" title="0">{
                valuesCopy := make([]V, len(values))
                copy(valuesCopy, values)
                result[key] = valuesCopy
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ForEach executes the given function for each key-value pair in this multimap in insertion order
func (m *ImmutableListMultimap[K, V]) ForEach(f func(K, V)) <span class="cov0" title="0">{
        for _, entry := range m.entries </span><span class="cov0" title="0">{
                f(entry.Key, entry.Value)
        }</span>
}

// Size returns the number of key-value mappings in this multimap
func (m *ImmutableListMultimap[K, V]) Size() int <span class="cov8" title="1">{
        return len(m.entries)
}</span>

// IsEmpty returns true if this multimap contains no key-value mappings
func (m *ImmutableListMultimap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return len(m.entries) == 0
}</span>

// Clear logs an error as ImmutableListMultimap is immutable
func (m *ImmutableListMultimap[K, V]) Clear() <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Clear", "create a new empty multimap")
        log.Printf("Warning: %v", err)
}</span>

// Contains returns true if this multimap contains the specified element
func (m *ImmutableListMultimap[K, V]) Contains(key K) bool <span class="cov0" title="0">{
        return m.ContainsKey(key)
}</span>

// String returns a string representation of this multimap
func (m *ImmutableListMultimap[K, V]) String() string <span class="cov0" title="0">{
        if m.IsEmpty() </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("{")

        first := true
        for key, values := range m.data </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">first = false

                builder.WriteString(fmt.Sprintf("%v=[%v]", key, formatValues(values)))</span>
        }

        <span class="cov0" title="0">builder.WriteString("}")
        return builder.String()</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package multimap

import (
        "fmt"
        "strings"
        "log"
        "github.com/chenjianyu/collections/container/common"
)

// ImmutableMultimap is an immutable implementation of a multimap
type ImmutableMultimap[K comparable, V comparable] struct {
        entries []Entry[K, V]
        data    map[K][]V
}

// NewImmutableMultimap creates a new ImmutableMultimap from the given entries
func NewImmutableMultimap[K comparable, V comparable](entries []Entry[K, V]) *ImmutableMultimap[K, V] <span class="cov8" title="1">{
        data := make(map[K][]V)
        
        // Group values by key
        for _, entry := range entries </span><span class="cov8" title="1">{
                data[entry.Key] = append(data[entry.Key], entry.Value)
        }</span>
        
        <span class="cov8" title="1">return &amp;ImmutableMultimap[K, V]{
                entries: append([]Entry[K, V]{}, entries...), // Create a copy of entries
                data:    data,
        }</span>
}

// Of creates a new ImmutableMultimap from the given key-value pairs
func Of[K comparable, V comparable](pairs ...interface{}) *ImmutableMultimap[K, V] <span class="cov8" title="1">{
        if len(pairs)%2 != 0 </span><span class="cov0" title="0">{
                err := common.ImmutableOperationError("Of requires an even number of arguments", "provide key-value pairs")
                log.Printf("Warning: %v", err)
                return NewImmutableMultimap([]Entry[K, V]{})
        }</span>
        
        <span class="cov8" title="1">entries := make([]Entry[K, V], 0, len(pairs)/2)
        
        for i := 0; i &lt; len(pairs); i += 2 </span><span class="cov8" title="1">{
                key, ok1 := pairs[i].(K)
                value, ok2 := pairs[i+1].(V)
                
                if !ok1 || !ok2 </span><span class="cov0" title="0">{
                        err := common.ImmutableOperationError("invalid type for key or value", "ensure correct types")
                        log.Printf("Warning: %v", err)
                        return NewImmutableMultimap([]Entry[K, V]{})
                }</span>
                
                <span class="cov8" title="1">entries = append(entries, Entry[K, V]{Key: key, Value: value})</span>
        }
        
        <span class="cov8" title="1">return NewImmutableMultimap(entries)</span>
}

// FromMultimap creates a new ImmutableMultimap from the given multimap
func FromMultimap[K comparable, V comparable](multimap Multimap[K, V]) *ImmutableMultimap[K, V] <span class="cov8" title="1">{
        return NewImmutableMultimap(multimap.Entries())
}</span>

// Put is not supported for ImmutableMultimap and will panic
func (m *ImmutableMultimap[K, V]) Put(key K, value V) bool <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Put", "use builder pattern")
        log.Printf("Warning: %v", err)
        return false
}</span>

// PutAll is not supported for ImmutableMultimap and will panic
func (m *ImmutableMultimap[K, V]) PutAll(multimap Multimap[K, V]) bool <span class="cov0" title="0">{
        err := common.ImmutableOperationError("PutAll", "use builder pattern")
        log.Printf("Warning: %v", err)
        return false
}</span>

// ReplaceValues is not supported for ImmutableMultimap and will panic
func (m *ImmutableMultimap[K, V]) ReplaceValues(key K, values []V) []V <span class="cov0" title="0">{
        err := common.ImmutableOperationError("ReplaceValues", "use builder pattern")
        log.Printf("Warning: %v", err)
        return nil
}</span>

// Remove is not supported for ImmutableMultimap and will panic
func (m *ImmutableMultimap[K, V]) Remove(key K, value V) bool <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Remove", "use builder pattern")
        log.Printf("Warning: %v", err)
        return false
}</span>

// RemoveAll is not supported for ImmutableMultimap and will panic
func (m *ImmutableMultimap[K, V]) RemoveAll(key K) []V <span class="cov0" title="0">{
        err := common.ImmutableOperationError("RemoveAll", "use builder pattern")
        log.Printf("Warning: %v", err)
        return nil
}</span>

// ContainsKey returns true if this multimap contains at least one key-value mapping with the specified key
func (m *ImmutableMultimap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        _, exists := m.data[key]
        return exists
}</span>

// ContainsValue returns true if this multimap contains at least one key-value mapping with the specified value
func (m *ImmutableMultimap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        for _, values := range m.data </span><span class="cov8" title="1">{
                for _, v := range values </span><span class="cov8" title="1">{
                        if v == value </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// ContainsEntry returns true if this multimap contains the specified key-value mapping
func (m *ImmutableMultimap[K, V]) ContainsEntry(key K, value V) bool <span class="cov8" title="1">{
        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                if v == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

// Get returns all values associated with the specified key
func (m *ImmutableMultimap[K, V]) Get(key K) []V <span class="cov8" title="1">{
        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Return a copy to maintain immutability
        <span class="cov8" title="1">result := make([]V, len(values))
        copy(result, values)
        return result</span>
}

// Keys returns all distinct keys in this multimap
func (m *ImmutableMultimap[K, V]) Keys() []K <span class="cov0" title="0">{
        keys := make([]K, 0, len(m.data))
        for key := range m.data </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Values returns all values in this multimap
func (m *ImmutableMultimap[K, V]) Values() []V <span class="cov0" title="0">{
        values := make([]V, 0, len(m.entries))
        for _, entry := range m.entries </span><span class="cov0" title="0">{
                values = append(values, entry.Value)
        }</span>
        <span class="cov0" title="0">return values</span>
}

// Entries returns all key-value pairs in this multimap
func (m *ImmutableMultimap[K, V]) Entries() []Entry[K, V] <span class="cov0" title="0">{
        // Return a copy to maintain immutability
        result := make([]Entry[K, V], len(m.entries))
        copy(result, m.entries)
        return result
}</span>

// KeySet returns a set view of the distinct keys in this multimap
func (m *ImmutableMultimap[K, V]) KeySet() []K <span class="cov0" title="0">{
        return m.Keys()
}</span>

// AsMap returns a map view of this multimap, mapping each key to its collection of values
func (m *ImmutableMultimap[K, V]) AsMap() map[K][]V <span class="cov0" title="0">{
        // Return a deep copy to maintain immutability
        result := make(map[K][]V, len(m.data))
        for key, values := range m.data </span><span class="cov0" title="0">{
                valuesCopy := make([]V, len(values))
                copy(valuesCopy, values)
                result[key] = valuesCopy
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ForEach executes the given function for each key-value pair in this multimap
func (m *ImmutableMultimap[K, V]) ForEach(f func(K, V)) <span class="cov0" title="0">{
        for _, entry := range m.entries </span><span class="cov0" title="0">{
                f(entry.Key, entry.Value)
        }</span>
}

// Size returns the number of key-value mappings in this multimap
func (m *ImmutableMultimap[K, V]) Size() int <span class="cov8" title="1">{
        return len(m.entries)
}</span>

// IsEmpty returns true if this multimap contains no key-value mappings
func (m *ImmutableMultimap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return len(m.entries) == 0
}</span>

// Clear is not supported for ImmutableMultimap and will panic
func (m *ImmutableMultimap[K, V]) Clear() <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Clear", "create a new empty multimap")
        log.Printf("Warning: %v", err)
}</span>

// Contains returns true if this multimap contains the specified element
func (m *ImmutableMultimap[K, V]) Contains(key K) bool <span class="cov0" title="0">{
        return m.ContainsKey(key)
}</span>

// String returns a string representation of this multimap
func (m *ImmutableMultimap[K, V]) String() string <span class="cov0" title="0">{
        if m.IsEmpty() </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("{")

        first := true
        for key, values := range m.data </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">first = false

                builder.WriteString(fmt.Sprintf("%v=[%v]", key, formatValues(values)))</span>
        }

        <span class="cov0" title="0">builder.WriteString("}")
        return builder.String()</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package multimap

import (
        "fmt"
        "strings"
        "log"
        "github.com/chenjianyu/collections/container/common"
        "github.com/chenjianyu/collections/container/set"
)

// ImmutableSetMultimap is an immutable implementation of a multimap that eliminates duplicate values
type ImmutableSetMultimap[K comparable, V comparable] struct {
        entries []Entry[K, V]
        data    map[K][]V
        sets    map[K]set.Set[V] // Used for quick lookups and deduplication
}

// NewImmutableSetMultimap creates a new ImmutableSetMultimap from the given entries
func NewImmutableSetMultimap[K comparable, V comparable](entries []Entry[K, V]) *ImmutableSetMultimap[K, V] <span class="cov8" title="1">{
        data := make(map[K][]V)
        sets := make(map[K]set.Set[V])
        dedupEntries := make([]Entry[K, V], 0)
        
        // Group values by key and eliminate duplicates
        for _, entry := range entries </span><span class="cov8" title="1">{
                key := entry.Key
                value := entry.Value
                
                // Initialize set for this key if it doesn't exist
                if _, exists := sets[key]; !exists </span><span class="cov8" title="1">{
                        sets[key] = set.New[V]()
                }</span>
                
                // Only add if not already present
                <span class="cov8" title="1">if !sets[key].Contains(value) </span><span class="cov8" title="1">{
                        sets[key].Add(value)
                        data[key] = append(data[key], value)
                        dedupEntries = append(dedupEntries, entry)
                }</span>
        }
        
        <span class="cov8" title="1">return &amp;ImmutableSetMultimap[K, V]{
                entries: dedupEntries,
                data:    data,
                sets:    sets,
        }</span>
}

// SetOf creates a new ImmutableSetMultimap from the given key-value pairs
func SetOf[K comparable, V comparable](pairs ...interface{}) *ImmutableSetMultimap[K, V] <span class="cov8" title="1">{
        if len(pairs)%2 != 0 </span><span class="cov0" title="0">{
                err := common.ImmutableOperationError("SetOf requires an even number of arguments", "provide key-value pairs")
                log.Printf("Warning: %v", err)
                return NewImmutableSetMultimap([]Entry[K, V]{})
        }</span>
        
        <span class="cov8" title="1">entries := make([]Entry[K, V], 0, len(pairs)/2)
        
        for i := 0; i &lt; len(pairs); i += 2 </span><span class="cov8" title="1">{
                key, ok1 := pairs[i].(K)
                value, ok2 := pairs[i+1].(V)
                
                if !ok1 || !ok2 </span><span class="cov0" title="0">{
                        err := common.ImmutableOperationError("invalid type for key or value", "ensure correct types")
                        log.Printf("Warning: %v", err)
                        return NewImmutableSetMultimap([]Entry[K, V]{})
                }</span>
                
                <span class="cov8" title="1">entries = append(entries, Entry[K, V]{Key: key, Value: value})</span>
        }
        
        <span class="cov8" title="1">return NewImmutableSetMultimap(entries)</span>
}

// FromHashMultimap creates a new ImmutableSetMultimap from the given HashMultimap
func FromHashMultimap[K comparable, V comparable](multimap *HashMultimap[K, V]) *ImmutableSetMultimap[K, V] <span class="cov8" title="1">{
        return NewImmutableSetMultimap(multimap.Entries())
}</span>

// FromMultimapToSet creates a new ImmutableSetMultimap from any multimap
func FromMultimapToSet[K comparable, V comparable](multimap Multimap[K, V]) *ImmutableSetMultimap[K, V] <span class="cov0" title="0">{
        return NewImmutableSetMultimap(multimap.Entries())
}</span>

// Put logs an error and returns false as ImmutableSetMultimap is immutable
func (m *ImmutableSetMultimap[K, V]) Put(key K, value V) bool <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Put", "use builder pattern")
        log.Printf("Warning: %v", err)
        return false
}</span>

// PutAll logs an error and returns false as ImmutableSetMultimap is immutable
func (m *ImmutableSetMultimap[K, V]) PutAll(multimap Multimap[K, V]) bool <span class="cov0" title="0">{
        err := common.ImmutableOperationError("PutAll", "use builder pattern")
        log.Printf("Warning: %v", err)
        return false
}</span>

// ReplaceValues logs an error and returns nil as ImmutableSetMultimap is immutable
func (m *ImmutableSetMultimap[K, V]) ReplaceValues(key K, values []V) []V <span class="cov0" title="0">{
        err := common.ImmutableOperationError("ReplaceValues", "use builder pattern")
        log.Printf("Warning: %v", err)
        return nil
}</span>

// Remove logs an error and returns false as ImmutableSetMultimap is immutable
func (m *ImmutableSetMultimap[K, V]) Remove(key K, value V) bool <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Remove", "use builder pattern")
        log.Printf("Warning: %v", err)
        return false
}</span>

// RemoveAll logs an error and returns nil as ImmutableSetMultimap is immutable
func (m *ImmutableSetMultimap[K, V]) RemoveAll(key K) []V <span class="cov0" title="0">{
        err := common.ImmutableOperationError("RemoveAll", "use builder pattern")
        log.Printf("Warning: %v", err)
        return nil
}</span>

// ContainsKey returns true if this multimap contains at least one key-value mapping with the specified key
func (m *ImmutableSetMultimap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        _, exists := m.data[key]
        return exists
}</span>

// ContainsValue returns true if this multimap contains at least one key-value mapping with the specified value
func (m *ImmutableSetMultimap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        for _, values := range m.data </span><span class="cov8" title="1">{
                for _, v := range values </span><span class="cov8" title="1">{
                        if v == value </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// ContainsEntry returns true if this multimap contains the specified key-value mapping
func (m *ImmutableSetMultimap[K, V]) ContainsEntry(key K, value V) bool <span class="cov8" title="1">{
        set, exists := m.sets[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">return set.Contains(value)</span>
}

// Get returns all values associated with the specified key, with duplicates removed
func (m *ImmutableSetMultimap[K, V]) Get(key K) []V <span class="cov8" title="1">{
        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Return a copy to maintain immutability
        <span class="cov8" title="1">result := make([]V, len(values))
        copy(result, values)
        return result</span>
}

// Keys returns all distinct keys in this multimap
func (m *ImmutableSetMultimap[K, V]) Keys() []K <span class="cov0" title="0">{
        keys := make([]K, 0, len(m.data))
        for key := range m.data </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Values returns all values in this multimap with duplicates removed
func (m *ImmutableSetMultimap[K, V]) Values() []V <span class="cov0" title="0">{
        values := make([]V, 0, len(m.entries))
        for _, entry := range m.entries </span><span class="cov0" title="0">{
                values = append(values, entry.Value)
        }</span>
        <span class="cov0" title="0">return values</span>
}

// Entries returns all key-value pairs in this multimap with duplicates removed
func (m *ImmutableSetMultimap[K, V]) Entries() []Entry[K, V] <span class="cov0" title="0">{
        // Return a copy to maintain immutability
        result := make([]Entry[K, V], len(m.entries))
        copy(result, m.entries)
        return result
}</span>

// KeySet returns a set view of the distinct keys in this multimap
func (m *ImmutableSetMultimap[K, V]) KeySet() []K <span class="cov0" title="0">{
        return m.Keys()
}</span>

// AsMap returns a map view of this multimap, mapping each key to its collection of values
func (m *ImmutableSetMultimap[K, V]) AsMap() map[K][]V <span class="cov0" title="0">{
        // Return a deep copy to maintain immutability
        result := make(map[K][]V, len(m.data))
        for key, values := range m.data </span><span class="cov0" title="0">{
                valuesCopy := make([]V, len(values))
                copy(valuesCopy, values)
                result[key] = valuesCopy
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ForEach executes the given function for each key-value pair in this multimap
func (m *ImmutableSetMultimap[K, V]) ForEach(f func(K, V)) <span class="cov0" title="0">{
        for _, entry := range m.entries </span><span class="cov0" title="0">{
                f(entry.Key, entry.Value)
        }</span>
}

// Size returns the number of key-value mappings in this multimap
func (m *ImmutableSetMultimap[K, V]) Size() int <span class="cov8" title="1">{
        return len(m.entries)
}</span>

// IsEmpty returns true if this multimap contains no key-value mappings
func (m *ImmutableSetMultimap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return len(m.entries) == 0
}</span>

// Clear logs an error as ImmutableSetMultimap is immutable
func (m *ImmutableSetMultimap[K, V]) Clear() <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Clear", "create a new empty multimap")
        log.Printf("Warning: %v", err)
}</span>

// Contains returns true if this multimap contains the specified element
func (m *ImmutableSetMultimap[K, V]) Contains(key K) bool <span class="cov0" title="0">{
        return m.ContainsKey(key)
}</span>

// String returns a string representation of this multimap
func (m *ImmutableSetMultimap[K, V]) String() string <span class="cov0" title="0">{
        if m.IsEmpty() </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("{")

        first := true
        for key, values := range m.data </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">first = false

                builder.WriteString(fmt.Sprintf("%v=[%v]", key, formatValues(values)))</span>
        }

        <span class="cov0" title="0">builder.WriteString("}")
        return builder.String()</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package multimap

import (
        "fmt"
        "strings"
        "sync"

        "github.com/chenjianyu/collections/container/set"
)

// LinkedHashMultimap is a multimap implementation that maintains insertion order of keys and values
type LinkedHashMultimap[K comparable, V comparable] struct {
        data   map[K]set.Set[V]
        keys   []K                 // Maintains insertion order of keys
        values map[K]map[V]struct{} // Tracks insertion order of values for each key
        size   int
        mutex  sync.RWMutex
}

// NewLinkedHashMultimap creates a new LinkedHashMultimap
func NewLinkedHashMultimap[K comparable, V comparable]() *LinkedHashMultimap[K, V] <span class="cov8" title="1">{
        return &amp;LinkedHashMultimap[K, V]{
                data:   make(map[K]set.Set[V]),
                keys:   make([]K, 0),
                values: make(map[K]map[V]struct{}),
                size:   0,
        }
}</span>

// Put adds a key-value mapping to this multimap
func (m *LinkedHashMultimap[K, V]) Put(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov8" title="1">{
                values = set.NewLinkedHashSet[V]()
                m.data[key] = values
                m.keys = append(m.keys, key)
                m.values[key] = make(map[V]struct{})
        }</span>

        <span class="cov8" title="1">result := values.Add(value)
        if result </span><span class="cov8" title="1">{
                m.size++
                // Track insertion order of values
                m.values[key][value] = struct{}{}
        }</span>

        <span class="cov8" title="1">return result</span>
}

// PutAll adds all key-value mappings from the specified multimap to this multimap
func (m *LinkedHashMultimap[K, V]) PutAll(multimap Multimap[K, V]) bool <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        changed := false
        
        // Preserve insertion order by iterating through entries
        for _, entry := range multimap.Entries() </span><span class="cov0" title="0">{
                key := entry.Key
                value := entry.Value
                
                values, exists := m.data[key]
                if !exists </span><span class="cov0" title="0">{
                        values = set.NewLinkedHashSet[V]()
                        m.data[key] = values
                        m.keys = append(m.keys, key)
                        m.values[key] = make(map[V]struct{})
                }</span>

                <span class="cov0" title="0">result := values.Add(value)
                if result </span><span class="cov0" title="0">{
                        m.size++
                        m.values[key][value] = struct{}{}
                        changed = true
                }</span>
        }

        <span class="cov0" title="0">return changed</span>
}

// ReplaceValues replaces all values for a key with the specified collection of values
func (m *LinkedHashMultimap[K, V]) ReplaceValues(key K, values []V) []V <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        oldValues, exists := m.data[key]
        if exists </span><span class="cov0" title="0">{
                oldValuesSlice := oldValues.ToSlice()
                m.size -= oldValues.Size()
                delete(m.data, key)
                delete(m.values, key)

                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                        newValues := set.NewLinkedHashSet[V]()
                        m.values[key] = make(map[V]struct{})
                        
                        for _, value := range values </span><span class="cov0" title="0">{
                                newValues.Add(value)
                                m.values[key][value] = struct{}{}
                        }</span>
                        
                        <span class="cov0" title="0">m.data[key] = newValues
                        m.size += newValues.Size()</span>
                } else<span class="cov0" title="0"> {
                        // Remove key from keys slice if no values remain
                        for i, k := range m.keys </span><span class="cov0" title="0">{
                                if k == key </span><span class="cov0" title="0">{
                                        m.keys = append(m.keys[:i], m.keys[i+1:]...)
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">return oldValuesSlice</span>
        } else<span class="cov0" title="0"> if len(values) &gt; 0 </span><span class="cov0" title="0">{
                newValues := set.NewLinkedHashSet[V]()
                m.keys = append(m.keys, key)
                m.values[key] = make(map[V]struct{})
                
                for _, value := range values </span><span class="cov0" title="0">{
                        newValues.Add(value)
                        m.values[key][value] = struct{}{}
                }</span>
                
                <span class="cov0" title="0">m.data[key] = newValues
                m.size += newValues.Size()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Remove removes a key-value mapping from this multimap
func (m *LinkedHashMultimap[K, V]) Remove(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">result := values.Remove(value)
        if result </span><span class="cov8" title="1">{
                m.size--
                delete(m.values[key], value)
                
                if values.IsEmpty() </span><span class="cov0" title="0">{
                        delete(m.data, key)
                        delete(m.values, key)
                        
                        // Remove key from keys slice
                        for i, k := range m.keys </span><span class="cov0" title="0">{
                                if k == key </span><span class="cov0" title="0">{
                                        m.keys = append(m.keys[:i], m.keys[i+1:]...)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return result</span>
}

// RemoveAll removes all values associated with a key
func (m *LinkedHashMultimap[K, V]) RemoveAll(key K) []V <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">result := values.ToSlice()
        m.size -= values.Size()
        delete(m.data, key)
        delete(m.values, key)
        
        // Remove key from keys slice
        for i, k := range m.keys </span><span class="cov8" title="1">{
                if k == key </span><span class="cov8" title="1">{
                        m.keys = append(m.keys[:i], m.keys[i+1:]...)
                        break</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// ContainsKey returns true if this multimap contains at least one key-value mapping with the specified key
func (m *LinkedHashMultimap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        _, exists := m.data[key]
        return exists
}</span>

// ContainsValue returns true if this multimap contains at least one key-value mapping with the specified value
func (m *LinkedHashMultimap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        for _, values := range m.data </span><span class="cov8" title="1">{
                if values.Contains(value) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ContainsEntry returns true if this multimap contains the specified key-value mapping
func (m *LinkedHashMultimap[K, V]) ContainsEntry(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return values.Contains(value)</span>
}

// Get returns all values associated with the specified key
func (m *LinkedHashMultimap[K, V]) Get(key K) []V <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return values.ToSlice()</span>
}

// Keys returns all distinct keys in this multimap in insertion order
func (m *LinkedHashMultimap[K, V]) Keys() []K <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make([]K, len(m.keys))
        copy(result, m.keys)
        return result
}</span>

// Values returns all values in this multimap in insertion order
func (m *LinkedHashMultimap[K, V]) Values() []V <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values := make([]V, 0, m.size)
        
        // Iterate through keys in insertion order
        for _, key := range m.keys </span><span class="cov8" title="1">{
                valueSet := m.data[key]
                values = append(values, valueSet.ToSlice()...)
        }</span>

        <span class="cov8" title="1">return values</span>
}

// Entries returns all key-value pairs in this multimap in insertion order
func (m *LinkedHashMultimap[K, V]) Entries() []Entry[K, V] <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        entries := make([]Entry[K, V], 0, m.size)
        
        // Iterate through keys in insertion order
        for _, key := range m.keys </span><span class="cov8" title="1">{
                valueSet := m.data[key]
                for _, value := range valueSet.ToSlice() </span><span class="cov8" title="1">{
                        entries = append(entries, Entry[K, V]{Key: key, Value: value})
                }</span>
        }

        <span class="cov8" title="1">return entries</span>
}

// KeySet returns a set view of the distinct keys in this multimap in insertion order
func (m *LinkedHashMultimap[K, V]) KeySet() []K <span class="cov0" title="0">{
        return m.Keys()
}</span>

// AsMap returns a map view of this multimap, mapping each key to its collection of values
func (m *LinkedHashMultimap[K, V]) AsMap() map[K][]V <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make(map[K][]V, len(m.data))
        for key, valueSet := range m.data </span><span class="cov0" title="0">{
                result[key] = valueSet.ToSlice()
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ForEach executes the given function for each key-value pair in this multimap in insertion order
func (m *LinkedHashMultimap[K, V]) ForEach(f func(K, V)) <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        // Iterate through keys in insertion order
        for _, key := range m.keys </span><span class="cov0" title="0">{
                valueSet := m.data[key]
                for _, value := range valueSet.ToSlice() </span><span class="cov0" title="0">{
                        f(key, value)
                }</span>
        }
}

// Size returns the number of key-value mappings in this multimap
func (m *LinkedHashMultimap[K, V]) Size() int <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.size
}</span>

// IsEmpty returns true if this multimap contains no key-value mappings
func (m *LinkedHashMultimap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.size == 0
}</span>

// Clear removes all key-value mappings from this multimap
func (m *LinkedHashMultimap[K, V]) Clear() <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.data = make(map[K]set.Set[V])
        m.keys = make([]K, 0)
        m.values = make(map[K]map[V]struct{})
        m.size = 0
}</span>

// Contains returns true if this multimap contains the specified element
func (m *LinkedHashMultimap[K, V]) Contains(key K) bool <span class="cov0" title="0">{
        return m.ContainsKey(key)
}</span>

// String returns a string representation of this multimap
func (m *LinkedHashMultimap[K, V]) String() string <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.IsEmpty() </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("{")

        first := true
        for _, key := range m.keys </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">first = false

                valueSet := m.data[key]
                builder.WriteString(fmt.Sprintf("%v=[%v]", key, formatValues(valueSet.ToSlice())))</span>
        }

        <span class="cov0" title="0">builder.WriteString("}")
        return builder.String()</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package multimap

import (
        "fmt"
        "strings"
        "sync"

        "github.com/chenjianyu/collections/container/set"
)

// TreeMultimap is a multimap implementation that maintains keys in sorted order
type TreeMultimap[K comparable, V comparable] struct {
        data   map[K]set.Set[V]
        keys   []K // Maintains sorted order of keys
        size   int
        mutex  sync.RWMutex
}

// NewTreeMultimap creates a new TreeMultimap
func NewTreeMultimap[K comparable, V comparable]() *TreeMultimap[K, V] <span class="cov8" title="1">{
        return &amp;TreeMultimap[K, V]{
                data: make(map[K]set.Set[V]),
                keys: make([]K, 0),
                size: 0,
        }
}</span>

// sortKeys sorts the keys slice
func (m *TreeMultimap[K, V]) sortKeys() <span class="cov8" title="1">{
        // Sort keys using insertion sort for simplicity
        for i := 1; i &lt; len(m.keys); i++ </span><span class="cov8" title="1">{
                key := m.keys[i]
                j := i - 1
                // Compare keys using the Compare function
                for j &gt;= 0 &amp;&amp; compare(m.keys[j], key) &gt; 0 </span><span class="cov8" title="1">{
                        m.keys[j+1] = m.keys[j]
                        j--
                }</span>
                <span class="cov8" title="1">m.keys[j+1] = key</span>
        }
}

// compare compares two comparable type values
func compare[E comparable](a, b E) int <span class="cov8" title="1">{
        // Check if the type implements CompareTo method (like ComparableString, ComparableInt)
        if comparableA, ok := any(a).(interface{ CompareTo(interface{}) int }); ok </span><span class="cov8" title="1">{
                return comparableA.CompareTo(b)
        }</span>
        
        // Try to convert to int type
        <span class="cov0" title="0">cmpA, okA := any(a).(int)
        cmpB, okB := any(b).(int)
        if okA &amp;&amp; okB </span><span class="cov0" title="0">{
                if cmpA == cmpB </span><span class="cov0" title="0">{
                        return 0
                }</span> else<span class="cov0" title="0"> if cmpA &lt; cmpB </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> {
                        return 1
                }</span>
        }
        // For string type
        <span class="cov0" title="0">strA, okA := any(a).(string)
        strB, okB := any(b).(string)
        if okA &amp;&amp; okB </span><span class="cov0" title="0">{
                if strA == strB </span><span class="cov0" title="0">{
                        return 0
                }</span> else<span class="cov0" title="0"> if strA &lt; strB </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> {
                        return 1
                }</span>
        }
        
        // Use reflection to compare values as a fallback
        // This handles cases where types are equal but not specifically handled above
        <span class="cov0" title="0">if a == b </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        // For types that can't be compared, we'll use string representation
        <span class="cov0" title="0">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        if aStr == bStr </span><span class="cov0" title="0">{
                return 0
        }</span> else<span class="cov0" title="0"> if aStr &lt; bStr </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov0" title="0"> {
                return 1
        }</span>
}

// findKeyIndex finds the index of a key in the sorted keys slice
func (m *TreeMultimap[K, V]) findKeyIndex(key K) int <span class="cov8" title="1">{
        for i, k := range m.keys </span><span class="cov8" title="1">{
                if compare(k, key) == 0 </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// Put adds a key-value mapping to this multimap
func (m *TreeMultimap[K, V]) Put(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov8" title="1">{
                values = set.NewTreeSetWithComparator[V](compare[V])
                m.data[key] = values
                m.keys = append(m.keys, key)
                m.sortKeys()
        }</span>

        <span class="cov8" title="1">result := values.Add(value)
        if result </span><span class="cov8" title="1">{
                m.size++
        }</span>

        <span class="cov8" title="1">return result</span>
}

// PutAll adds all key-value mappings from the specified multimap to this multimap
func (m *TreeMultimap[K, V]) PutAll(multimap Multimap[K, V]) bool <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        changed := false
        multimap.ForEach(func(key K, value V) </span><span class="cov0" title="0">{
                values, exists := m.data[key]
                if !exists </span><span class="cov0" title="0">{
                        values = set.NewTreeSetWithComparator[V](compare[V])
                        m.data[key] = values
                        m.keys = append(m.keys, key)
                        // We'll sort keys once at the end for efficiency
                }</span>

                <span class="cov0" title="0">result := values.Add(value)
                if result </span><span class="cov0" title="0">{
                        m.size++
                        changed = true
                }</span>
        })

        // Sort keys if any were added
        <span class="cov0" title="0">if changed </span><span class="cov0" title="0">{
                m.sortKeys()
        }</span>

        <span class="cov0" title="0">return changed</span>
}

// ReplaceValues replaces all values for a key with the specified collection of values
func (m *TreeMultimap[K, V]) ReplaceValues(key K, values []V) []V <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        oldValues, exists := m.data[key]
        if exists </span><span class="cov0" title="0">{
                oldValuesSlice := oldValues.ToSlice()
                m.size -= oldValues.Size()
                delete(m.data, key)

                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                        newValues := set.NewTreeSetWithComparator[V](compare[V])
                        for _, value := range values </span><span class="cov0" title="0">{
                                newValues.Add(value)
                        }</span>
                        <span class="cov0" title="0">m.data[key] = newValues
                        m.size += newValues.Size()</span>
                } else<span class="cov0" title="0"> {
                        // Remove key from keys slice if no values remain
                        index := m.findKeyIndex(key)
                        if index &gt;= 0 </span><span class="cov0" title="0">{
                                m.keys = append(m.keys[:index], m.keys[index+1:]...)
                        }</span>
                }

                <span class="cov0" title="0">return oldValuesSlice</span>
        } else<span class="cov0" title="0"> if len(values) &gt; 0 </span><span class="cov0" title="0">{
                newValues := set.NewTreeSetWithComparator[V](compare[V])
                for _, value := range values </span><span class="cov0" title="0">{
                        newValues.Add(value)
                }</span>
                <span class="cov0" title="0">m.data[key] = newValues
                m.keys = append(m.keys, key)
                m.sortKeys()
                m.size += newValues.Size()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Remove removes a key-value mapping from this multimap
func (m *TreeMultimap[K, V]) Remove(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">result := values.Remove(value)
        if result </span><span class="cov8" title="1">{
                m.size--
                if values.IsEmpty() </span><span class="cov0" title="0">{
                        delete(m.data, key)
                        // Remove key from keys slice
                        index := m.findKeyIndex(key)
                        if index &gt;= 0 </span><span class="cov0" title="0">{
                                m.keys = append(m.keys[:index], m.keys[index+1:]...)
                        }</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// RemoveAll removes all values associated with a key
func (m *TreeMultimap[K, V]) RemoveAll(key K) []V <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">result := values.ToSlice()
        m.size -= values.Size()
        delete(m.data, key)
        
        // Remove key from keys slice
        index := m.findKeyIndex(key)
        if index &gt;= 0 </span><span class="cov8" title="1">{
                m.keys = append(m.keys[:index], m.keys[index+1:]...)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ContainsKey returns true if this multimap contains at least one key-value mapping with the specified key
func (m *TreeMultimap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        _, exists := m.data[key]
        return exists
}</span>

// ContainsValue returns true if this multimap contains at least one key-value mapping with the specified value
func (m *TreeMultimap[K, V]) ContainsValue(value V) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        for _, values := range m.data </span><span class="cov8" title="1">{
                if values.Contains(value) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// ContainsEntry returns true if this multimap contains the specified key-value mapping
func (m *TreeMultimap[K, V]) ContainsEntry(key K, value V) bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return values.Contains(value)</span>
}

// Get returns all values associated with the specified key
func (m *TreeMultimap[K, V]) Get(key K) []V <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values, exists := m.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return values.ToSlice()</span>
}

// Keys returns all distinct keys in this multimap in sorted order
func (m *TreeMultimap[K, V]) Keys() []K <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make([]K, len(m.keys))
        copy(result, m.keys)
        return result
}</span>

// Values returns all values in this multimap
func (m *TreeMultimap[K, V]) Values() []V <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        values := make([]V, 0, m.size)
        
        // Iterate through keys in sorted order
        for _, key := range m.keys </span><span class="cov8" title="1">{
                valueSet := m.data[key]
                values = append(values, valueSet.ToSlice()...)
        }</span>

        <span class="cov8" title="1">return values</span>
}

// Entries returns all key-value pairs in this multimap
func (m *TreeMultimap[K, V]) Entries() []Entry[K, V] <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        entries := make([]Entry[K, V], 0, m.size)
        
        // Iterate through keys in sorted order
        for _, key := range m.keys </span><span class="cov8" title="1">{
                valueSet := m.data[key]
                for _, value := range valueSet.ToSlice() </span><span class="cov8" title="1">{
                        entries = append(entries, Entry[K, V]{Key: key, Value: value})
                }</span>
        }

        <span class="cov8" title="1">return entries</span>
}

// KeySet returns a set view of the distinct keys in this multimap
func (m *TreeMultimap[K, V]) KeySet() []K <span class="cov0" title="0">{
        return m.Keys()
}</span>

// AsMap returns a map view of this multimap, mapping each key to its collection of values
func (m *TreeMultimap[K, V]) AsMap() map[K][]V <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make(map[K][]V, len(m.data))
        for key, valueSet := range m.data </span><span class="cov0" title="0">{
                result[key] = valueSet.ToSlice()
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ForEach executes the given function for each key-value pair in this multimap
func (m *TreeMultimap[K, V]) ForEach(f func(K, V)) <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        // Iterate through keys in sorted order
        for _, key := range m.keys </span><span class="cov0" title="0">{
                valueSet := m.data[key]
                for _, value := range valueSet.ToSlice() </span><span class="cov0" title="0">{
                        f(key, value)
                }</span>
        }
}

// Size returns the number of key-value mappings in this multimap
func (m *TreeMultimap[K, V]) Size() int <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.size
}</span>

// IsEmpty returns true if this multimap contains no key-value mappings
func (m *TreeMultimap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.size == 0
}</span>

// Clear removes all key-value mappings from this multimap
func (m *TreeMultimap[K, V]) Clear() <span class="cov8" title="1">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.data = make(map[K]set.Set[V])
        m.keys = make([]K, 0)
        m.size = 0
}</span>

// Contains returns true if this multimap contains the specified element
func (m *TreeMultimap[K, V]) Contains(key K) bool <span class="cov0" title="0">{
        return m.ContainsKey(key)
}</span>

// String returns a string representation of this multimap
func (m *TreeMultimap[K, V]) String() string <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.IsEmpty() </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("{")

        first := true
        for _, key := range m.keys </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">first = false

                valueSet := m.data[key]
                builder.WriteString(fmt.Sprintf("%v=[%v]", key, formatValues[V](valueSet.ToSlice())))</span>
        }

        <span class="cov0" title="0">builder.WriteString("}")
        return builder.String()</span>
}</pre>
		
		<pre class="file" id="file16" style="display: none">package multiset

import (
        "fmt"
        "strings"
        "sync"
        "sync/atomic"

        "github.com/chenjianyu/collections/container/common"
)

// ConcurrentHashMultiset is a thread-safe multiset implementation
// It uses fine-grained locking with segment-based approach for better concurrency
type ConcurrentHashMultiset[E comparable] struct {
        segments []*segment[E]
        segMask  uint32
        size     int64
}

type segment[E comparable] struct {
        counts map[E]int
        mu     sync.RWMutex
}

const (
        defaultSegmentCount = 16
        defaultSegmentSize  = 16
)

// NewConcurrentHashMultiset creates a new empty ConcurrentHashMultiset
func NewConcurrentHashMultiset[E comparable]() *ConcurrentHashMultiset[E] <span class="cov8" title="1">{
        return NewConcurrentHashMultisetWithSegments[E](defaultSegmentCount)
}</span>

// NewConcurrentHashMultisetWithSegments creates a new ConcurrentHashMultiset with specified segment count
func NewConcurrentHashMultisetWithSegments[E comparable](segmentCount int) *ConcurrentHashMultiset[E] <span class="cov8" title="1">{
        // Ensure segment count is a power of 2
        if segmentCount &lt;= 0 </span><span class="cov0" title="0">{
                segmentCount = defaultSegmentCount
        }</span>
        
        // Round up to next power of 2
        <span class="cov8" title="1">actualSegmentCount := 1
        for actualSegmentCount &lt; segmentCount </span><span class="cov8" title="1">{
                actualSegmentCount &lt;&lt;= 1
        }</span>
        
        <span class="cov8" title="1">segments := make([]*segment[E], actualSegmentCount)
        for i := range segments </span><span class="cov8" title="1">{
                segments[i] = &amp;segment[E]{
                        counts: make(map[E]int, defaultSegmentSize),
                }
        }</span>
        
        <span class="cov8" title="1">return &amp;ConcurrentHashMultiset[E]{
                segments: segments,
                segMask:  uint32(actualSegmentCount - 1),
        }</span>
}

// NewConcurrentHashMultisetFromSlice creates a new ConcurrentHashMultiset from a slice
func NewConcurrentHashMultisetFromSlice[E comparable](elements []E) *ConcurrentHashMultiset[E] <span class="cov0" title="0">{
        ms := NewConcurrentHashMultiset[E]()
        for _, element := range elements </span><span class="cov0" title="0">{
                ms.Add(element)
        }</span>
        <span class="cov0" title="0">return ms</span>
}

// hash computes a hash value for the given element
func (ms *ConcurrentHashMultiset[E]) hash(element E) uint32 <span class="cov8" title="1">{
        // Simple hash function - in production, use a better hash function
        str := fmt.Sprintf("%v", element)
        var hash uint32 = 5381
        for _, c := range str </span><span class="cov8" title="1">{
                hash = ((hash &lt;&lt; 5) + hash) + uint32(c)
        }</span>
        <span class="cov8" title="1">return hash</span>
}

// getSegment returns the segment for the given element
func (ms *ConcurrentHashMultiset[E]) getSegment(element E) *segment[E] <span class="cov8" title="1">{
        hash := ms.hash(element)
        return ms.segments[hash&amp;ms.segMask]
}</span>

// Add adds one occurrence of the specified element
func (ms *ConcurrentHashMultiset[E]) Add(element E) int <span class="cov8" title="1">{
        seg := ms.getSegment(element)
        seg.mu.Lock()
        defer seg.mu.Unlock()
        
        prevCount := seg.counts[element]
        seg.counts[element] = prevCount + 1
        atomic.AddInt64(&amp;ms.size, 1)
        return prevCount
}</span>

// AddCount adds the specified number of occurrences of the element
func (ms *ConcurrentHashMultiset[E]) AddCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return ms.Count(element), nil
        }</span>
        
        <span class="cov8" title="1">seg := ms.getSegment(element)
        seg.mu.Lock()
        defer seg.mu.Unlock()
        
        prevCount := seg.counts[element]
        seg.counts[element] = prevCount + count
        atomic.AddInt64(&amp;ms.size, int64(count))
        return prevCount, nil</span>
}

// Remove removes one occurrence of the specified element
func (ms *ConcurrentHashMultiset[E]) Remove(element E) int <span class="cov8" title="1">{
        seg := ms.getSegment(element)
        seg.mu.Lock()
        defer seg.mu.Unlock()
        
        prevCount := seg.counts[element]
        if prevCount &gt; 0 </span><span class="cov8" title="1">{
                if prevCount == 1 </span><span class="cov0" title="0">{
                        delete(seg.counts, element)
                }</span> else<span class="cov8" title="1"> {
                        seg.counts[element] = prevCount - 1
                }</span>
                <span class="cov8" title="1">atomic.AddInt64(&amp;ms.size, -1)</span>
        }
        <span class="cov8" title="1">return prevCount</span>
}

// RemoveCount removes the specified number of occurrences of the element
func (ms *ConcurrentHashMultiset[E]) RemoveCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return ms.Count(element), nil
        }</span>
        
        <span class="cov8" title="1">seg := ms.getSegment(element)
        seg.mu.Lock()
        defer seg.mu.Unlock()
        
        prevCount := seg.counts[element]
        if prevCount &gt; 0 </span><span class="cov8" title="1">{
                removeCount := count
                if removeCount &gt; prevCount </span><span class="cov0" title="0">{
                        removeCount = prevCount
                }</span>
                
                <span class="cov8" title="1">newCount := prevCount - removeCount
                if newCount == 0 </span><span class="cov0" title="0">{
                        delete(seg.counts, element)
                }</span> else<span class="cov8" title="1"> {
                        seg.counts[element] = newCount
                }</span>
                <span class="cov8" title="1">atomic.AddInt64(&amp;ms.size, -int64(removeCount))</span>
        }
        <span class="cov8" title="1">return prevCount, nil</span>
}

// RemoveAll removes all occurrences of the specified element
func (ms *ConcurrentHashMultiset[E]) RemoveAll(element E) int <span class="cov8" title="1">{
        seg := ms.getSegment(element)
        seg.mu.Lock()
        defer seg.mu.Unlock()
        
        prevCount := seg.counts[element]
        if prevCount &gt; 0 </span><span class="cov8" title="1">{
                delete(seg.counts, element)
                atomic.AddInt64(&amp;ms.size, -int64(prevCount))
        }</span>
        <span class="cov8" title="1">return prevCount</span>
}

// Count returns the number of occurrences of the specified element
func (ms *ConcurrentHashMultiset[E]) Count(element E) int <span class="cov8" title="1">{
        seg := ms.getSegment(element)
        seg.mu.RLock()
        defer seg.mu.RUnlock()
        return seg.counts[element]
}</span>

// SetCount sets the count of the specified element to the given value
func (ms *ConcurrentHashMultiset[E]) SetCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        
        <span class="cov8" title="1">seg := ms.getSegment(element)
        seg.mu.Lock()
        defer seg.mu.Unlock()
        
        prevCount := seg.counts[element]
        
        if count == 0 </span><span class="cov8" title="1">{
                if prevCount &gt; 0 </span><span class="cov8" title="1">{
                        delete(seg.counts, element)
                        atomic.AddInt64(&amp;ms.size, -int64(prevCount))
                }</span>
        } else<span class="cov8" title="1"> {
                seg.counts[element] = count
                atomic.AddInt64(&amp;ms.size, int64(count-prevCount))
        }</span>
        
        <span class="cov8" title="1">return prevCount, nil</span>
}

// Contains checks if the multiset contains the specified element
func (ms *ConcurrentHashMultiset[E]) Contains(element E) bool <span class="cov8" title="1">{
        return ms.Count(element) &gt; 0
}</span>

// IsEmpty returns true if the multiset contains no elements
func (ms *ConcurrentHashMultiset[E]) IsEmpty() bool <span class="cov8" title="1">{
        return atomic.LoadInt64(&amp;ms.size) == 0
}</span>

// Size returns the number of distinct elements in the multiset
func (ms *ConcurrentHashMultiset[E]) Size() int <span class="cov8" title="1">{
        count := 0
        for _, seg := range ms.segments </span><span class="cov8" title="1">{
                seg.mu.RLock()
                count += len(seg.counts)
                seg.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">return count</span>
}

// TotalSize returns the total number of elements (including duplicates)
func (ms *ConcurrentHashMultiset[E]) TotalSize() int <span class="cov8" title="1">{
        return int(atomic.LoadInt64(&amp;ms.size))
}</span>

// DistinctElements returns the number of distinct elements
func (ms *ConcurrentHashMultiset[E]) DistinctElements() int <span class="cov0" title="0">{
        return ms.Size()
}</span>

// Clear removes all elements from the multiset
func (ms *ConcurrentHashMultiset[E]) Clear() <span class="cov8" title="1">{
        for _, seg := range ms.segments </span><span class="cov8" title="1">{
                seg.mu.Lock()
                seg.counts = make(map[E]int, defaultSegmentSize)
                seg.mu.Unlock()
        }</span>
        <span class="cov8" title="1">atomic.StoreInt64(&amp;ms.size, 0)</span>
}

// ElementSet returns a slice of distinct elements
func (ms *ConcurrentHashMultiset[E]) ElementSet() []E <span class="cov8" title="1">{
        var elements []E
        
        for _, seg := range ms.segments </span><span class="cov8" title="1">{
                seg.mu.RLock()
                for element := range seg.counts </span><span class="cov8" title="1">{
                        elements = append(elements, element)
                }</span>
                <span class="cov8" title="1">seg.mu.RUnlock()</span>
        }
        
        <span class="cov8" title="1">return elements</span>
}

// EntrySet returns a slice of entries (element-count pairs)
func (ms *ConcurrentHashMultiset[E]) EntrySet() []Entry[E] <span class="cov8" title="1">{
        var entries []Entry[E]
        
        for _, seg := range ms.segments </span><span class="cov8" title="1">{
                seg.mu.RLock()
                for element, count := range seg.counts </span><span class="cov8" title="1">{
                        entries = append(entries, Entry[E]{Element: element, Count: count})
                }</span>
                <span class="cov8" title="1">seg.mu.RUnlock()</span>
        }
        
        <span class="cov8" title="1">return entries</span>
}

// ToSlice returns a slice containing all elements (including duplicates)
func (ms *ConcurrentHashMultiset[E]) ToSlice() []E <span class="cov8" title="1">{
        var result []E
        
        for _, seg := range ms.segments </span><span class="cov8" title="1">{
                seg.mu.RLock()
                for element, count := range seg.counts </span><span class="cov8" title="1">{
                        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                                result = append(result, element)
                        }</span>
                }
                <span class="cov8" title="1">seg.mu.RUnlock()</span>
        }
        
        <span class="cov8" title="1">return result</span>
}

// Iterator returns an iterator over the multiset elements
func (ms *ConcurrentHashMultiset[E]) Iterator() common.Iterator[E] <span class="cov8" title="1">{
        return &amp;concurrentHashMultisetIterator[E]{
                multiset: ms,
                entries:  ms.EntrySet(),
                index:    0,
                current:  0,
        }
}</span>

// ForEach executes the given function for each element in the multiset
func (ms *ConcurrentHashMultiset[E]) ForEach(fn func(E)) <span class="cov8" title="1">{
        for _, entry := range ms.EntrySet() </span><span class="cov8" title="1">{
                for i := 0; i &lt; entry.Count; i++ </span><span class="cov8" title="1">{
                        fn(entry.Element)
                }</span>
        }
}

// Union returns a new multiset containing the union of this and another multiset
func (ms *ConcurrentHashMultiset[E]) Union(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        result := NewConcurrentHashMultiset[E]()
        
        // Add all elements from this multiset
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                result.AddCount(entry.Element, entry.Count)
        }</span>
        
        // Add elements from other multiset, taking maximum count
        <span class="cov0" title="0">for _, entry := range other.EntrySet() </span><span class="cov0" title="0">{
                currentCount := result.Count(entry.Element)
                if entry.Count &gt; currentCount </span><span class="cov0" title="0">{
                        result.SetCount(entry.Element, entry.Count)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

// Intersection returns a new multiset containing the intersection
func (ms *ConcurrentHashMultiset[E]) Intersection(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        result := NewConcurrentHashMultiset[E]()
        
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                otherCount := other.Count(entry.Element)
                if otherCount &gt; 0 </span><span class="cov0" title="0">{
                        minCount := entry.Count
                        if otherCount &lt; minCount </span><span class="cov0" title="0">{
                                minCount = otherCount
                        }</span>
                        <span class="cov0" title="0">result.AddCount(entry.Element, minCount)</span>
                }
        }
        
        <span class="cov0" title="0">return result</span>
}

// Difference returns a new multiset containing elements in this but not in other
func (ms *ConcurrentHashMultiset[E]) Difference(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        result := NewConcurrentHashMultiset[E]()
        
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                otherCount := other.Count(entry.Element)
                if entry.Count &gt; otherCount </span><span class="cov0" title="0">{
                        result.AddCount(entry.Element, entry.Count-otherCount)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

// IsSubsetOf checks if this multiset is a subset of another
func (ms *ConcurrentHashMultiset[E]) IsSubsetOf(other Multiset[E]) bool <span class="cov0" title="0">{
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                if other.Count(entry.Element) &lt; entry.Count </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// IsSupersetOf checks if this multiset is a superset of another
func (ms *ConcurrentHashMultiset[E]) IsSupersetOf(other Multiset[E]) bool <span class="cov0" title="0">{
        return other.IsSubsetOf(ms)
}</span>

// String returns a string representation of the multiset
func (ms *ConcurrentHashMultiset[E]) String() string <span class="cov0" title="0">{
        if ms.TotalSize() == 0 </span><span class="cov0" title="0">{
                return "ConcurrentHashMultiset[]"
        }</span>
        
        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("ConcurrentHashMultiset[")
        
        entries := ms.EntrySet()
        for i, entry := range entries </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">if entry.Count == 1 </span><span class="cov0" title="0">{
                        builder.WriteString(fmt.Sprintf("%v", entry.Element))
                }</span> else<span class="cov0" title="0"> {
                        builder.WriteString(fmt.Sprintf("%v x %d", entry.Element, entry.Count))
                }</span>
        }
        
        <span class="cov0" title="0">builder.WriteString("]")
        return builder.String()</span>
}

// concurrentHashMultisetIterator implements Iterator for ConcurrentHashMultiset
type concurrentHashMultisetIterator[E comparable] struct {
        multiset *ConcurrentHashMultiset[E]
        entries  []Entry[E]
        index    int
        current  int
}

func (it *concurrentHashMultisetIterator[E]) HasNext() bool <span class="cov8" title="1">{
        return it.index &lt; len(it.entries) &amp;&amp; (it.current &lt; it.entries[it.index].Count || it.index+1 &lt; len(it.entries))
}</span>

func (it *concurrentHashMultisetIterator[E]) Next() (E, bool) <span class="cov8" title="1">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                var zero E
                return zero, false
        }</span>
        
        <span class="cov8" title="1">if it.current &gt;= it.entries[it.index].Count </span><span class="cov8" title="1">{
                it.index++
                it.current = 0
        }</span>
        
        <span class="cov8" title="1">element := it.entries[it.index].Element
        it.current++
        return element, true</span>
}

func (it *concurrentHashMultisetIterator[E]) Reset() <span class="cov0" title="0">{
        it.entries = it.multiset.EntrySet()
        it.index = 0
        it.current = 0
}</span>

func (it *concurrentHashMultisetIterator[E]) Remove() bool <span class="cov0" title="0">{
        if it.index &gt;= len(it.entries) || it.current == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">element := it.entries[it.index].Element
        it.multiset.Remove(element)
        
        // Refresh entries after removal
        it.entries = it.multiset.EntrySet()
        if it.index &gt;= len(it.entries) </span><span class="cov0" title="0">{
                it.index = len(it.entries)
                it.current = 0
        }</span> else<span class="cov0" title="0"> if it.current &gt; it.entries[it.index].Count </span><span class="cov0" title="0">{
                it.current = it.entries[it.index].Count
        }</span>
        
        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">package multiset

import (
        "fmt"
        "strings"
        "sync"

        "github.com/chenjianyu/collections/container/common"
)

// HashMultiset is a multiset implementation based on a hash map
// It provides O(1) average time complexity for basic operations
type HashMultiset[E comparable] struct {
        counts map[E]int
        size   int
        mu     sync.RWMutex
}

// NewHashMultiset creates a new empty HashMultiset
func NewHashMultiset[E comparable]() *HashMultiset[E] <span class="cov8" title="1">{
        return &amp;HashMultiset[E]{
                counts: make(map[E]int),
                size:   0,
        }
}</span>

// NewHashMultisetFromSlice creates a new HashMultiset from a slice
func NewHashMultisetFromSlice[E comparable](elements []E) *HashMultiset[E] <span class="cov8" title="1">{
        ms := NewHashMultiset[E]()
        for _, element := range elements </span><span class="cov8" title="1">{
                ms.Add(element)
        }</span>
        <span class="cov8" title="1">return ms</span>
}

// Add adds one occurrence of the specified element
func (ms *HashMultiset[E]) Add(element E) int <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := ms.counts[element]
        ms.counts[element] = prevCount + 1
        ms.size++
        return prevCount
}</span>

// AddCount adds the specified number of occurrences of the element
func (ms *HashMultiset[E]) AddCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov8" title="1">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return ms.Count(element), nil
        }</span>
        
        <span class="cov8" title="1">ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := ms.counts[element]
        ms.counts[element] = prevCount + count
        ms.size += count
        return prevCount, nil</span>
}

// Remove removes one occurrence of the specified element
func (ms *HashMultiset[E]) Remove(element E) int <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := ms.counts[element]
        if prevCount &gt; 0 </span><span class="cov8" title="1">{
                if prevCount == 1 </span><span class="cov0" title="0">{
                        delete(ms.counts, element)
                }</span> else<span class="cov8" title="1"> {
                        ms.counts[element] = prevCount - 1
                }</span>
                <span class="cov8" title="1">ms.size--</span>
        }
        <span class="cov8" title="1">return prevCount</span>
}

// RemoveCount removes the specified number of occurrences of the element
func (ms *HashMultiset[E]) RemoveCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov8" title="1">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return ms.Count(element), nil
        }</span>
        
        <span class="cov8" title="1">ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := ms.counts[element]
        if prevCount &gt; 0 </span><span class="cov8" title="1">{
                removeCount := count
                if removeCount &gt; prevCount </span><span class="cov0" title="0">{
                        removeCount = prevCount
                }</span>
                
                <span class="cov8" title="1">newCount := prevCount - removeCount
                if newCount == 0 </span><span class="cov0" title="0">{
                        delete(ms.counts, element)
                }</span> else<span class="cov8" title="1"> {
                        ms.counts[element] = newCount
                }</span>
                <span class="cov8" title="1">ms.size -= removeCount</span>
        }
        <span class="cov8" title="1">return prevCount, nil</span>
}

// RemoveAll removes all occurrences of the specified element
func (ms *HashMultiset[E]) RemoveAll(element E) int <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := ms.counts[element]
        if prevCount &gt; 0 </span><span class="cov8" title="1">{
                delete(ms.counts, element)
                ms.size -= prevCount
        }</span>
        <span class="cov8" title="1">return prevCount</span>
}

// Count returns the number of occurrences of the specified element
func (ms *HashMultiset[E]) Count(element E) int <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return ms.counts[element]
}</span>

// SetCount sets the count of the specified element to the given value
func (ms *HashMultiset[E]) SetCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov8" title="1">{
                return 0, common.NegativeCountError(count)
        }</span>
        
        <span class="cov8" title="1">ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := ms.counts[element]
        
        if count == 0 </span><span class="cov8" title="1">{
                if prevCount &gt; 0 </span><span class="cov8" title="1">{
                        delete(ms.counts, element)
                        ms.size -= prevCount
                }</span>
        } else<span class="cov8" title="1"> {
                ms.counts[element] = count
                ms.size += count - prevCount
        }</span>
        
        <span class="cov8" title="1">return prevCount, nil</span>
}

// Contains checks if the multiset contains the specified element
func (ms *HashMultiset[E]) Contains(element E) bool <span class="cov8" title="1">{
        return ms.Count(element) &gt; 0
}</span>

// IsEmpty returns true if the multiset contains no elements
func (ms *HashMultiset[E]) IsEmpty() bool <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return ms.size == 0
}</span>

// Size returns the number of distinct elements in the multiset
func (ms *HashMultiset[E]) Size() int <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return len(ms.counts)
}</span>

// TotalSize returns the total number of elements (including duplicates)
func (ms *HashMultiset[E]) TotalSize() int <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return ms.size
}</span>

// DistinctElements returns the number of distinct elements
func (ms *HashMultiset[E]) DistinctElements() int <span class="cov0" title="0">{
        return ms.Size()
}</span>

// Clear removes all elements from the multiset
func (ms *HashMultiset[E]) Clear() <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        ms.counts = make(map[E]int)
        ms.size = 0
}</span>

// ElementSet returns a slice of distinct elements
func (ms *HashMultiset[E]) ElementSet() []E <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        elements := make([]E, 0, len(ms.counts))
        for element := range ms.counts </span><span class="cov8" title="1">{
                elements = append(elements, element)
        }</span>
        <span class="cov8" title="1">return elements</span>
}

// EntrySet returns a slice of entries (element-count pairs)
func (ms *HashMultiset[E]) EntrySet() []Entry[E] <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        entries := make([]Entry[E], 0, len(ms.counts))
        for element, count := range ms.counts </span><span class="cov8" title="1">{
                entries = append(entries, Entry[E]{Element: element, Count: count})
        }</span>
        <span class="cov8" title="1">return entries</span>
}

// ToSlice returns a slice containing all elements (including duplicates)
func (ms *HashMultiset[E]) ToSlice() []E <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        result := make([]E, 0, ms.size)
        for element, count := range ms.counts </span><span class="cov8" title="1">{
                for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                        result = append(result, element)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// Iterator returns an iterator over the multiset elements
func (ms *HashMultiset[E]) Iterator() common.Iterator[E] <span class="cov8" title="1">{
        return &amp;hashMultisetIterator[E]{
                multiset: ms,
                entries:  ms.EntrySet(),
                index:    0,
                current:  0,
        }
}</span>

// ForEach executes the given function for each element in the multiset
func (ms *HashMultiset[E]) ForEach(fn func(E)) <span class="cov8" title="1">{
        for _, entry := range ms.EntrySet() </span><span class="cov8" title="1">{
                for i := 0; i &lt; entry.Count; i++ </span><span class="cov8" title="1">{
                        fn(entry.Element)
                }</span>
        }
}

// Union returns a new multiset containing the union of this and another multiset
func (ms *HashMultiset[E]) Union(other Multiset[E]) Multiset[E] <span class="cov8" title="1">{
        result := NewHashMultiset[E]()
        
        // Add all elements from this multiset
        for _, entry := range ms.EntrySet() </span><span class="cov8" title="1">{
                result.AddCount(entry.Element, entry.Count)
        }</span>
        
        // Add elements from other multiset, taking maximum count
        <span class="cov8" title="1">for _, entry := range other.EntrySet() </span><span class="cov8" title="1">{
                currentCount := result.Count(entry.Element)
                if entry.Count &gt; currentCount </span><span class="cov8" title="1">{
                        result.SetCount(entry.Element, entry.Count)
                }</span>
        }
        
        <span class="cov8" title="1">return result</span>
}

// Intersection returns a new multiset containing the intersection
func (ms *HashMultiset[E]) Intersection(other Multiset[E]) Multiset[E] <span class="cov8" title="1">{
        result := NewHashMultiset[E]()
        
        for _, entry := range ms.EntrySet() </span><span class="cov8" title="1">{
                otherCount := other.Count(entry.Element)
                if otherCount &gt; 0 </span><span class="cov8" title="1">{
                        minCount := entry.Count
                        if otherCount &lt; minCount </span><span class="cov8" title="1">{
                                minCount = otherCount
                        }</span>
                        <span class="cov8" title="1">result.AddCount(entry.Element, minCount)</span>
                }
        }
        
        <span class="cov8" title="1">return result</span>
}

// Difference returns a new multiset containing elements in this but not in other
func (ms *HashMultiset[E]) Difference(other Multiset[E]) Multiset[E] <span class="cov8" title="1">{
        result := NewHashMultiset[E]()
        
        for _, entry := range ms.EntrySet() </span><span class="cov8" title="1">{
                otherCount := other.Count(entry.Element)
                if entry.Count &gt; otherCount </span><span class="cov8" title="1">{
                        result.AddCount(entry.Element, entry.Count-otherCount)
                }</span>
        }
        
        <span class="cov8" title="1">return result</span>
}

// IsSubsetOf checks if this multiset is a subset of another
func (ms *HashMultiset[E]) IsSubsetOf(other Multiset[E]) bool <span class="cov8" title="1">{
        for _, entry := range ms.EntrySet() </span><span class="cov8" title="1">{
                if other.Count(entry.Element) &lt; entry.Count </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsSupersetOf checks if this multiset is a superset of another
func (ms *HashMultiset[E]) IsSupersetOf(other Multiset[E]) bool <span class="cov8" title="1">{
        return other.IsSubsetOf(ms)
}</span>

// String returns a string representation of the multiset
func (ms *HashMultiset[E]) String() string <span class="cov0" title="0">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        if ms.size == 0 </span><span class="cov0" title="0">{
                return "HashMultiset[]"
        }</span>
        
        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("HashMultiset[")
        
        first := true
        for element, count := range ms.counts </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">if count == 1 </span><span class="cov0" title="0">{
                        builder.WriteString(fmt.Sprintf("%v", element))
                }</span> else<span class="cov0" title="0"> {
                        builder.WriteString(fmt.Sprintf("%v x %d", element, count))
                }</span>
                <span class="cov0" title="0">first = false</span>
        }
        
        <span class="cov0" title="0">builder.WriteString("]")
        return builder.String()</span>
}

// hashMultisetIterator implements Iterator for HashMultiset
type hashMultisetIterator[E comparable] struct {
        multiset *HashMultiset[E]
        entries  []Entry[E]
        index    int
        current  int
}

func (it *hashMultisetIterator[E]) HasNext() bool <span class="cov8" title="1">{
        return it.index &lt; len(it.entries) &amp;&amp; (it.current &lt; it.entries[it.index].Count || it.index+1 &lt; len(it.entries))
}</span>

func (it *hashMultisetIterator[E]) Next() (E, bool) <span class="cov8" title="1">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                var zero E
                return zero, false
        }</span>
        
        <span class="cov8" title="1">if it.current &gt;= it.entries[it.index].Count </span><span class="cov8" title="1">{
                it.index++
                it.current = 0
        }</span>
        
        <span class="cov8" title="1">element := it.entries[it.index].Element
        it.current++
        return element, true</span>
}

func (it *hashMultisetIterator[E]) Reset() <span class="cov0" title="0">{
        it.entries = it.multiset.EntrySet()
        it.index = 0
        it.current = 0
}</span>

func (it *hashMultisetIterator[E]) Remove() bool <span class="cov0" title="0">{
        if it.index &gt;= len(it.entries) || it.current == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">element := it.entries[it.index].Element
        it.multiset.Remove(element)
        
        // Refresh entries after removal
        it.entries = it.multiset.EntrySet()
        if it.index &gt;= len(it.entries) </span><span class="cov0" title="0">{
                it.index = len(it.entries)
                it.current = 0
        }</span> else<span class="cov0" title="0"> if it.current &gt; it.entries[it.index].Count </span><span class="cov0" title="0">{
                it.current = it.entries[it.index].Count
        }</span>
        
        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package multiset

import (
        "fmt"
        "strings"

        "github.com/chenjianyu/collections/container/common"
)

// ImmutableMultiset is an immutable multiset implementation
// Once created, it cannot be modified. All modification operations return new instances
type ImmutableMultiset[E comparable] struct {
        counts map[E]int
        size   int
}

// NewImmutableMultiset creates a new empty ImmutableMultiset
func NewImmutableMultiset[E comparable]() *ImmutableMultiset[E] <span class="cov8" title="1">{
        return &amp;ImmutableMultiset[E]{
                counts: make(map[E]int),
                size:   0,
        }
}</span>

// NewImmutableMultisetFromSlice creates a new ImmutableMultiset from a slice
func NewImmutableMultisetFromSlice[E comparable](elements []E) *ImmutableMultiset[E] <span class="cov8" title="1">{
        counts := make(map[E]int)
        size := 0
        
        for _, element := range elements </span><span class="cov8" title="1">{
                counts[element]++
                size++
        }</span>
        
        <span class="cov8" title="1">return &amp;ImmutableMultiset[E]{
                counts: counts,
                size:   size,
        }</span>
}

// NewImmutableMultisetFromEntries creates a new ImmutableMultiset from entries
func NewImmutableMultisetFromEntries[E comparable](entries []Entry[E]) *ImmutableMultiset[E] <span class="cov0" title="0">{
        counts := make(map[E]int)
        size := 0
        
        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.Count &gt; 0 </span><span class="cov0" title="0">{
                        counts[entry.Element] = entry.Count
                        size += entry.Count
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;ImmutableMultiset[E]{
                counts: counts,
                size:   size,
        }</span>
}

// copyMap creates a deep copy of the counts map
func (ms *ImmutableMultiset[E]) copyMap() map[E]int <span class="cov8" title="1">{
        newCounts := make(map[E]int, len(ms.counts))
        for k, v := range ms.counts </span><span class="cov8" title="1">{
                newCounts[k] = v
        }</span>
        <span class="cov8" title="1">return newCounts</span>
}

// Add returns a new ImmutableMultiset with one occurrence of the element added
func (ms *ImmutableMultiset[E]) Add(element E) int <span class="cov0" title="0">{
        newCounts := ms.copyMap()
        prevCount := newCounts[element]
        newCounts[element] = prevCount + 1
        
        // Note: This violates the interface contract but is needed for immutability
        // The returned int is the previous count, but we can't modify this instance
        return prevCount
}</span>

// AddCount returns a new ImmutableMultiset with the specified count of elements added
func (ms *ImmutableMultiset[E]) AddCount(element E, count int) (int, error) <span class="cov0" title="0">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return ms.Count(element), nil
        }</span>
        
        <span class="cov0" title="0">newCounts := ms.copyMap()
        prevCount := newCounts[element]
        newCounts[element] = prevCount + count
        
        return prevCount, nil</span>
}

// WithAdd returns a new ImmutableMultiset with one occurrence of the element added
func (ms *ImmutableMultiset[E]) WithAdd(element E) *ImmutableMultiset[E] <span class="cov8" title="1">{
        newCounts := ms.copyMap()
        newCounts[element]++
        
        return &amp;ImmutableMultiset[E]{
                counts: newCounts,
                size:   ms.size + 1,
        }
}</span>

// WithAddCount returns a new ImmutableMultiset with the specified count of elements added
func (ms *ImmutableMultiset[E]) WithAddCount(element E, count int) (*ImmutableMultiset[E], error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return nil, common.NegativeCountError(count)
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return ms, nil
        }</span>
        
        <span class="cov8" title="1">newCounts := ms.copyMap()
        newCounts[element] += count
        
        return &amp;ImmutableMultiset[E]{
                counts: newCounts,
                size:   ms.size + count,
        }, nil</span>
}

// Remove returns the previous count (but doesn't actually modify this immutable instance)
func (ms *ImmutableMultiset[E]) Remove(element E) int <span class="cov0" title="0">{
        return ms.counts[element]
}</span>

// RemoveCount returns the previous count (but doesn't actually modify this immutable instance)
func (ms *ImmutableMultiset[E]) RemoveCount(element E, count int) (int, error) <span class="cov0" title="0">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov0" title="0">return ms.counts[element], nil</span>
}

// RemoveAll returns the previous count (but doesn't actually modify this immutable instance)
func (ms *ImmutableMultiset[E]) RemoveAll(element E) int <span class="cov0" title="0">{
        return ms.counts[element]
}</span>

// WithRemove returns a new ImmutableMultiset with one occurrence of the element removed
func (ms *ImmutableMultiset[E]) WithRemove(element E) *ImmutableMultiset[E] <span class="cov0" title="0">{
        currentCount := ms.counts[element]
        if currentCount == 0 </span><span class="cov0" title="0">{
                return ms
        }</span>
        
        <span class="cov0" title="0">newCounts := ms.copyMap()
        if currentCount == 1 </span><span class="cov0" title="0">{
                delete(newCounts, element)
        }</span> else<span class="cov0" title="0"> {
                newCounts[element] = currentCount - 1
        }</span>
        
        <span class="cov0" title="0">return &amp;ImmutableMultiset[E]{
                counts: newCounts,
                size:   ms.size - 1,
        }</span>
}

// WithRemoveCount returns a new ImmutableMultiset with the specified count of elements removed
func (ms *ImmutableMultiset[E]) WithRemoveCount(element E, count int) (*ImmutableMultiset[E], error) <span class="cov0" title="0">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return nil, common.NegativeCountError(count)
        }</span>
        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return ms, nil
        }</span>
        
        <span class="cov0" title="0">currentCount := ms.counts[element]
        if currentCount == 0 </span><span class="cov0" title="0">{
                return ms, nil
        }</span>
        
        <span class="cov0" title="0">removeCount := count
        if removeCount &gt; currentCount </span><span class="cov0" title="0">{
                removeCount = currentCount
        }</span>
        
        <span class="cov0" title="0">newCounts := ms.copyMap()
        newCount := currentCount - removeCount
        if newCount == 0 </span><span class="cov0" title="0">{
                delete(newCounts, element)
        }</span> else<span class="cov0" title="0"> {
                newCounts[element] = newCount
        }</span>
        
        <span class="cov0" title="0">return &amp;ImmutableMultiset[E]{
                counts: newCounts,
                size:   ms.size - removeCount,
        }, nil</span>
}

// WithRemoveAll returns a new ImmutableMultiset with all occurrences of the element removed
func (ms *ImmutableMultiset[E]) WithRemoveAll(element E) *ImmutableMultiset[E] <span class="cov0" title="0">{
        currentCount := ms.counts[element]
        if currentCount == 0 </span><span class="cov0" title="0">{
                return ms
        }</span>
        
        <span class="cov0" title="0">newCounts := ms.copyMap()
        delete(newCounts, element)
        
        return &amp;ImmutableMultiset[E]{
                counts: newCounts,
                size:   ms.size - currentCount,
        }</span>
}

// Count returns the number of occurrences of the specified element
func (ms *ImmutableMultiset[E]) Count(element E) int <span class="cov8" title="1">{
        return ms.counts[element]
}</span>

// SetCount returns the previous count (but doesn't actually modify this immutable instance)
func (ms *ImmutableMultiset[E]) SetCount(element E, count int) (int, error) <span class="cov0" title="0">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov0" title="0">return ms.counts[element], nil</span>
}

// WithSetCount returns a new ImmutableMultiset with the element count set to the specified value
func (ms *ImmutableMultiset[E]) WithSetCount(element E, count int) (*ImmutableMultiset[E], error) <span class="cov0" title="0">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return nil, common.NegativeCountError(count)
        }</span>
        
        <span class="cov0" title="0">currentCount := ms.counts[element]
        if currentCount == count </span><span class="cov0" title="0">{
                return ms, nil
        }</span>
        
        <span class="cov0" title="0">newCounts := ms.copyMap()
        sizeDiff := count - currentCount
        
        if count == 0 </span><span class="cov0" title="0">{
                delete(newCounts, element)
        }</span> else<span class="cov0" title="0"> {
                newCounts[element] = count
        }</span>
        
        <span class="cov0" title="0">return &amp;ImmutableMultiset[E]{
                counts: newCounts,
                size:   ms.size + sizeDiff,
        }, nil</span>
}

// Contains checks if the multiset contains the specified element
func (ms *ImmutableMultiset[E]) Contains(element E) bool <span class="cov8" title="1">{
        return ms.counts[element] &gt; 0
}</span>

// IsEmpty returns true if the multiset contains no elements
func (ms *ImmutableMultiset[E]) IsEmpty() bool <span class="cov8" title="1">{
        return ms.size == 0
}</span>

// Size returns the number of distinct elements in the multiset
func (ms *ImmutableMultiset[E]) Size() int <span class="cov0" title="0">{
        return len(ms.counts)
}</span>

// TotalSize returns the total number of elements (including duplicates)
func (ms *ImmutableMultiset[E]) TotalSize() int <span class="cov8" title="1">{
        return ms.size
}</span>

// DistinctElements returns the number of distinct elements
func (ms *ImmutableMultiset[E]) DistinctElements() int <span class="cov0" title="0">{
        return len(ms.counts)
}</span>

// Clear returns an empty ImmutableMultiset
func (ms *ImmutableMultiset[E]) Clear() {<span class="cov0" title="0">
        // This violates the interface but is needed for immutability
        // Use WithClear() instead for proper immutable behavior
}</span>

// WithClear returns a new empty ImmutableMultiset
func (ms *ImmutableMultiset[E]) WithClear() *ImmutableMultiset[E] <span class="cov0" title="0">{
        return NewImmutableMultiset[E]()
}</span>

// ElementSet returns a slice of distinct elements
func (ms *ImmutableMultiset[E]) ElementSet() []E <span class="cov0" title="0">{
        elements := make([]E, 0, len(ms.counts))
        for element := range ms.counts </span><span class="cov0" title="0">{
                elements = append(elements, element)
        }</span>
        <span class="cov0" title="0">return elements</span>
}

// EntrySet returns a slice of entries (element-count pairs)
func (ms *ImmutableMultiset[E]) EntrySet() []Entry[E] <span class="cov0" title="0">{
        entries := make([]Entry[E], 0, len(ms.counts))
        for element, count := range ms.counts </span><span class="cov0" title="0">{
                entries = append(entries, Entry[E]{Element: element, Count: count})
        }</span>
        <span class="cov0" title="0">return entries</span>
}

// ToSlice returns a slice containing all elements (including duplicates)
func (ms *ImmutableMultiset[E]) ToSlice() []E <span class="cov0" title="0">{
        result := make([]E, 0, ms.size)
        for element, count := range ms.counts </span><span class="cov0" title="0">{
                for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                        result = append(result, element)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

// Iterator returns an iterator over the multiset elements
func (ms *ImmutableMultiset[E]) Iterator() common.Iterator[E] <span class="cov0" title="0">{
        return &amp;immutableMultisetIterator[E]{
                multiset: ms,
                entries:  ms.EntrySet(),
                index:    0,
                current:  0,
        }
}</span>

// ForEach executes the given function for each element in the multiset
func (ms *ImmutableMultiset[E]) ForEach(fn func(E)) <span class="cov0" title="0">{
        for element, count := range ms.counts </span><span class="cov0" title="0">{
                for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                        fn(element)
                }</span>
        }
}

// Union returns a new multiset containing the union of this and another multiset
func (ms *ImmutableMultiset[E]) Union(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        newCounts := ms.copyMap()
        newSize := ms.size
        
        // Add elements from other multiset, taking maximum count
        for _, entry := range other.EntrySet() </span><span class="cov0" title="0">{
                currentCount := newCounts[entry.Element]
                if entry.Count &gt; currentCount </span><span class="cov0" title="0">{
                        newSize += entry.Count - currentCount
                        newCounts[entry.Element] = entry.Count
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;ImmutableMultiset[E]{
                counts: newCounts,
                size:   newSize,
        }</span>
}

// Intersection returns a new multiset containing the intersection
func (ms *ImmutableMultiset[E]) Intersection(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        newCounts := make(map[E]int)
        newSize := 0
        
        for element, count := range ms.counts </span><span class="cov0" title="0">{
                otherCount := other.Count(element)
                if otherCount &gt; 0 </span><span class="cov0" title="0">{
                        minCount := count
                        if otherCount &lt; minCount </span><span class="cov0" title="0">{
                                minCount = otherCount
                        }</span>
                        <span class="cov0" title="0">newCounts[element] = minCount
                        newSize += minCount</span>
                }
        }
        
        <span class="cov0" title="0">return &amp;ImmutableMultiset[E]{
                counts: newCounts,
                size:   newSize,
        }</span>
}

// Difference returns a new multiset containing elements in this but not in other
func (ms *ImmutableMultiset[E]) Difference(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        newCounts := make(map[E]int)
        newSize := 0
        
        for element, count := range ms.counts </span><span class="cov0" title="0">{
                otherCount := other.Count(element)
                if count &gt; otherCount </span><span class="cov0" title="0">{
                        diffCount := count - otherCount
                        newCounts[element] = diffCount
                        newSize += diffCount
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;ImmutableMultiset[E]{
                counts: newCounts,
                size:   newSize,
        }</span>
}

// IsSubsetOf checks if this multiset is a subset of another
func (ms *ImmutableMultiset[E]) IsSubsetOf(other Multiset[E]) bool <span class="cov0" title="0">{
        for element, count := range ms.counts </span><span class="cov0" title="0">{
                if other.Count(element) &lt; count </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// IsSupersetOf checks if this multiset is a superset of another
func (ms *ImmutableMultiset[E]) IsSupersetOf(other Multiset[E]) bool <span class="cov0" title="0">{
        return other.IsSubsetOf(ms)
}</span>

// String returns a string representation of the multiset
func (ms *ImmutableMultiset[E]) String() string <span class="cov0" title="0">{
        if ms.size == 0 </span><span class="cov0" title="0">{
                return "ImmutableMultiset[]"
        }</span>
        
        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("ImmutableMultiset[")
        
        first := true
        for element, count := range ms.counts </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">if count == 1 </span><span class="cov0" title="0">{
                        builder.WriteString(fmt.Sprintf("%v", element))
                }</span> else<span class="cov0" title="0"> {
                        builder.WriteString(fmt.Sprintf("%v x %d", element, count))
                }</span>
                <span class="cov0" title="0">first = false</span>
        }
        
        <span class="cov0" title="0">builder.WriteString("]")
        return builder.String()</span>
}

// immutableMultisetIterator implements Iterator for ImmutableMultiset
type immutableMultisetIterator[E comparable] struct {
        multiset *ImmutableMultiset[E]
        entries  []Entry[E]
        index    int
        current  int
}

func (it *immutableMultisetIterator[E]) HasNext() bool <span class="cov0" title="0">{
        return it.index &lt; len(it.entries) &amp;&amp; (it.current &lt; it.entries[it.index].Count || it.index+1 &lt; len(it.entries))
}</span>

func (it *immutableMultisetIterator[E]) Next() (E, bool) <span class="cov0" title="0">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                var zero E
                return zero, false
        }</span>
        
        <span class="cov0" title="0">if it.current &gt;= it.entries[it.index].Count </span><span class="cov0" title="0">{
                it.index++
                it.current = 0
        }</span>
        
        <span class="cov0" title="0">element := it.entries[it.index].Element
        it.current++
        return element, true</span>
}

func (it *immutableMultisetIterator[E]) Reset() <span class="cov0" title="0">{
        it.entries = it.multiset.EntrySet()
        it.index = 0
        it.current = 0
}</span>

func (it *immutableMultisetIterator[E]) Remove() bool <span class="cov0" title="0">{
        // Remove operation is not supported for immutable collections
        return false
}</pre>
		
		<pre class="file" id="file19" style="display: none">package multiset

import (
        "fmt"
        "strings"
        "sync"

        "github.com/chenjianyu/collections/container/common"
)

// LinkedHashMultiset is a multiset implementation that maintains insertion order
// It combines a hash map for O(1) operations with a doubly-linked list for order preservation
type LinkedHashMultiset[E comparable] struct {
        counts map[E]*linkedEntry[E]
        head   *linkedEntry[E]
        tail   *linkedEntry[E]
        size   int
        mu     sync.RWMutex
}

type linkedEntry[E comparable] struct {
        element E
        count   int
        prev    *linkedEntry[E]
        next    *linkedEntry[E]
}

// NewLinkedHashMultiset creates a new empty LinkedHashMultiset
func NewLinkedHashMultiset[E comparable]() *LinkedHashMultiset[E] <span class="cov8" title="1">{
        ms := &amp;LinkedHashMultiset[E]{
                counts: make(map[E]*linkedEntry[E]),
        }
        // Create sentinel nodes
        ms.head = &amp;linkedEntry[E]{}
        ms.tail = &amp;linkedEntry[E]{}
        ms.head.next = ms.tail
        ms.tail.prev = ms.head
        return ms
}</span>

// NewLinkedHashMultisetFromSlice creates a new LinkedHashMultiset from a slice
func NewLinkedHashMultisetFromSlice[E comparable](elements []E) *LinkedHashMultiset[E] <span class="cov0" title="0">{
        ms := NewLinkedHashMultiset[E]()
        for _, element := range elements </span><span class="cov0" title="0">{
                ms.Add(element)
        }</span>
        <span class="cov0" title="0">return ms</span>
}

// Add adds one occurrence of the specified element
func (ms *LinkedHashMultiset[E]) Add(element E) int <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        if entry, exists := ms.counts[element]; exists </span><span class="cov8" title="1">{
                prevCount := entry.count
                entry.count++
                ms.size++
                return prevCount
        }</span>
        
        // Create new entry and add to end of list
        <span class="cov8" title="1">entry := &amp;linkedEntry[E]{
                element: element,
                count:   1,
        }
        ms.counts[element] = entry
        ms.addToTail(entry)
        ms.size++
        return 0</span>
}

// AddCount adds the specified number of occurrences of the element
func (ms *LinkedHashMultiset[E]) AddCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return ms.Count(element), nil
        }</span>
        
        <span class="cov8" title="1">ms.mu.Lock()
        defer ms.mu.Unlock()
        
        if entry, exists := ms.counts[element]; exists </span><span class="cov0" title="0">{
                prevCount := entry.count
                entry.count += count
                ms.size += count
                return prevCount, nil
        }</span>
        
        // Create new entry and add to end of list
        <span class="cov8" title="1">entry := &amp;linkedEntry[E]{
                element: element,
                count:   count,
        }
        ms.counts[element] = entry
        ms.addToTail(entry)
        ms.size += count
        return 0, nil</span>
}

// Remove removes one occurrence of the specified element
func (ms *LinkedHashMultiset[E]) Remove(element E) int <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        entry, exists := ms.counts[element]
        if !exists </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov8" title="1">prevCount := entry.count
        entry.count--
        ms.size--
        
        if entry.count == 0 </span><span class="cov0" title="0">{
                ms.removeFromList(entry)
                delete(ms.counts, element)
        }</span>
        
        <span class="cov8" title="1">return prevCount</span>
}

// RemoveCount removes the specified number of occurrences of the element
func (ms *LinkedHashMultiset[E]) RemoveCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return ms.Count(element), nil
        }</span>
        
        <span class="cov8" title="1">ms.mu.Lock()
        defer ms.mu.Unlock()
        
        entry, exists := ms.counts[element]
        if !exists </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        
        <span class="cov8" title="1">prevCount := entry.count
        removeCount := count
        if removeCount &gt; prevCount </span><span class="cov0" title="0">{
                removeCount = prevCount
        }</span>
        
        <span class="cov8" title="1">entry.count -= removeCount
        ms.size -= removeCount
        
        if entry.count == 0 </span><span class="cov0" title="0">{
                ms.removeFromList(entry)
                delete(ms.counts, element)
        }</span>
        
        <span class="cov8" title="1">return prevCount, nil</span>
}

// RemoveAll removes all occurrences of the specified element
func (ms *LinkedHashMultiset[E]) RemoveAll(element E) int <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        entry, exists := ms.counts[element]
        if !exists </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov8" title="1">prevCount := entry.count
        ms.size -= prevCount
        ms.removeFromList(entry)
        delete(ms.counts, element)
        
        return prevCount</span>
}

// Count returns the number of occurrences of the specified element
func (ms *LinkedHashMultiset[E]) Count(element E) int <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        if entry, exists := ms.counts[element]; exists </span><span class="cov8" title="1">{
                return entry.count
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// SetCount sets the count of the specified element to the given value
func (ms *LinkedHashMultiset[E]) SetCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        
        <span class="cov8" title="1">ms.mu.Lock()
        defer ms.mu.Unlock()
        
        entry, exists := ms.counts[element]
        var prevCount int
        
        if exists </span><span class="cov8" title="1">{
                prevCount = entry.count
                if count == 0 </span><span class="cov8" title="1">{
                        ms.size -= prevCount
                        ms.removeFromList(entry)
                        delete(ms.counts, element)
                }</span> else<span class="cov0" title="0"> {
                        ms.size += count - prevCount
                        entry.count = count
                }</span>
        } else<span class="cov8" title="1"> {
                prevCount = 0
                if count &gt; 0 </span><span class="cov8" title="1">{
                        newEntry := &amp;linkedEntry[E]{
                                element: element,
                                count:   count,
                        }
                        ms.counts[element] = newEntry
                        ms.addToTail(newEntry)
                        ms.size += count
                }</span>
        }
        
        <span class="cov8" title="1">return prevCount, nil</span>
}

// Contains checks if the multiset contains the specified element
func (ms *LinkedHashMultiset[E]) Contains(element E) bool <span class="cov8" title="1">{
        return ms.Count(element) &gt; 0
}</span>

// IsEmpty returns true if the multiset contains no elements
func (ms *LinkedHashMultiset[E]) IsEmpty() bool <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return ms.size == 0
}</span>

// Size returns the number of distinct elements in the multiset
func (ms *LinkedHashMultiset[E]) Size() int <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return len(ms.counts)
}</span>

// TotalSize returns the total number of elements (including duplicates)
func (ms *LinkedHashMultiset[E]) TotalSize() int <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return ms.size
}</span>

// DistinctElements returns the number of distinct elements
func (ms *LinkedHashMultiset[E]) DistinctElements() int <span class="cov0" title="0">{
        return ms.Size()
}</span>

// Clear removes all elements from the multiset
func (ms *LinkedHashMultiset[E]) Clear() <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        ms.counts = make(map[E]*linkedEntry[E])
        ms.head.next = ms.tail
        ms.tail.prev = ms.head
        ms.size = 0
}</span>

// ElementSet returns a slice of distinct elements in insertion order
func (ms *LinkedHashMultiset[E]) ElementSet() []E <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        elements := make([]E, 0, len(ms.counts))
        current := ms.head.next
        for current != ms.tail </span><span class="cov8" title="1">{
                elements = append(elements, current.element)
                current = current.next
        }</span>
        <span class="cov8" title="1">return elements</span>
}

// EntrySet returns a slice of entries (element-count pairs) in insertion order
func (ms *LinkedHashMultiset[E]) EntrySet() []Entry[E] <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        entries := make([]Entry[E], 0, len(ms.counts))
        current := ms.head.next
        for current != ms.tail </span><span class="cov8" title="1">{
                entries = append(entries, Entry[E]{Element: current.element, Count: current.count})
                current = current.next
        }</span>
        <span class="cov8" title="1">return entries</span>
}

// ToSlice returns a slice containing all elements (including duplicates) in insertion order
func (ms *LinkedHashMultiset[E]) ToSlice() []E <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        result := make([]E, 0, ms.size)
        current := ms.head.next
        for current != ms.tail </span><span class="cov8" title="1">{
                for i := 0; i &lt; current.count; i++ </span><span class="cov8" title="1">{
                        result = append(result, current.element)
                }</span>
                <span class="cov8" title="1">current = current.next</span>
        }
        <span class="cov8" title="1">return result</span>
}

// Iterator returns an iterator over the multiset elements in insertion order
func (ms *LinkedHashMultiset[E]) Iterator() common.Iterator[E] <span class="cov8" title="1">{
        return &amp;linkedHashMultisetIterator[E]{
                multiset: ms,
                entries:  ms.EntrySet(),
                index:    0,
                current:  0,
        }
}</span>

// ForEach executes the given function for each element in the multiset in insertion order
func (ms *LinkedHashMultiset[E]) ForEach(fn func(E)) <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        current := ms.head.next
        for current != ms.tail </span><span class="cov8" title="1">{
                for i := 0; i &lt; current.count; i++ </span><span class="cov8" title="1">{
                        fn(current.element)
                }</span>
                <span class="cov8" title="1">current = current.next</span>
        }
}

// Union returns a new multiset containing the union of this and another multiset
func (ms *LinkedHashMultiset[E]) Union(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        result := NewLinkedHashMultiset[E]()
        
        // Add all elements from this multiset (preserving order)
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                result.AddCount(entry.Element, entry.Count)
        }</span>
        
        // Add elements from other multiset, taking maximum count
        <span class="cov0" title="0">for _, entry := range other.EntrySet() </span><span class="cov0" title="0">{
                currentCount := result.Count(entry.Element)
                if entry.Count &gt; currentCount </span><span class="cov0" title="0">{
                        result.SetCount(entry.Element, entry.Count)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

// Intersection returns a new multiset containing the intersection
func (ms *LinkedHashMultiset[E]) Intersection(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        result := NewLinkedHashMultiset[E]()
        
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                otherCount := other.Count(entry.Element)
                if otherCount &gt; 0 </span><span class="cov0" title="0">{
                        minCount := entry.Count
                        if otherCount &lt; minCount </span><span class="cov0" title="0">{
                                minCount = otherCount
                        }</span>
                        <span class="cov0" title="0">result.AddCount(entry.Element, minCount)</span>
                }
        }
        
        <span class="cov0" title="0">return result</span>
}

// Difference returns a new multiset containing elements in this but not in other
func (ms *LinkedHashMultiset[E]) Difference(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        result := NewLinkedHashMultiset[E]()
        
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                otherCount := other.Count(entry.Element)
                if entry.Count &gt; otherCount </span><span class="cov0" title="0">{
                        result.AddCount(entry.Element, entry.Count-otherCount)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

// IsSubsetOf checks if this multiset is a subset of another
func (ms *LinkedHashMultiset[E]) IsSubsetOf(other Multiset[E]) bool <span class="cov0" title="0">{
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                if other.Count(entry.Element) &lt; entry.Count </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// IsSupersetOf checks if this multiset is a superset of another
func (ms *LinkedHashMultiset[E]) IsSupersetOf(other Multiset[E]) bool <span class="cov0" title="0">{
        return other.IsSubsetOf(ms)
}</span>

// String returns a string representation of the multiset
func (ms *LinkedHashMultiset[E]) String() string <span class="cov0" title="0">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        if ms.size == 0 </span><span class="cov0" title="0">{
                return "LinkedHashMultiset[]"
        }</span>
        
        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("LinkedHashMultiset[")
        
        first := true
        current := ms.head.next
        for current != ms.tail </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">if current.count == 1 </span><span class="cov0" title="0">{
                        builder.WriteString(fmt.Sprintf("%v", current.element))
                }</span> else<span class="cov0" title="0"> {
                        builder.WriteString(fmt.Sprintf("%v x %d", current.element, current.count))
                }</span>
                <span class="cov0" title="0">first = false
                current = current.next</span>
        }
        
        <span class="cov0" title="0">builder.WriteString("]")
        return builder.String()</span>
}

// Helper methods for doubly-linked list operations
func (ms *LinkedHashMultiset[E]) addToTail(entry *linkedEntry[E]) <span class="cov8" title="1">{
        prev := ms.tail.prev
        prev.next = entry
        entry.prev = prev
        entry.next = ms.tail
        ms.tail.prev = entry
}</span>

func (ms *LinkedHashMultiset[E]) removeFromList(entry *linkedEntry[E]) <span class="cov8" title="1">{
        entry.prev.next = entry.next
        entry.next.prev = entry.prev
}</span>

// linkedHashMultisetIterator implements Iterator for LinkedHashMultiset
type linkedHashMultisetIterator[E comparable] struct {
        multiset *LinkedHashMultiset[E]
        entries  []Entry[E]
        index    int
        current  int
}

func (it *linkedHashMultisetIterator[E]) HasNext() bool <span class="cov8" title="1">{
        return it.index &lt; len(it.entries) &amp;&amp; (it.current &lt; it.entries[it.index].Count || it.index+1 &lt; len(it.entries))
}</span>

func (it *linkedHashMultisetIterator[E]) Next() (E, bool) <span class="cov8" title="1">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                var zero E
                return zero, false
        }</span>
        
        <span class="cov8" title="1">if it.current &gt;= it.entries[it.index].Count </span><span class="cov8" title="1">{
                it.index++
                it.current = 0
        }</span>
        
        <span class="cov8" title="1">element := it.entries[it.index].Element
        it.current++
        return element, true</span>
}

func (it *linkedHashMultisetIterator[E]) Reset() <span class="cov0" title="0">{
        it.entries = it.multiset.EntrySet()
        it.index = 0
        it.current = 0
}</span>

func (it *linkedHashMultisetIterator[E]) Remove() bool <span class="cov0" title="0">{
        if it.index &gt;= len(it.entries) || it.current == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">element := it.entries[it.index].Element
        it.multiset.Remove(element)
        
        // Refresh entries after removal
        it.entries = it.multiset.EntrySet()
        if it.index &gt;= len(it.entries) </span><span class="cov0" title="0">{
                it.index = len(it.entries)
                it.current = 0
        }</span> else<span class="cov0" title="0"> if it.current &gt; it.entries[it.index].Count </span><span class="cov0" title="0">{
                it.current = it.entries[it.index].Count
        }</span>
        
        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">package multiset

import (
        "fmt"
        "strings"
        "sync"

        "github.com/chenjianyu/collections/container/common"
)

// TreeMultiset is a multiset implementation based on a balanced binary search tree
// It maintains elements in sorted order and provides O(log n) time complexity for basic operations
type TreeMultiset[E comparable] struct {
        root *treeNode[E]
        size int
        mu   sync.RWMutex
        cmp  func(E, E) int
}

type treeNode[E comparable] struct {
        element E
        count   int
        left    *treeNode[E]
        right   *treeNode[E]
        height  int
}

// NewTreeMultiset creates a new empty TreeMultiset with default comparison
func NewTreeMultiset[E comparable]() *TreeMultiset[E] <span class="cov8" title="1">{
        return &amp;TreeMultiset[E]{
                cmp: defaultCompare[E],
        }
}</span>

// NewTreeMultisetWithComparator creates a new TreeMultiset with custom comparator
func NewTreeMultisetWithComparator[E comparable](cmp func(E, E) int) *TreeMultiset[E] <span class="cov0" title="0">{
        return &amp;TreeMultiset[E]{
                cmp: cmp,
        }
}</span>

// NewTreeMultisetFromSlice creates a new TreeMultiset from a slice
func NewTreeMultisetFromSlice[E comparable](elements []E) *TreeMultiset[E] <span class="cov0" title="0">{
        ms := NewTreeMultiset[E]()
        for _, element := range elements </span><span class="cov0" title="0">{
                ms.Add(element)
        }</span>
        <span class="cov0" title="0">return ms</span>
}

// defaultCompare provides default comparison for comparable types
func defaultCompare[E comparable](a, b E) int <span class="cov8" title="1">{
        if any(a) == any(b) </span><span class="cov8" title="1">{
                return 0
        }</span>
        // For string comparison
        <span class="cov8" title="1">if sa, ok := any(a).(string); ok </span><span class="cov8" title="1">{
                if sb, ok := any(b).(string); ok </span><span class="cov8" title="1">{
                        if sa &lt; sb </span><span class="cov8" title="1">{
                                return -1
                        }</span> else<span class="cov8" title="1"> if sa &gt; sb </span><span class="cov8" title="1">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        }
        // For numeric types, we'll use a simple approach
        <span class="cov0" title="0">aStr := fmt.Sprintf("%v", a)
        bStr := fmt.Sprintf("%v", b)
        if aStr &lt; bStr </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov0" title="0"> if aStr &gt; bStr </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Add adds one occurrence of the specified element
func (ms *TreeMultiset[E]) Add(element E) int <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := 0
        ms.root, prevCount = ms.addNode(ms.root, element)
        ms.size++
        return prevCount
}</span>

func (ms *TreeMultiset[E]) addNode(node *treeNode[E], element E) (*treeNode[E], int) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return &amp;treeNode[E]{
                        element: element,
                        count:   1,
                        height:  1,
                }, 0
        }</span>
        
        <span class="cov8" title="1">cmp := ms.cmp(element, node.element)
        var prevCount int
        
        if cmp &lt; 0 </span><span class="cov8" title="1">{
                node.left, prevCount = ms.addNode(node.left, element)
        }</span> else<span class="cov8" title="1"> if cmp &gt; 0 </span><span class="cov8" title="1">{
                node.right, prevCount = ms.addNode(node.right, element)
        }</span> else<span class="cov8" title="1"> {
                prevCount = node.count
                node.count++
                return node, prevCount
        }</span>
        
        <span class="cov8" title="1">return ms.balance(node), prevCount</span>
}

// AddCount adds the specified number of occurrences of the element
func (ms *TreeMultiset[E]) AddCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return ms.Count(element), nil
        }</span>
        
        <span class="cov8" title="1">ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := 0
        ms.root, prevCount = ms.addCountNode(ms.root, element, count)
        ms.size += count
        return prevCount, nil</span>
}

func (ms *TreeMultiset[E]) addCountNode(node *treeNode[E], element E, count int) (*treeNode[E], int) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return &amp;treeNode[E]{
                        element: element,
                        count:   count,
                        height:  1,
                }, 0
        }</span>
        
        <span class="cov8" title="1">cmp := ms.cmp(element, node.element)
        var prevCount int
        
        if cmp &lt; 0 </span><span class="cov0" title="0">{
                node.left, prevCount = ms.addCountNode(node.left, element, count)
        }</span> else<span class="cov8" title="1"> if cmp &gt; 0 </span><span class="cov8" title="1">{
                node.right, prevCount = ms.addCountNode(node.right, element, count)
        }</span> else<span class="cov0" title="0"> {
                prevCount = node.count
                node.count += count
                return node, prevCount
        }</span>
        
        <span class="cov8" title="1">return ms.balance(node), prevCount</span>
}

// Remove removes one occurrence of the specified element
func (ms *TreeMultiset[E]) Remove(element E) int <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := 0
        ms.root, prevCount = ms.removeNode(ms.root, element, 1)
        if prevCount &gt; 0 </span><span class="cov8" title="1">{
                ms.size--
        }</span>
        <span class="cov8" title="1">return prevCount</span>
}

func (ms *TreeMultiset[E]) removeNode(node *treeNode[E], element E, count int) (*treeNode[E], int) <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        
        <span class="cov8" title="1">cmp := ms.cmp(element, node.element)
        var prevCount int
        
        if cmp &lt; 0 </span><span class="cov0" title="0">{
                node.left, prevCount = ms.removeNode(node.left, element, count)
        }</span> else<span class="cov8" title="1"> if cmp &gt; 0 </span><span class="cov0" title="0">{
                node.right, prevCount = ms.removeNode(node.right, element, count)
        }</span> else<span class="cov8" title="1"> {
                prevCount = node.count
                node.count -= count
                if node.count &lt;= 0 </span><span class="cov0" title="0">{
                        return ms.deleteNode(node), prevCount
                }</span>
                <span class="cov8" title="1">return node, prevCount</span>
        }
        
        <span class="cov0" title="0">return ms.balance(node), prevCount</span>
}

// RemoveCount removes the specified number of occurrences of the element
func (ms *TreeMultiset[E]) RemoveCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return ms.Count(element), nil
        }</span>
        
        <span class="cov8" title="1">ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := 0
        actualRemoved := 0
        ms.root, prevCount, actualRemoved = ms.removeCountNode(ms.root, element, count)
        ms.size -= actualRemoved
        return prevCount, nil</span>
}

func (ms *TreeMultiset[E]) removeCountNode(node *treeNode[E], element E, count int) (*treeNode[E], int, int) <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil, 0, 0
        }</span>
        
        <span class="cov8" title="1">cmp := ms.cmp(element, node.element)
        var prevCount, actualRemoved int
        
        if cmp &lt; 0 </span><span class="cov0" title="0">{
                node.left, prevCount, actualRemoved = ms.removeCountNode(node.left, element, count)
        }</span> else<span class="cov8" title="1"> if cmp &gt; 0 </span><span class="cov8" title="1">{
                node.right, prevCount, actualRemoved = ms.removeCountNode(node.right, element, count)
        }</span> else<span class="cov8" title="1"> {
                prevCount = node.count
                actualRemoved = count
                if actualRemoved &gt; prevCount </span><span class="cov0" title="0">{
                        actualRemoved = prevCount
                }</span>
                
                <span class="cov8" title="1">node.count -= actualRemoved
                if node.count &lt;= 0 </span><span class="cov0" title="0">{
                        return ms.deleteNode(node), prevCount, actualRemoved
                }</span>
                <span class="cov8" title="1">return node, prevCount, actualRemoved</span>
        }
        
        <span class="cov8" title="1">return ms.balance(node), prevCount, actualRemoved</span>
}

// RemoveAll removes all occurrences of the specified element
func (ms *TreeMultiset[E]) RemoveAll(element E) int <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        prevCount := 0
        ms.root, prevCount = ms.removeAllNode(ms.root, element)
        ms.size -= prevCount
        return prevCount
}</span>

func (ms *TreeMultiset[E]) removeAllNode(node *treeNode[E], element E) (*treeNode[E], int) <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        
        <span class="cov8" title="1">cmp := ms.cmp(element, node.element)
        var prevCount int
        
        if cmp &lt; 0 </span><span class="cov0" title="0">{
                node.left, prevCount = ms.removeAllNode(node.left, element)
        }</span> else<span class="cov8" title="1"> if cmp &gt; 0 </span><span class="cov8" title="1">{
                node.right, prevCount = ms.removeAllNode(node.right, element)
        }</span> else<span class="cov8" title="1"> {
                prevCount = node.count
                return ms.deleteNode(node), prevCount
        }</span>
        
        <span class="cov8" title="1">return ms.balance(node), prevCount</span>
}

func (ms *TreeMultiset[E]) deleteNode(node *treeNode[E]) *treeNode[E] <span class="cov8" title="1">{
        if node.left == nil </span><span class="cov8" title="1">{
                return node.right
        }</span>
        <span class="cov0" title="0">if node.right == nil </span><span class="cov0" title="0">{
                return node.left
        }</span>
        
        // Find inorder successor
        <span class="cov0" title="0">successor := ms.findMin(node.right)
        node.element = successor.element
        node.count = successor.count
        node.right = ms.deleteMin(node.right)
        
        return ms.balance(node)</span>
}

func (ms *TreeMultiset[E]) findMin(node *treeNode[E]) *treeNode[E] <span class="cov0" title="0">{
        for node.left != nil </span><span class="cov0" title="0">{
                node = node.left
        }</span>
        <span class="cov0" title="0">return node</span>
}

func (ms *TreeMultiset[E]) deleteMin(node *treeNode[E]) *treeNode[E] <span class="cov0" title="0">{
        if node.left == nil </span><span class="cov0" title="0">{
                return node.right
        }</span>
        <span class="cov0" title="0">node.left = ms.deleteMin(node.left)
        return ms.balance(node)</span>
}

// Count returns the number of occurrences of the specified element
func (ms *TreeMultiset[E]) Count(element E) int <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        node := ms.findNode(ms.root, element)
        if node == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return node.count</span>
}

func (ms *TreeMultiset[E]) findNode(node *treeNode[E], element E) *treeNode[E] <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        <span class="cov8" title="1">cmp := ms.cmp(element, node.element)
        if cmp &lt; 0 </span><span class="cov8" title="1">{
                return ms.findNode(node.left, element)
        }</span> else<span class="cov8" title="1"> if cmp &gt; 0 </span><span class="cov8" title="1">{
                return ms.findNode(node.right, element)
        }</span>
        <span class="cov8" title="1">return node</span>
}

// SetCount sets the count of the specified element to the given value
func (ms *TreeMultiset[E]) SetCount(element E, count int) (int, error) <span class="cov8" title="1">{
        if count &lt; 0 </span><span class="cov0" title="0">{
                return 0, common.NegativeCountError(count)
        }</span>
        
        <span class="cov8" title="1">prevCount := ms.Count(element)
        
        if count == 0 </span><span class="cov8" title="1">{
                ms.RemoveAll(element)
        }</span> else<span class="cov8" title="1"> {
                diff := count - prevCount
                if diff &gt; 0 </span><span class="cov8" title="1">{
                        _, err := ms.AddCount(element, diff)
                        if err != nil </span><span class="cov0" title="0">{
                                return prevCount, err
                        }</span>
                } else<span class="cov0" title="0"> if diff &lt; 0 </span><span class="cov0" title="0">{
                        _, err := ms.RemoveCount(element, -diff)
                        if err != nil </span><span class="cov0" title="0">{
                                return prevCount, err
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return prevCount, nil</span>
}

// Contains checks if the multiset contains the specified element
func (ms *TreeMultiset[E]) Contains(element E) bool <span class="cov8" title="1">{
        return ms.Count(element) &gt; 0
}</span>

// IsEmpty returns true if the multiset contains no elements
func (ms *TreeMultiset[E]) IsEmpty() bool <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return ms.size == 0
}</span>

// Size returns the number of distinct elements in the multiset
func (ms *TreeMultiset[E]) Size() int <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return ms.countNodes(ms.root)
}</span>

func (ms *TreeMultiset[E]) countNodes(node *treeNode[E]) int <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return 1 + ms.countNodes(node.left) + ms.countNodes(node.right)</span>
}

// TotalSize returns the total number of elements (including duplicates)
func (ms *TreeMultiset[E]) TotalSize() int <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        return ms.size
}</span>

// DistinctElements returns the number of distinct elements
func (ms *TreeMultiset[E]) DistinctElements() int <span class="cov0" title="0">{
        return ms.Size()
}</span>

// Clear removes all elements from the multiset
func (ms *TreeMultiset[E]) Clear() <span class="cov8" title="1">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        ms.root = nil
        ms.size = 0
}</span>

// ElementSet returns a slice of distinct elements in sorted order
func (ms *TreeMultiset[E]) ElementSet() []E <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        var elements []E
        ms.inorderElements(ms.root, &amp;elements)
        return elements
}</span>

func (ms *TreeMultiset[E]) inorderElements(node *treeNode[E], elements *[]E) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                ms.inorderElements(node.left, elements)
                *elements = append(*elements, node.element)
                ms.inorderElements(node.right, elements)
        }</span>
}

// EntrySet returns a slice of entries (element-count pairs) in sorted order
func (ms *TreeMultiset[E]) EntrySet() []Entry[E] <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        var entries []Entry[E]
        ms.inorderEntries(ms.root, &amp;entries)
        return entries
}</span>

func (ms *TreeMultiset[E]) inorderEntries(node *treeNode[E], entries *[]Entry[E]) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                ms.inorderEntries(node.left, entries)
                *entries = append(*entries, Entry[E]{Element: node.element, Count: node.count})
                ms.inorderEntries(node.right, entries)
        }</span>
}

// ToSlice returns a slice containing all elements (including duplicates) in sorted order
func (ms *TreeMultiset[E]) ToSlice() []E <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        var result []E
        ms.inorderSlice(ms.root, &amp;result)
        return result
}</span>

func (ms *TreeMultiset[E]) inorderSlice(node *treeNode[E], result *[]E) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                ms.inorderSlice(node.left, result)
                for i := 0; i &lt; node.count; i++ </span><span class="cov8" title="1">{
                        *result = append(*result, node.element)
                }</span>
                <span class="cov8" title="1">ms.inorderSlice(node.right, result)</span>
        }
}

// Iterator returns an iterator over the multiset elements in sorted order
func (ms *TreeMultiset[E]) Iterator() common.Iterator[E] <span class="cov8" title="1">{
        return &amp;treeMultisetIterator[E]{
                multiset: ms,
                entries:  ms.EntrySet(),
                index:    0,
                current:  0,
        }
}</span>

// ForEach executes the given function for each element in the multiset in sorted order
func (ms *TreeMultiset[E]) ForEach(fn func(E)) <span class="cov8" title="1">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        ms.forEachInorder(ms.root, fn)
}</span>

func (ms *TreeMultiset[E]) forEachInorder(node *treeNode[E], fn func(E)) <span class="cov8" title="1">{
        if node != nil </span><span class="cov8" title="1">{
                ms.forEachInorder(node.left, fn)
                for i := 0; i &lt; node.count; i++ </span><span class="cov8" title="1">{
                        fn(node.element)
                }</span>
                <span class="cov8" title="1">ms.forEachInorder(node.right, fn)</span>
        }
}

// Union returns a new multiset containing the union of this and another multiset
func (ms *TreeMultiset[E]) Union(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        result := NewTreeMultisetWithComparator(ms.cmp)
        
        // Add all elements from this multiset
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                result.AddCount(entry.Element, entry.Count)
        }</span>
        
        // Add elements from other multiset, taking maximum count
        <span class="cov0" title="0">for _, entry := range other.EntrySet() </span><span class="cov0" title="0">{
                currentCount := result.Count(entry.Element)
                if entry.Count &gt; currentCount </span><span class="cov0" title="0">{
                        result.SetCount(entry.Element, entry.Count)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

// Intersection returns a new multiset containing the intersection
func (ms *TreeMultiset[E]) Intersection(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        result := NewTreeMultisetWithComparator(ms.cmp)
        
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                otherCount := other.Count(entry.Element)
                if otherCount &gt; 0 </span><span class="cov0" title="0">{
                        minCount := entry.Count
                        if otherCount &lt; minCount </span><span class="cov0" title="0">{
                                minCount = otherCount
                        }</span>
                        <span class="cov0" title="0">result.AddCount(entry.Element, minCount)</span>
                }
        }
        
        <span class="cov0" title="0">return result</span>
}

// Difference returns a new multiset containing elements in this but not in other
func (ms *TreeMultiset[E]) Difference(other Multiset[E]) Multiset[E] <span class="cov0" title="0">{
        result := NewTreeMultisetWithComparator(ms.cmp)
        
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                otherCount := other.Count(entry.Element)
                if entry.Count &gt; otherCount </span><span class="cov0" title="0">{
                        result.AddCount(entry.Element, entry.Count-otherCount)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

// IsSubsetOf checks if this multiset is a subset of another
func (ms *TreeMultiset[E]) IsSubsetOf(other Multiset[E]) bool <span class="cov0" title="0">{
        for _, entry := range ms.EntrySet() </span><span class="cov0" title="0">{
                if other.Count(entry.Element) &lt; entry.Count </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// IsSupersetOf checks if this multiset is a superset of another
func (ms *TreeMultiset[E]) IsSupersetOf(other Multiset[E]) bool <span class="cov0" title="0">{
        return other.IsSubsetOf(ms)
}</span>

// String returns a string representation of the multiset
func (ms *TreeMultiset[E]) String() string <span class="cov0" title="0">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        if ms.size == 0 </span><span class="cov0" title="0">{
                return "TreeMultiset[]"
        }</span>
        
        <span class="cov0" title="0">var builder strings.Builder
        builder.WriteString("TreeMultiset[")
        
        entries := ms.EntrySet()
        for i, entry := range entries </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov0" title="0">if entry.Count == 1 </span><span class="cov0" title="0">{
                        builder.WriteString(fmt.Sprintf("%v", entry.Element))
                }</span> else<span class="cov0" title="0"> {
                        builder.WriteString(fmt.Sprintf("%v x %d", entry.Element, entry.Count))
                }</span>
        }
        
        <span class="cov0" title="0">builder.WriteString("]")
        return builder.String()</span>
}

// AVL tree balancing methods
func (ms *TreeMultiset[E]) height(node *treeNode[E]) int <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return node.height</span>
}

func (ms *TreeMultiset[E]) updateHeight(node *treeNode[E]) <span class="cov8" title="1">{
        leftHeight := ms.height(node.left)
        rightHeight := ms.height(node.right)
        if leftHeight &gt; rightHeight </span><span class="cov8" title="1">{
                node.height = leftHeight + 1
        }</span> else<span class="cov8" title="1"> {
                node.height = rightHeight + 1
        }</span>
}

func (ms *TreeMultiset[E]) balanceFactor(node *treeNode[E]) int <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return ms.height(node.left) - ms.height(node.right)</span>
}

func (ms *TreeMultiset[E]) rotateRight(y *treeNode[E]) *treeNode[E] <span class="cov8" title="1">{
        x := y.left
        y.left = x.right
        x.right = y
        ms.updateHeight(y)
        ms.updateHeight(x)
        return x
}</span>

func (ms *TreeMultiset[E]) rotateLeft(x *treeNode[E]) *treeNode[E] <span class="cov8" title="1">{
        y := x.right
        x.right = y.left
        y.left = x
        ms.updateHeight(x)
        ms.updateHeight(y)
        return y
}</span>

func (ms *TreeMultiset[E]) balance(node *treeNode[E]) *treeNode[E] <span class="cov8" title="1">{
        ms.updateHeight(node)
        
        balance := ms.balanceFactor(node)
        
        // Left heavy
        if balance &gt; 1 </span><span class="cov8" title="1">{
                if ms.balanceFactor(node.left) &lt; 0 </span><span class="cov8" title="1">{
                        node.left = ms.rotateLeft(node.left)
                }</span>
                <span class="cov8" title="1">return ms.rotateRight(node)</span>
        }
        
        // Right heavy
        <span class="cov8" title="1">if balance &lt; -1 </span><span class="cov8" title="1">{
                if ms.balanceFactor(node.right) &gt; 0 </span><span class="cov0" title="0">{
                        node.right = ms.rotateRight(node.right)
                }</span>
                <span class="cov8" title="1">return ms.rotateLeft(node)</span>
        }
        
        <span class="cov8" title="1">return node</span>
}

// treeMultisetIterator implements Iterator for TreeMultiset
type treeMultisetIterator[E comparable] struct {
        multiset *TreeMultiset[E]
        entries  []Entry[E]
        index    int
        current  int
}

func (it *treeMultisetIterator[E]) HasNext() bool <span class="cov8" title="1">{
        return it.index &lt; len(it.entries) &amp;&amp; (it.current &lt; it.entries[it.index].Count || it.index+1 &lt; len(it.entries))
}</span>

func (it *treeMultisetIterator[E]) Next() (E, bool) <span class="cov8" title="1">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                var zero E
                return zero, false
        }</span>
        
        <span class="cov8" title="1">if it.current &gt;= it.entries[it.index].Count </span><span class="cov8" title="1">{
                it.index++
                it.current = 0
        }</span>
        
        <span class="cov8" title="1">element := it.entries[it.index].Element
        it.current++
        return element, true</span>
}

func (it *treeMultisetIterator[E]) Reset() <span class="cov0" title="0">{
        it.entries = it.multiset.EntrySet()
        it.index = 0
        it.current = 0
}</span>

func (it *treeMultisetIterator[E]) Remove() bool <span class="cov0" title="0">{
        if it.index &gt;= len(it.entries) || it.current == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">element := it.entries[it.index].Element
        it.multiset.Remove(element)
        
        // Refresh entries after removal
        it.entries = it.multiset.EntrySet()
        if it.index &gt;= len(it.entries) </span><span class="cov0" title="0">{
                it.index = len(it.entries)
                it.current = 0
        }</span> else<span class="cov0" title="0"> if it.current &gt; it.entries[it.index].Count </span><span class="cov0" title="0">{
                it.current = it.entries[it.index].Count
        }</span>
        
        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">// Package queue provides queue data structure implementations
package queue

import (
        "github.com/chenjianyu/collections/container/common"
        "github.com/chenjianyu/collections/container/list"
)

// LinkedList is a Deque implementation based on doubly linked list, reusing LinkedList from list package
type LinkedList[E any] struct {
        list   *list.LinkedList[E]
        maxCap int // maximum capacity, 0 means unbounded
}

// New creates a new unbounded LinkedList
func New[E any]() *LinkedList[E] <span class="cov0" title="0">{
        return &amp;LinkedList[E]{
                list:   list.NewLinkedList[E](),
                maxCap: 0,
        }
}</span>

// WithCapacity creates a LinkedList with specified maximum capacity
func WithCapacity[E any](capacity int) *LinkedList[E] <span class="cov8" title="1">{
        return &amp;LinkedList[E]{
                list:   list.NewLinkedList[E](),
                maxCap: capacity,
        }
}</span>

// FromSlice creates a new LinkedList from a slice
func FromSlice[E any](slice []E) *LinkedList[E] <span class="cov0" title="0">{
        ll := New[E]()
        for _, item := range slice </span><span class="cov0" title="0">{
                ll.list.Add(item)
        }</span>
        <span class="cov0" title="0">return ll</span>
}

// Size returns the number of elements in the queue
func (ll *LinkedList[E]) Size() int <span class="cov8" title="1">{
        return ll.list.Size()
}</span>

// IsEmpty checks if the queue is empty
func (ll *LinkedList[E]) IsEmpty() bool <span class="cov0" title="0">{
        return ll.list.IsEmpty()
}</span>

// isFull checks if the queue is full
func (ll *LinkedList[E]) isFull() bool <span class="cov8" title="1">{
        return ll.maxCap &gt; 0 &amp;&amp; ll.list.Size() &gt;= ll.maxCap
}</span>

// Clear clears the queue
func (ll *LinkedList[E]) Clear() <span class="cov0" title="0">{
        ll.list.Clear()
}</span>

// Contains checks if the queue contains the specified element
func (ll *LinkedList[E]) Contains(element E) bool <span class="cov0" title="0">{
        return ll.list.Contains(element)
}</span>

// ForEach executes the given operation for each element in the queue
func (ll *LinkedList[E]) ForEach(fn func(E)) <span class="cov0" title="0">{
        ll.list.ForEach(fn)
}</span>

// String returns the string representation of the queue
func (ll *LinkedList[E]) String() string <span class="cov0" title="0">{
        return ll.list.String()
}</span>

// Add adds an element to the tail of the queue
func (ll *LinkedList[E]) Add(element E) error <span class="cov8" title="1">{
        if ll.isFull() </span><span class="cov8" title="1">{
                return common.FullContainerError("LinkedListQueue", ll.maxCap)
        }</span>
        <span class="cov8" title="1">ll.list.Add(element)
        return nil</span>
}

// Offer adds an element to the tail of the queue
func (ll *LinkedList[E]) Offer(element E) bool <span class="cov8" title="1">{
        if ll.isFull() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">ll.list.Add(element)
        return true</span>
}

// Remove removes and returns the element at the head of the queue
func (ll *LinkedList[E]) Remove() (E, error) <span class="cov0" title="0">{
        if ll.IsEmpty() </span><span class="cov0" title="0">{
                var zero E
                return zero, common.EmptyContainerError("LinkedListQueue")
        }</span>
        <span class="cov0" title="0">val, success := ll.list.RemoveFirst()
        if !success </span><span class="cov0" title="0">{
                var zero E
                return zero, common.EmptyContainerError("LinkedListQueue")
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// Poll removes and returns the element at the head of the queue
func (ll *LinkedList[E]) Poll() (E, bool) <span class="cov0" title="0">{
        val, success := ll.list.RemoveFirst()
        return val, success
}</span>

// Element returns the element at the head of the queue without removing it
func (ll *LinkedList[E]) Element() (E, error) <span class="cov0" title="0">{
        return ll.list.GetFirst()
}</span>

// Peek returns the element at the head of the queue without removing it
func (ll *LinkedList[E]) Peek() (E, bool) <span class="cov0" title="0">{
        val, err := ll.list.GetFirst()
        return val, err == nil
}</span>

// AddFirst adds an element to the head of the queue
func (ll *LinkedList[E]) AddFirst(element E) error <span class="cov0" title="0">{
        if ll.isFull() </span><span class="cov0" title="0">{
                return common.FullContainerError("LinkedListQueue", ll.maxCap)
        }</span>
        <span class="cov0" title="0">ll.list.AddFirst(element)
        return nil</span>
}

// AddLast adds an element to the tail of the queue
func (ll *LinkedList[E]) AddLast(element E) error <span class="cov0" title="0">{
        if ll.isFull() </span><span class="cov0" title="0">{
                return common.FullContainerError("LinkedListQueue", ll.maxCap)
        }</span>
        <span class="cov0" title="0">ll.list.AddLast(element)
        return nil</span>
}

// OfferFirst adds an element to the head of the queue
func (ll *LinkedList[E]) OfferFirst(element E) bool <span class="cov0" title="0">{
        if ll.isFull() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">ll.list.AddFirst(element)
        return true</span>
}

// OfferLast adds an element to the tail of the queue
func (ll *LinkedList[E]) OfferLast(element E) bool <span class="cov0" title="0">{
        if ll.isFull() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">ll.list.AddLast(element)
        return true</span>
}

// RemoveFirst removes and returns the element at the head of the queue
func (ll *LinkedList[E]) RemoveFirst() (E, error) <span class="cov0" title="0">{
        if ll.IsEmpty() </span><span class="cov0" title="0">{
                var zero E
                return zero, common.EmptyContainerError("LinkedListQueue")
        }</span>
        <span class="cov0" title="0">val, success := ll.list.RemoveFirst()
        if !success </span><span class="cov0" title="0">{
                var zero E
                return zero, common.EmptyContainerError("LinkedListQueue")
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// RemoveLast removes and returns the element at the tail of the queue
func (ll *LinkedList[E]) RemoveLast() (E, error) <span class="cov0" title="0">{
        if ll.IsEmpty() </span><span class="cov0" title="0">{
                var zero E
                return zero, common.EmptyContainerError("LinkedListQueue")
        }</span>
        <span class="cov0" title="0">val, success := ll.list.RemoveLast()
        if !success </span><span class="cov0" title="0">{
                var zero E
                return zero, common.EmptyContainerError("LinkedListQueue")
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// PollFirst removes and returns the element at the head of the queue
func (ll *LinkedList[E]) PollFirst() (E, bool) <span class="cov0" title="0">{
        val, err := ll.RemoveFirst()
        return val, err == nil
}</span>

// PollLast removes and returns the element at the tail of the queue
func (ll *LinkedList[E]) PollLast() (E, bool) <span class="cov0" title="0">{
        val, err := ll.RemoveLast()
        return val, err == nil
}</span>

// GetFirst returns the element at the head of the queue without removing it
func (ll *LinkedList[E]) GetFirst() (E, error) <span class="cov0" title="0">{
        if ll.IsEmpty() </span><span class="cov0" title="0">{
                var zero E
                return zero, common.EmptyContainerError("LinkedListQueue")
        }</span>
        <span class="cov0" title="0">return ll.list.GetFirst()</span>
}

// GetLast returns the element at the tail of the queue without removing it
func (ll *LinkedList[E]) GetLast() (E, error) <span class="cov0" title="0">{
        if ll.IsEmpty() </span><span class="cov0" title="0">{
                var zero E
                return zero, common.EmptyContainerError("LinkedListQueue")
        }</span>
        <span class="cov0" title="0">return ll.list.GetLast()</span>
}

// PeekFirst returns the element at the head of the queue without removing it
func (ll *LinkedList[E]) PeekFirst() (E, bool) <span class="cov0" title="0">{
        val, err := ll.GetFirst()
        return val, err == nil
}</span>

// PeekLast returns the element at the tail of the queue without removing it
func (ll *LinkedList[E]) PeekLast() (E, bool) <span class="cov0" title="0">{
        val, err := ll.GetLast()
        return val, err == nil
}</span>

// ToSlice returns a slice containing all elements in the queue
func (ll *LinkedList[E]) ToSlice() []E <span class="cov0" title="0">{
        return ll.list.ToSlice()
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package queue provides queue data structure implementations
package queue

import (
        "fmt"
        "strings"
        "github.com/chenjianyu/collections/container/common"
)

// PriorityQueue is a priority queue implementation based on binary heap
// Default is min heap, can create max heap by providing custom comparator
type PriorityQueue[E any] struct {
        heap       []E
        comparator func(a, b E) int
        maxCap     int // maximum capacity, 0 means unbounded
}

// NewPriorityQueue creates a new unbounded priority queue using default comparator
// Default comparator requires element type to implement common.Comparable interface
func NewPriorityQueue[E common.Comparable]() *PriorityQueue[E] <span class="cov8" title="1">{
        return &amp;PriorityQueue[E]{
                heap: make([]E, 0),
                comparator: func(a, b E) int </span><span class="cov8" title="1">{
                        return a.CompareTo(b)
                }</span>,
                maxCap: 0,
        }
}

// NewPriorityQueueWithComparator creates a new unbounded priority queue using custom comparator
func NewPriorityQueueWithComparator[E any](comparator func(a, b E) int) *PriorityQueue[E] <span class="cov8" title="1">{
        return &amp;PriorityQueue[E]{
                heap:       make([]E, 0),
                comparator: comparator,
                maxCap:     0,
        }
}</span>

// WithCapacity creates a priority queue with specified maximum capacity using default comparator
func WithCapacityComparable[E common.Comparable](capacity int) *PriorityQueue[E] <span class="cov0" title="0">{
        return &amp;PriorityQueue[E]{
                heap: make([]E, 0, capacity),
                comparator: func(a, b E) int </span><span class="cov0" title="0">{
                        return a.CompareTo(b)
                }</span>,
                maxCap: capacity,
        }
}

// WithCapacityAndComparator creates a priority queue with specified maximum capacity using custom comparator
func WithCapacityAndComparator[E any](capacity int, comparator func(a, b E) int) *PriorityQueue[E] <span class="cov0" title="0">{
        return &amp;PriorityQueue[E]{
                heap:       make([]E, 0, capacity),
                comparator: comparator,
                maxCap:     capacity,
        }
}</span>

// NewFromSlice creates a new priority queue from a slice using default comparator
func NewFromSliceComparable[E common.Comparable](slice []E) *PriorityQueue[E] <span class="cov0" title="0">{
        pq := NewPriorityQueue[E]()
        for _, item := range slice </span><span class="cov0" title="0">{
                pq.Add(item)
        }</span>
        <span class="cov0" title="0">return pq</span>
}

// NewFromSliceWithComparator creates a new priority queue from a slice using custom comparator
func NewFromSliceWithComparator[E any](slice []E, comparator func(a, b E) int) *PriorityQueue[E] <span class="cov0" title="0">{
        pq := NewPriorityQueueWithComparator(comparator)
        for _, item := range slice </span><span class="cov0" title="0">{
                pq.Add(item)
        }</span>
        <span class="cov0" title="0">return pq</span>
}

// Size returns the number of elements in the queue
func (pq *PriorityQueue[E]) Size() int <span class="cov8" title="1">{
        return len(pq.heap)
}</span>

// IsEmpty checks if the queue is empty
func (pq *PriorityQueue[E]) IsEmpty() bool <span class="cov8" title="1">{
        return len(pq.heap) == 0
}</span>

// isFull checks if the queue is full
func (pq *PriorityQueue[E]) isFull() bool <span class="cov8" title="1">{
        return pq.maxCap &gt; 0 &amp;&amp; len(pq.heap) &gt;= pq.maxCap
}</span>

// Clear clears the queue
func (pq *PriorityQueue[E]) Clear() <span class="cov8" title="1">{
        pq.heap = pq.heap[:0]
}</span>

// Contains checks if the queue contains the specified element
func (pq *PriorityQueue[E]) Contains(element E) bool <span class="cov8" title="1">{
        for _, item := range pq.heap </span><span class="cov8" title="1">{
                if common.Equal(item, element) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ForEach executes the given operation for each element in the queue
// Note: traversal order is not guaranteed to be in priority order
func (pq *PriorityQueue[E]) ForEach(fn func(E)) <span class="cov8" title="1">{
        for _, item := range pq.heap </span><span class="cov8" title="1">{
                fn(item)
        }</span>
}

// String returns the string representation of the queue
func (pq *PriorityQueue[E]) String() string <span class="cov8" title="1">{
        if pq.IsEmpty() </span><span class="cov8" title="1">{
                return "[]"
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.WriteString("[")

        for i, item := range pq.heap </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("%v", item))
                if i &lt; len(pq.heap)-1 </span><span class="cov8" title="1">{
                        sb.WriteString(", ")
                }</span>
        }

        <span class="cov8" title="1">sb.WriteString("]")
        return sb.String()</span>
}

// Add adds an element to the queue
func (pq *PriorityQueue[E]) Add(element E) error <span class="cov8" title="1">{
        if pq.isFull() </span><span class="cov0" title="0">{
                return common.FullContainerError("PriorityQueue", pq.maxCap)
        }</span>

        <span class="cov8" title="1">pq.heap = append(pq.heap, element)
        pq.heapifyUp(len(pq.heap) - 1)
        return nil</span>
}

// Offer adds an element to the queue
func (pq *PriorityQueue[E]) Offer(element E) bool <span class="cov8" title="1">{
        if pq.isFull() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">pq.heap = append(pq.heap, element)
        pq.heapifyUp(len(pq.heap) - 1)
        return true</span>
}

// Remove removes and returns the highest priority element from the queue
func (pq *PriorityQueue[E]) Remove() (E, error) <span class="cov8" title="1">{
        if pq.IsEmpty() </span><span class="cov8" title="1">{
                var zero E
                return zero, common.EmptyContainerError("PriorityQueue")
        }</span>

        <span class="cov8" title="1">root := pq.heap[0]
        lastIndex := len(pq.heap) - 1
        pq.heap[0] = pq.heap[lastIndex]
        pq.heap = pq.heap[:lastIndex]

        if len(pq.heap) &gt; 0 </span><span class="cov8" title="1">{
                pq.heapifyDown(0)
        }</span>

        <span class="cov8" title="1">return root, nil</span>
}

// Poll removes and returns the highest priority element from the queue
func (pq *PriorityQueue[E]) Poll() (E, bool) <span class="cov8" title="1">{
        element, err := pq.Remove()
        return element, err == nil
}</span>

// Element returns the highest priority element from the queue without removing it
func (pq *PriorityQueue[E]) Element() (E, error) <span class="cov8" title="1">{
        if pq.IsEmpty() </span><span class="cov8" title="1">{
                var zero E
                return zero, common.EmptyContainerError("PriorityQueue")
        }</span>
        <span class="cov8" title="1">return pq.heap[0], nil</span>
}

// Peek returns the highest priority element from the queue without removing it
func (pq *PriorityQueue[E]) Peek() (E, bool) <span class="cov8" title="1">{
        element, err := pq.Element()
        return element, err == nil
}</span>

// ToSlice returns a slice containing all elements in the queue
// Note: returned slice is not guaranteed to be sorted by priority
func (pq *PriorityQueue[E]) ToSlice() []E <span class="cov8" title="1">{
        result := make([]E, len(pq.heap))
        copy(result, pq.heap)
        return result
}</span>

// ToSortedSlice returns a slice of queue elements sorted by priority
func (pq *PriorityQueue[E]) ToSortedSlice() []E <span class="cov8" title="1">{
        if pq.IsEmpty() </span><span class="cov8" title="1">{
                return []E{}
        }</span>

        // Create a copy of the priority queue
        <span class="cov8" title="1">tempPQ := &amp;PriorityQueue[E]{
                heap:       make([]E, len(pq.heap)),
                comparator: pq.comparator,
                maxCap:     0,
        }
        copy(tempPQ.heap, pq.heap)

        result := make([]E, 0, len(pq.heap))
        for !tempPQ.IsEmpty() </span><span class="cov8" title="1">{
                element, _ := tempPQ.Remove()
                result = append(result, element)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Internal method: heapify up operation to maintain heap property
func (pq *PriorityQueue[E]) heapifyUp(index int) <span class="cov8" title="1">{
        for index &gt; 0 </span><span class="cov8" title="1">{
                parentIndex := (index - 1) / 2
                if pq.comparator(pq.heap[index], pq.heap[parentIndex]) &gt;= 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">pq.heap[index], pq.heap[parentIndex] = pq.heap[parentIndex], pq.heap[index]
                index = parentIndex</span>
        }
}

// Internal method: heapify down operation to maintain heap property
func (pq *PriorityQueue[E]) heapifyDown(index int) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                leftChild := 2*index + 1
                rightChild := 2*index + 2
                smallest := index

                if leftChild &lt; len(pq.heap) &amp;&amp; pq.comparator(pq.heap[leftChild], pq.heap[smallest]) &lt; 0 </span><span class="cov8" title="1">{
                        smallest = leftChild
                }</span>

                <span class="cov8" title="1">if rightChild &lt; len(pq.heap) &amp;&amp; pq.comparator(pq.heap[rightChild], pq.heap[smallest]) &lt; 0 </span><span class="cov8" title="1">{
                        smallest = rightChild
                }</span>

                <span class="cov8" title="1">if smallest == index </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">pq.heap[index], pq.heap[smallest] = pq.heap[smallest], pq.heap[index]
                index = smallest</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package ranges

import (
        "strings"
        "log"
        "github.com/chenjianyu/collections/container/common"
)

// ImmutableRangeMap is an immutable implementation of RangeMap
// All modification operations return new instances
type ImmutableRangeMap[K comparable, V any] struct {
        entries    []Entry[K, V]
        comparator Comparator[K]
}

// NewImmutableRangeMap creates a new empty ImmutableRangeMap
func NewImmutableRangeMap[K comparable, V any]() RangeMap[K, V] <span class="cov8" title="1">{
        return &amp;ImmutableRangeMap[K, V]{
                entries:    make([]Entry[K, V], 0),
                comparator: DefaultComparator[K],
        }
}</span>

// NewImmutableRangeMapWithComparator creates a new ImmutableRangeMap with custom comparator
func NewImmutableRangeMapWithComparator[K comparable, V any](cmp Comparator[K]) RangeMap[K, V] <span class="cov0" title="0">{
        return &amp;ImmutableRangeMap[K, V]{
                entries:    make([]Entry[K, V], 0),
                comparator: cmp,
        }
}</span>

// NewImmutableRangeMapFromEntries creates a new ImmutableRangeMap from existing entries
func NewImmutableRangeMapFromEntries[K comparable, V any](entries []Entry[K, V]) RangeMap[K, V] <span class="cov0" title="0">{
        // Create a mutable map to handle overlapping ranges
        mutableMap := NewTreeRangeMap[K, V]()
        for _, entry := range entries </span><span class="cov0" title="0">{
                mutableMap.Put(entry.Range, entry.Value)
        }</span>
        
        <span class="cov0" title="0">return &amp;ImmutableRangeMap[K, V]{
                entries:    convertToEntries(mutableMap.AsMapOfRanges()),
                comparator: DefaultComparator[K],
        }</span>
}

// Helper function to convert map to entries slice
func convertToEntries[K comparable, V any](rangeMap map[Range[K]]V) []Entry[K, V] <span class="cov0" title="0">{
        entries := make([]Entry[K, V], 0, len(rangeMap))
        for r, v := range rangeMap </span><span class="cov0" title="0">{
                entries = append(entries, Entry[K, V]{Range: r, Value: v})
        }</span>
        <span class="cov0" title="0">return entries</span>
}

// Size returns the number of range-value mappings in this map
func (irm *ImmutableRangeMap[K, V]) Size() int <span class="cov0" title="0">{
        return len(irm.entries)
}</span>

// IsEmpty returns true if this range map is empty
func (irm *ImmutableRangeMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return len(irm.entries) == 0
}</span>

// Clear logs an error and returns as ImmutableRangeMap is immutable
func (irm *ImmutableRangeMap[K, V]) Clear() <span class="cov0" title="0">{
        err := common.ImmutableOperationError("Clear", "WithClear()")
        log.Printf("Warning: %v", err)
}</span>

// WithClear returns a new empty ImmutableRangeMap
func (irm *ImmutableRangeMap[K, V]) WithClear() RangeMap[K, V] <span class="cov0" title="0">{
        return NewImmutableRangeMapWithComparator[K, V](irm.comparator)
}</span>

// String returns the string representation of this range map
func (irm *ImmutableRangeMap[K, V]) String() string <span class="cov0" title="0">{
        if len(irm.entries) == 0 </span><span class="cov0" title="0">{
                return "{}"
        }</span>
        
        <span class="cov0" title="0">var parts []string
        for _, entry := range irm.entries </span><span class="cov0" title="0">{
                parts = append(parts, entry.String())
        }</span>
        <span class="cov0" title="0">return "{" + strings.Join(parts, ", ") + "}"</span>
}

// Get returns the value associated with the specified key, or nil if no such value exists
func (irm *ImmutableRangeMap[K, V]) Get(key K) (V, bool) <span class="cov0" title="0">{
        for _, entry := range irm.entries </span><span class="cov0" title="0">{
                if entry.Range.Contains(key) </span><span class="cov0" title="0">{
                        return entry.Value, true
                }</span>
        }
        
        <span class="cov0" title="0">var zero V
        return zero, false</span>
}

// GetEntry returns the range-value entry that contains the specified key
func (irm *ImmutableRangeMap[K, V]) GetEntry(key K) (Range[K], V, bool) <span class="cov0" title="0">{
        for _, entry := range irm.entries </span><span class="cov0" title="0">{
                if entry.Range.Contains(key) </span><span class="cov0" title="0">{
                        return entry.Range, entry.Value, true
                }</span>
        }
        
        <span class="cov0" title="0">var zeroV V
        var zeroR Range[K]
        return zeroR, zeroV, false</span>
}

// Put logs an error and returns as ImmutableRangeMap is immutable
func (irm *ImmutableRangeMap[K, V]) Put(rangeKey Range[K], value V) <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Put", "WithPut()")
        log.Printf("Warning: %v", err)
}</span>

// WithPut returns a new ImmutableRangeMap with the range-value mapping added
func (irm *ImmutableRangeMap[K, V]) WithPut(rangeKey Range[K], value V) RangeMap[K, V] <span class="cov0" title="0">{
        if rangeKey == nil || rangeKey.IsEmpty() </span><span class="cov0" title="0">{
                return irm
        }</span>
        
        // Create a mutable copy and add the mapping
        <span class="cov0" title="0">mutableMap := NewTreeRangeMapWithComparator[K, V](irm.comparator)
        for _, entry := range irm.entries </span><span class="cov0" title="0">{
                mutableMap.Put(entry.Range, entry.Value)
        }</span>
        <span class="cov0" title="0">mutableMap.Put(rangeKey, value)
        
        return &amp;ImmutableRangeMap[K, V]{
                entries:    convertToEntries(mutableMap.AsMapOfRanges()),
                comparator: irm.comparator,
        }</span>
}

// PutRange logs an error and returns as ImmutableRangeMap is immutable
func (irm *ImmutableRangeMap[K, V]) PutRange(lower K, lowerType BoundType, upper K, upperType BoundType, value V) <span class="cov0" title="0">{
        err := common.ImmutableOperationError("PutRange", "WithPutRange()")
        log.Printf("Warning: %v", err)
}</span>

// WithPutRange returns a new ImmutableRangeMap with the range-value mapping added
func (irm *ImmutableRangeMap[K, V]) WithPutRange(lower K, lowerType BoundType, upper K, upperType BoundType, value V) RangeMap[K, V] <span class="cov0" title="0">{
        rangeKey := NewRangeWithComparator(lower, lowerType, upper, upperType, irm.comparator)
        return irm.WithPut(rangeKey, value)
}</span>

// Remove logs an error and returns as ImmutableRangeMap is immutable
func (irm *ImmutableRangeMap[K, V]) Remove(rangeToRemove Range[K]) <span class="cov0" title="0">{
        err := common.ImmutableOperationError("Remove", "WithRemove()")
        log.Printf("Warning: %v", err)
}</span>

// WithRemove returns a new ImmutableRangeMap with the range removed
func (irm *ImmutableRangeMap[K, V]) WithRemove(rangeToRemove Range[K]) RangeMap[K, V] <span class="cov0" title="0">{
        if rangeToRemove == nil || rangeToRemove.IsEmpty() </span><span class="cov0" title="0">{
                return irm
        }</span>
        
        // Create a mutable copy and remove the range
        <span class="cov0" title="0">mutableMap := NewTreeRangeMapWithComparator[K, V](irm.comparator)
        for _, entry := range irm.entries </span><span class="cov0" title="0">{
                mutableMap.Put(entry.Range, entry.Value)
        }</span>
        <span class="cov0" title="0">mutableMap.Remove(rangeToRemove)
        
        return &amp;ImmutableRangeMap[K, V]{
                entries:    convertToEntries(mutableMap.AsMapOfRanges()),
                comparator: irm.comparator,
        }</span>
}

// RemoveRange logs an error and returns as ImmutableRangeMap is immutable
func (irm *ImmutableRangeMap[K, V]) RemoveRange(lower K, lowerType BoundType, upper K, upperType BoundType) <span class="cov0" title="0">{
        err := common.ImmutableOperationError("RemoveRange", "WithRemoveRange()")
        log.Printf("Warning: %v", err)
}</span>

// WithRemoveRange returns a new ImmutableRangeMap with the range removed
func (irm *ImmutableRangeMap[K, V]) WithRemoveRange(lower K, lowerType BoundType, upper K, upperType BoundType) RangeMap[K, V] <span class="cov0" title="0">{
        rangeToRemove := NewRangeWithComparator(lower, lowerType, upper, upperType, irm.comparator)
        return irm.WithRemove(rangeToRemove)
}</span>

// AsMapOfRanges returns a view of this range map as a map from ranges to values
func (irm *ImmutableRangeMap[K, V]) AsMapOfRanges() map[Range[K]]V <span class="cov0" title="0">{
        result := make(map[Range[K]]V)
        for _, entry := range irm.entries </span><span class="cov0" title="0">{
                result[entry.Range] = entry.Value
        }</span>
        <span class="cov0" title="0">return result</span>
}

// AsDescendingMapOfRanges returns a view of this range map as a map from ranges to values in descending order
func (irm *ImmutableRangeMap[K, V]) AsDescendingMapOfRanges() map[Range[K]]V <span class="cov0" title="0">{
        result := make(map[Range[K]]V)
        for i := len(irm.entries) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                entry := irm.entries[i]
                result[entry.Range] = entry.Value
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Span returns the minimal range that contains all ranges in this map
func (irm *ImmutableRangeMap[K, V]) Span() (Range[K], bool) <span class="cov0" title="0">{
        if len(irm.entries) == 0 </span><span class="cov0" title="0">{
                var zeroR Range[K]
                return zeroR, false
        }</span>
        
        <span class="cov0" title="0">if len(irm.entries) == 1 </span><span class="cov0" title="0">{
                return irm.entries[0].Range, true
        }</span>
        
        // Calculate the span of all ranges
        <span class="cov0" title="0">span := irm.entries[0].Range
        for i := 1; i &lt; len(irm.entries); i++ </span><span class="cov0" title="0">{
                span = span.Span(irm.entries[i].Range)
        }</span>
        
        <span class="cov0" title="0">return span, true</span>
}

// SubRangeMap returns a view of the portion of this range map that intersects with the given range
func (irm *ImmutableRangeMap[K, V]) SubRangeMap(subRange Range[K]) RangeMap[K, V] <span class="cov0" title="0">{
        if subRange == nil || subRange.IsEmpty() </span><span class="cov0" title="0">{
                return NewImmutableRangeMapWithComparator[K, V](irm.comparator)
        }</span>
        
        <span class="cov0" title="0">var resultEntries []Entry[K, V]
        
        for _, entry := range irm.entries </span><span class="cov0" title="0">{
                if entry.Range.IsConnected(subRange) </span><span class="cov0" title="0">{
                        intersection := entry.Range.Intersection(subRange)
                        if !intersection.IsEmpty() </span><span class="cov0" title="0">{
                                resultEntries = append(resultEntries, Entry[K, V]{
                                        Range: intersection,
                                        Value: entry.Value,
                                })
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return &amp;ImmutableRangeMap[K, V]{
                entries:    resultEntries,
                comparator: irm.comparator,
        }</span>
}</pre>
		
		<pre class="file" id="file24" style="display: none">package ranges

import (
        "strings"
        "log"
        "github.com/chenjianyu/collections/container/common"
)

// ImmutableRangeSet is an immutable implementation of RangeSet
// All modification operations return new instances
type ImmutableRangeSet[T comparable] struct {
        ranges     []Range[T]
        comparator Comparator[T]
}

// NewImmutableRangeSet creates a new empty ImmutableRangeSet
func NewImmutableRangeSet[T comparable]() RangeSet[T] <span class="cov8" title="1">{
        return &amp;ImmutableRangeSet[T]{
                ranges:     make([]Range[T], 0),
                comparator: DefaultComparator[T],
        }
}</span>

// NewImmutableRangeSetWithComparator creates a new ImmutableRangeSet with custom comparator
func NewImmutableRangeSetWithComparator[T comparable](cmp Comparator[T]) RangeSet[T] <span class="cov0" title="0">{
        return &amp;ImmutableRangeSet[T]{
                ranges:     make([]Range[T], 0),
                comparator: cmp,
        }
}</span>

// NewImmutableRangeSetFromRanges creates a new ImmutableRangeSet from existing ranges
func NewImmutableRangeSetFromRanges[T comparable](ranges []Range[T]) RangeSet[T] <span class="cov0" title="0">{
        // Create a mutable set to handle merging and sorting
        mutableSet := NewTreeRangeSet[T]()
        for _, r := range ranges </span><span class="cov0" title="0">{
                mutableSet.Add(r)
        }</span>
        
        <span class="cov0" title="0">return &amp;ImmutableRangeSet[T]{
                ranges:     mutableSet.AsRanges(),
                comparator: DefaultComparator[T],
        }</span>
}

// Size returns the number of ranges in this set
func (irs *ImmutableRangeSet[T]) Size() int <span class="cov0" title="0">{
        return len(irs.ranges)
}</span>

// IsEmpty returns true if this range set is empty
func (irs *ImmutableRangeSet[T]) IsEmpty() bool <span class="cov8" title="1">{
        return len(irs.ranges) == 0
}</span>

// Clear returns a new empty ImmutableRangeSet (immutable operation)
// Clear logs an error and returns as ImmutableRangeSet is immutable
func (irs *ImmutableRangeSet[T]) Clear() <span class="cov0" title="0">{
        err := common.ImmutableOperationError("Clear", "WithClear()")
        log.Printf("Warning: %v", err)
}</span>

// WithClear returns a new empty ImmutableRangeSet
func (irs *ImmutableRangeSet[T]) WithClear() RangeSet[T] <span class="cov0" title="0">{
        return NewImmutableRangeSetWithComparator(irs.comparator)
}</span>

// String returns the string representation of this range set
func (irs *ImmutableRangeSet[T]) String() string <span class="cov0" title="0">{
        if len(irs.ranges) == 0 </span><span class="cov0" title="0">{
                return "{}"
        }</span>
        
        <span class="cov0" title="0">var parts []string
        for _, r := range irs.ranges </span><span class="cov0" title="0">{
                parts = append(parts, r.String())
        }</span>
        <span class="cov0" title="0">return "{" + strings.Join(parts, ", ") + "}"</span>
}

// Add returns an error as ImmutableRangeSet is immutable
// Add logs an error and returns as ImmutableRangeSet is immutable
func (irs *ImmutableRangeSet[T]) Add(rangeToAdd Range[T]) <span class="cov8" title="1">{
        err := common.ImmutableOperationError("Add", "WithAdd()")
        log.Printf("Warning: %v", err)
}</span>

// WithAdd returns a new ImmutableRangeSet with the range added
func (irs *ImmutableRangeSet[T]) WithAdd(rangeToAdd Range[T]) RangeSet[T] <span class="cov0" title="0">{
        if rangeToAdd == nil || rangeToAdd.IsEmpty() </span><span class="cov0" title="0">{
                return irs
        }</span>
        
        // Create a mutable copy and add the range
        <span class="cov0" title="0">mutableSet := NewTreeRangeSetWithComparator(irs.comparator)
        for _, r := range irs.ranges </span><span class="cov0" title="0">{
                mutableSet.Add(r)
        }</span>
        <span class="cov0" title="0">mutableSet.Add(rangeToAdd)
        
        return &amp;ImmutableRangeSet[T]{
                ranges:     mutableSet.AsRanges(),
                comparator: irs.comparator,
        }</span>
}

// AddRange returns an error as ImmutableRangeSet is immutable
// AddRange logs an error and returns as ImmutableRangeSet is immutable
func (irs *ImmutableRangeSet[T]) AddRange(lower T, lowerType BoundType, upper T, upperType BoundType) <span class="cov0" title="0">{
        err := common.ImmutableOperationError("AddRange", "WithAddRange()")
        log.Printf("Warning: %v", err)
}</span>

// WithAddRange returns a new ImmutableRangeSet with the range added
func (irs *ImmutableRangeSet[T]) WithAddRange(lower T, lowerType BoundType, upper T, upperType BoundType) RangeSet[T] <span class="cov0" title="0">{
        rangeToAdd := NewRangeWithComparator(lower, lowerType, upper, upperType, irs.comparator)
        return irs.WithAdd(rangeToAdd)
}</span>

// Remove returns an error as ImmutableRangeSet is immutable
// Remove logs an error and returns as ImmutableRangeSet is immutable
func (irs *ImmutableRangeSet[T]) Remove(rangeToRemove Range[T]) <span class="cov0" title="0">{
        err := common.ImmutableOperationError("Remove", "WithRemove()")
        log.Printf("Warning: %v", err)
}</span>

// WithRemove returns a new ImmutableRangeSet with the range removed
func (irs *ImmutableRangeSet[T]) WithRemove(rangeToRemove Range[T]) RangeSet[T] <span class="cov0" title="0">{
        if rangeToRemove == nil || rangeToRemove.IsEmpty() </span><span class="cov0" title="0">{
                return irs
        }</span>
        
        // Create a mutable copy and remove the range
        <span class="cov0" title="0">mutableSet := NewTreeRangeSetWithComparator(irs.comparator)
        for _, r := range irs.ranges </span><span class="cov0" title="0">{
                mutableSet.Add(r)
        }</span>
        <span class="cov0" title="0">mutableSet.Remove(rangeToRemove)
        
        return &amp;ImmutableRangeSet[T]{
                ranges:     mutableSet.AsRanges(),
                comparator: irs.comparator,
        }</span>
}

// RemoveRange returns an error as ImmutableRangeSet is immutable
// RemoveRange logs an error and returns as ImmutableRangeSet is immutable
func (irs *ImmutableRangeSet[T]) RemoveRange(lower T, lowerType BoundType, upper T, upperType BoundType) <span class="cov0" title="0">{
        err := common.ImmutableOperationError("RemoveRange", "WithRemoveRange()")
        log.Printf("Warning: %v", err)
}</span>

// WithRemoveRange returns a new ImmutableRangeSet with the range removed
func (irs *ImmutableRangeSet[T]) WithRemoveRange(lower T, lowerType BoundType, upper T, upperType BoundType) RangeSet[T] <span class="cov0" title="0">{
        rangeToRemove := NewRangeWithComparator(lower, lowerType, upper, upperType, irs.comparator)
        return irs.WithRemove(rangeToRemove)
}</span>

// ContainsValue returns true if the value is contained in any range in this set
func (irs *ImmutableRangeSet[T]) ContainsValue(value T) bool <span class="cov0" title="0">{
        for _, r := range irs.ranges </span><span class="cov0" title="0">{
                if r.Contains(value) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ContainsRange returns true if the range is entirely contained in this set
func (irs *ImmutableRangeSet[T]) ContainsRange(rangeToCheck Range[T]) bool <span class="cov0" title="0">{
        if rangeToCheck == nil || rangeToCheck.IsEmpty() </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">for _, r := range irs.ranges </span><span class="cov0" title="0">{
                if r.ContainsRange(rangeToCheck) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Encloses returns true if this range set encloses the other range set
func (irs *ImmutableRangeSet[T]) Encloses(other RangeSet[T]) bool <span class="cov0" title="0">{
        if other == nil || other.IsEmpty() </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">otherRanges := other.AsRanges()
        for _, r := range otherRanges </span><span class="cov0" title="0">{
                if !irs.ContainsRange(r) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// AsRanges returns a view of the disconnected ranges that make up this range set
func (irs *ImmutableRangeSet[T]) AsRanges() []Range[T] <span class="cov0" title="0">{
        result := make([]Range[T], len(irs.ranges))
        copy(result, irs.ranges)
        return result
}</span>

// Complement returns the complement of this range set
func (irs *ImmutableRangeSet[T]) Complement() RangeSet[T] <span class="cov0" title="0">{
        // Create a mutable set to compute complement
        mutableSet := NewTreeRangeSetWithComparator(irs.comparator)
        for _, r := range irs.ranges </span><span class="cov0" title="0">{
                mutableSet.Add(r)
        }</span>
        
        <span class="cov0" title="0">complement := mutableSet.Complement()
        return &amp;ImmutableRangeSet[T]{
                ranges:     complement.AsRanges(),
                comparator: irs.comparator,
        }</span>
}

// Union returns the union of this range set with another
func (irs *ImmutableRangeSet[T]) Union(other RangeSet[T]) RangeSet[T] <span class="cov0" title="0">{
        // Create a mutable set to compute union
        mutableSet := NewTreeRangeSetWithComparator(irs.comparator)
        
        // Add all ranges from this set
        for _, r := range irs.ranges </span><span class="cov0" title="0">{
                mutableSet.Add(r)
        }</span>
        
        // Add all ranges from other set
        <span class="cov0" title="0">for _, r := range other.AsRanges() </span><span class="cov0" title="0">{
                mutableSet.Add(r)
        }</span>
        
        <span class="cov0" title="0">return &amp;ImmutableRangeSet[T]{
                ranges:     mutableSet.AsRanges(),
                comparator: irs.comparator,
        }</span>
}

// Intersection returns the intersection of this range set with another
func (irs *ImmutableRangeSet[T]) Intersection(other RangeSet[T]) RangeSet[T] <span class="cov0" title="0">{
        result := NewTreeRangeSetWithComparator(irs.comparator)
        
        otherRanges := other.AsRanges()
        
        for _, thisRange := range irs.ranges </span><span class="cov0" title="0">{
                for _, otherRange := range otherRanges </span><span class="cov0" title="0">{
                        intersection := thisRange.Intersection(otherRange)
                        if !intersection.IsEmpty() </span><span class="cov0" title="0">{
                                result.Add(intersection)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return &amp;ImmutableRangeSet[T]{
                ranges:     result.AsRanges(),
                comparator: irs.comparator,
        }</span>
}

// Difference returns the difference of this range set with another
func (irs *ImmutableRangeSet[T]) Difference(other RangeSet[T]) RangeSet[T] <span class="cov0" title="0">{
        // Create a mutable set to compute difference
        mutableSet := NewTreeRangeSetWithComparator(irs.comparator)
        
        // Start with all ranges from this set
        for _, r := range irs.ranges </span><span class="cov0" title="0">{
                mutableSet.Add(r)
        }</span>
        
        // Remove all ranges from other set
        <span class="cov0" title="0">for _, r := range other.AsRanges() </span><span class="cov0" title="0">{
                mutableSet.Remove(r)
        }</span>
        
        <span class="cov0" title="0">return &amp;ImmutableRangeSet[T]{
                ranges:     mutableSet.AsRanges(),
                comparator: irs.comparator,
        }</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">// Package range provides range-based collection implementations similar to Guava's Range collections
package ranges

import (
        "fmt"
        "log"
)

// BoundType represents the type of bound (open or closed)
type BoundType int

const (
        Open   BoundType = iota // (value) - exclusive
        Closed                  // [value] - inclusive
)

// Range represents a contiguous span of values of some Comparable type
type Range[T comparable] interface {
        // LowerBound returns the lower bound of this range
        LowerBound() (T, BoundType, bool)
        
        // UpperBound returns the upper bound of this range
        UpperBound() (T, BoundType, bool)
        
        // Contains returns true if the value is within this range
        Contains(value T) bool
        
        // ContainsRange returns true if the other range is entirely contained within this range
        ContainsRange(other Range[T]) bool
        
        // IsConnected returns true if there exists a (possibly empty) range which is
        // enclosed by both this range and other
        IsConnected(other Range[T]) bool
        
        // Intersection returns the maximal range enclosed by both this range and other
        // Returns nil if no such range exists
        Intersection(other Range[T]) Range[T]
        
        // Span returns the minimal range that encloses both this range and other
        Span(other Range[T]) Range[T]
        
        // IsEmpty returns true if this range is empty
        IsEmpty() bool
        
        // String returns the string representation of this range
        String() string
}

// RangeSet represents a set of non-empty, disconnected ranges
type RangeSet[T comparable] interface {
        // Size returns the number of ranges in this set
        Size() int
        
        // IsEmpty returns true if this range set is empty
        IsEmpty() bool
        
        // Clear removes all ranges from this set
        Clear()
        
        // String returns the string representation of this range set
        String() string
        
        // Add adds a range to this range set
        Add(rangeToAdd Range[T])
        
        // AddRange adds a range defined by bounds to this range set
        AddRange(lower T, lowerType BoundType, upper T, upperType BoundType)
        
        // Remove removes a range from this range set
        Remove(rangeToRemove Range[T])
        
        // RemoveRange removes a range defined by bounds from this range set
        RemoveRange(lower T, lowerType BoundType, upper T, upperType BoundType)
        
        // ContainsValue returns true if the value is contained in any range in this set
        ContainsValue(value T) bool
        
        // ContainsRange returns true if the range is entirely contained in this set
        ContainsRange(rangeToCheck Range[T]) bool
        
        // Encloses returns true if this range set encloses the other range set
        Encloses(other RangeSet[T]) bool
        
        // AsRanges returns a view of the disconnected ranges that make up this range set
        AsRanges() []Range[T]
        
        // Complement returns the complement of this range set
        Complement() RangeSet[T]
        
        // Union returns the union of this range set with another
        Union(other RangeSet[T]) RangeSet[T]
        
        // Intersection returns the intersection of this range set with another
        Intersection(other RangeSet[T]) RangeSet[T]
        
        // Difference returns the difference of this range set with another
        Difference(other RangeSet[T]) RangeSet[T]
}

// RangeMap represents a mapping from disjoint nonempty ranges to non-null values
type RangeMap[K comparable, V any] interface {
        // Size returns the number of range-value mappings in this map
        Size() int
        
        // IsEmpty returns true if this range map is empty
        IsEmpty() bool
        
        // Clear removes all mappings from this range map
        Clear()
        
        // String returns the string representation of this range map
        String() string
        
        // Get returns the value associated with the specified key, or nil if no such value exists
        Get(key K) (V, bool)
        
        // GetEntry returns the range-value entry containing the specified key, or nil if no such entry exists
        GetEntry(key K) (Range[K], V, bool)
        
        // Put associates the specified value with the specified range
        Put(rangeKey Range[K], value V)
        
        // PutRange associates the specified value with the specified range defined by bounds
        PutRange(lower K, lowerType BoundType, upper K, upperType BoundType, value V)
        
        // Remove removes all associations from this range map in the specified range
        Remove(rangeToRemove Range[K])
        
        // RemoveRange removes all associations from this range map in the specified range defined by bounds
        RemoveRange(lower K, lowerType BoundType, upper K, upperType BoundType)
        
        // AsMapOfRanges returns a view of this range map as a Map&lt;Range&lt;K&gt;, V&gt;
        AsMapOfRanges() map[Range[K]]V
        
        // AsDescendingMapOfRanges returns a view of this range map as a descending Map&lt;Range&lt;K&gt;, V&gt;
        AsDescendingMapOfRanges() map[Range[K]]V
        
        // Span returns the minimal range enclosing the ranges in this RangeMap
        Span() (Range[K], bool)
        
        // SubRangeMap returns a view of the portion of this range map that intersects with range
        SubRangeMap(range_ Range[K]) RangeMap[K, V]
}

// Entry represents a range-value pair in a RangeMap
type Entry[K comparable, V any] struct {
        Range Range[K]
        Value V
}

// String returns the string representation of this entry
func (e Entry[K, V]) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s=%v", e.Range.String(), e.Value)
}</span>

// Comparator function type for comparing values
type Comparator[T any] func(a, b T) int

// DefaultComparator provides a default comparison function for comparable types
func DefaultComparator[T comparable](a, b T) int <span class="cov8" title="1">{
        switch any(a).(type) </span>{
        case int:<span class="cov8" title="1">
                aInt, bInt := any(a).(int), any(b).(int)
                if aInt &lt; bInt </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if aInt &gt; bInt </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        case int8:<span class="cov0" title="0">
                aInt, bInt := any(a).(int8), any(b).(int8)
                if aInt &lt; bInt </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aInt &gt; bInt </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int16:<span class="cov0" title="0">
                aInt, bInt := any(a).(int16), any(b).(int16)
                if aInt &lt; bInt </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aInt &gt; bInt </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int32:<span class="cov0" title="0">
                aInt, bInt := any(a).(int32), any(b).(int32)
                if aInt &lt; bInt </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aInt &gt; bInt </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case int64:<span class="cov0" title="0">
                aInt, bInt := any(a).(int64), any(b).(int64)
                if aInt &lt; bInt </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aInt &gt; bInt </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint:<span class="cov0" title="0">
                aInt, bInt := any(a).(uint), any(b).(uint)
                if aInt &lt; bInt </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aInt &gt; bInt </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint8:<span class="cov0" title="0">
                aInt, bInt := any(a).(uint8), any(b).(uint8)
                if aInt &lt; bInt </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aInt &gt; bInt </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint16:<span class="cov0" title="0">
                aInt, bInt := any(a).(uint16), any(b).(uint16)
                if aInt &lt; bInt </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aInt &gt; bInt </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint32:<span class="cov0" title="0">
                aInt, bInt := any(a).(uint32), any(b).(uint32)
                if aInt &lt; bInt </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aInt &gt; bInt </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case uint64:<span class="cov0" title="0">
                aInt, bInt := any(a).(uint64), any(b).(uint64)
                if aInt &lt; bInt </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aInt &gt; bInt </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case float32:<span class="cov0" title="0">
                aFloat, bFloat := any(a).(float32), any(b).(float32)
                if aFloat &lt; bFloat </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aFloat &gt; bFloat </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case float64:<span class="cov0" title="0">
                aFloat, bFloat := any(a).(float64), any(b).(float64)
                if aFloat &lt; bFloat </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aFloat &gt; bFloat </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case string:<span class="cov0" title="0">
                aStr, bStr := any(a).(string), any(b).(string)
                if aStr &lt; bStr </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aStr &gt; bStr </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        default:<span class="cov0" title="0">
                // For other types, we can't provide a meaningful comparison
                // This should be handled by providing a custom comparator
                log.Printf("Warning: no default comparator available for type %T", a)
                return 0</span> // Return 0 to indicate equality as fallback
        }
}</pre>
		
		<pre class="file" id="file26" style="display: none">package ranges

import (
        "fmt"
)

// rangeImpl is the concrete implementation of Range
type rangeImpl[T comparable] struct {
        hasLowerBound bool
        lowerBound    T
        lowerType     BoundType
        hasUpperBound bool
        upperBound    T
        upperType     BoundType
        comparator    Comparator[T]
}

// NewRange creates a new range with the specified bounds
func NewRange[T comparable](lower T, lowerType BoundType, upper T, upperType BoundType) Range[T] <span class="cov8" title="1">{
        return NewRangeWithComparator(lower, lowerType, upper, upperType, DefaultComparator[T])
}</span>

// NewRangeWithComparator creates a new range with the specified bounds and comparator
func NewRangeWithComparator[T comparable](lower T, lowerType BoundType, upper T, upperType BoundType, cmp Comparator[T]) Range[T] <span class="cov8" title="1">{
        return &amp;rangeImpl[T]{
                hasLowerBound: true,
                lowerBound:    lower,
                lowerType:     lowerType,
                hasUpperBound: true,
                upperBound:    upper,
                upperType:     upperType,
                comparator:    cmp,
        }
}</span>

// OpenRange creates an open range (lower, upper)
func OpenRange[T comparable](lower, upper T) Range[T] <span class="cov8" title="1">{
        return NewRange(lower, Open, upper, Open)
}</span>

// ClosedRange creates a closed range [lower, upper]
func ClosedRange[T comparable](lower, upper T) Range[T] <span class="cov8" title="1">{
        return NewRange(lower, Closed, upper, Closed)
}</span>

// OpenClosed creates a range (lower, upper]
func OpenClosed[T comparable](lower, upper T) Range[T] <span class="cov0" title="0">{
        return NewRange(lower, Open, upper, Closed)
}</span>

// ClosedOpen creates a range [lower, upper)
func ClosedOpen[T comparable](lower, upper T) Range[T] <span class="cov0" title="0">{
        return NewRange(lower, Closed, upper, Open)
}</span>

// GreaterThan creates a range (lower, +)
func GreaterThan[T comparable](lower T) Range[T] <span class="cov0" title="0">{
        return &amp;rangeImpl[T]{
                hasLowerBound: true,
                lowerBound:    lower,
                lowerType:     Open,
                hasUpperBound: false,
                comparator:    DefaultComparator[T],
        }
}</span>

// AtLeast creates a range [lower, +)
func AtLeast[T comparable](lower T) Range[T] <span class="cov0" title="0">{
        return &amp;rangeImpl[T]{
                hasLowerBound: true,
                lowerBound:    lower,
                lowerType:     Closed,
                hasUpperBound: false,
                comparator:    DefaultComparator[T],
        }
}</span>

// LessThan creates a range (-, upper)
func LessThan[T comparable](upper T) Range[T] <span class="cov0" title="0">{
        return &amp;rangeImpl[T]{
                hasLowerBound: false,
                hasUpperBound: true,
                upperBound:    upper,
                upperType:     Open,
                comparator:    DefaultComparator[T],
        }
}</span>

// AtMost creates a range (-, upper]
func AtMost[T comparable](upper T) Range[T] <span class="cov0" title="0">{
        return &amp;rangeImpl[T]{
                hasLowerBound: false,
                hasUpperBound: true,
                upperBound:    upper,
                upperType:     Closed,
                comparator:    DefaultComparator[T],
        }
}</span>

// All creates a range (-, +)
func All[T comparable]() Range[T] <span class="cov0" title="0">{
        return &amp;rangeImpl[T]{
                hasLowerBound: false,
                hasUpperBound: false,
                comparator:    DefaultComparator[T],
        }
}</span>

// Singleton creates a range [value, value]
func Singleton[T comparable](value T) Range[T] <span class="cov8" title="1">{
        return ClosedRange(value, value)
}</span>

// LowerBound returns the lower bound of this range
func (r *rangeImpl[T]) LowerBound() (T, BoundType, bool) <span class="cov8" title="1">{
        return r.lowerBound, r.lowerType, r.hasLowerBound
}</span>

// UpperBound returns the upper bound of this range
func (r *rangeImpl[T]) UpperBound() (T, BoundType, bool) <span class="cov8" title="1">{
        return r.upperBound, r.upperType, r.hasUpperBound
}</span>

// Contains returns true if the value is within this range
func (r *rangeImpl[T]) Contains(value T) bool <span class="cov8" title="1">{
        if r.hasLowerBound </span><span class="cov8" title="1">{
                cmp := r.comparator(value, r.lowerBound)
                if cmp &lt; 0 || (cmp == 0 &amp;&amp; r.lowerType == Open) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        <span class="cov8" title="1">if r.hasUpperBound </span><span class="cov8" title="1">{
                cmp := r.comparator(value, r.upperBound)
                if cmp &gt; 0 || (cmp == 0 &amp;&amp; r.upperType == Open) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        
        <span class="cov8" title="1">return true</span>
}

// ContainsRange returns true if the other range is entirely contained within this range
func (r *rangeImpl[T]) ContainsRange(other Range[T]) bool <span class="cov8" title="1">{
        if other.IsEmpty() </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check lower bound
        <span class="cov8" title="1">if lowerBound, lowerType, hasLower := other.LowerBound(); hasLower </span><span class="cov8" title="1">{
                if !r.Contains(lowerBound) </span><span class="cov0" title="0">{
                        return false
                }</span>
                // If other has a closed lower bound and this range has the same bound but open, it's not contained
                <span class="cov8" title="1">if r.hasLowerBound &amp;&amp; r.comparator(lowerBound, r.lowerBound) == 0 </span><span class="cov0" title="0">{
                        if lowerType == Closed &amp;&amp; r.lowerType == Open </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        
        // Check upper bound
        <span class="cov8" title="1">if upperBound, upperType, hasUpper := other.UpperBound(); hasUpper </span><span class="cov8" title="1">{
                if !r.Contains(upperBound) </span><span class="cov0" title="0">{
                        return false
                }</span>
                // If other has a closed upper bound and this range has the same bound but open, it's not contained
                <span class="cov8" title="1">if r.hasUpperBound &amp;&amp; r.comparator(upperBound, r.upperBound) == 0 </span><span class="cov0" title="0">{
                        if upperType == Closed &amp;&amp; r.upperType == Open </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return true</span>
}

// IsConnected returns true if there exists a (possibly empty) range which is
// enclosed by both this range and other
func (r *rangeImpl[T]) IsConnected(other Range[T]) bool <span class="cov8" title="1">{
        // Two ranges are connected if they overlap or are adjacent
        return !r.Intersection(other).IsEmpty() || r.isAdjacent(other)
}</span>

// isAdjacent checks if two ranges are adjacent (touching but not overlapping)
func (r *rangeImpl[T]) isAdjacent(other Range[T]) bool <span class="cov0" title="0">{
        otherImpl, ok := other.(*rangeImpl[T])
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check if r's upper bound touches other's lower bound
        <span class="cov0" title="0">if r.hasUpperBound &amp;&amp; otherImpl.hasLowerBound </span><span class="cov0" title="0">{
                cmp := r.comparator(r.upperBound, otherImpl.lowerBound)
                if cmp == 0 &amp;&amp; (r.upperType == Closed || otherImpl.lowerType == Closed) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        // Check if other's upper bound touches r's lower bound
        <span class="cov0" title="0">if otherImpl.hasUpperBound &amp;&amp; r.hasLowerBound </span><span class="cov0" title="0">{
                cmp := r.comparator(otherImpl.upperBound, r.lowerBound)
                if cmp == 0 &amp;&amp; (otherImpl.upperType == Closed || r.lowerType == Closed) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

// Intersection returns the maximal range enclosed by both this range and other
func (r *rangeImpl[T]) Intersection(other Range[T]) Range[T] <span class="cov8" title="1">{
        otherImpl, ok := other.(*rangeImpl[T])
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Calculate intersection bounds
        <span class="cov8" title="1">var lowerBound T
        var lowerType BoundType
        var hasLower bool
        
        var upperBound T
        var upperType BoundType
        var hasUpper bool
        
        // Lower bound of intersection
        if !r.hasLowerBound &amp;&amp; !otherImpl.hasLowerBound </span><span class="cov0" title="0">{
                hasLower = false
        }</span> else<span class="cov8" title="1"> if !r.hasLowerBound </span><span class="cov0" title="0">{
                lowerBound = otherImpl.lowerBound
                lowerType = otherImpl.lowerType
                hasLower = true
        }</span> else<span class="cov8" title="1"> if !otherImpl.hasLowerBound </span><span class="cov0" title="0">{
                lowerBound = r.lowerBound
                lowerType = r.lowerType
                hasLower = true
        }</span> else<span class="cov8" title="1"> {
                cmp := r.comparator(r.lowerBound, otherImpl.lowerBound)
                if cmp &gt; 0 </span><span class="cov0" title="0">{
                        lowerBound = r.lowerBound
                        lowerType = r.lowerType
                }</span> else<span class="cov8" title="1"> if cmp &lt; 0 </span><span class="cov8" title="1">{
                        lowerBound = otherImpl.lowerBound
                        lowerType = otherImpl.lowerType
                }</span> else<span class="cov0" title="0"> {
                        // Same bound, use the more restrictive type
                        lowerBound = r.lowerBound
                        if r.lowerType == Open || otherImpl.lowerType == Open </span><span class="cov0" title="0">{
                                lowerType = Open
                        }</span> else<span class="cov0" title="0"> {
                                lowerType = Closed
                        }</span>
                }
                <span class="cov8" title="1">hasLower = true</span>
        }
        
        // Upper bound of intersection
        <span class="cov8" title="1">if !r.hasUpperBound &amp;&amp; !otherImpl.hasUpperBound </span><span class="cov0" title="0">{
                hasUpper = false
        }</span> else<span class="cov8" title="1"> if !r.hasUpperBound </span><span class="cov0" title="0">{
                upperBound = otherImpl.upperBound
                upperType = otherImpl.upperType
                hasUpper = true
        }</span> else<span class="cov8" title="1"> if !otherImpl.hasUpperBound </span><span class="cov0" title="0">{
                upperBound = r.upperBound
                upperType = r.upperType
                hasUpper = true
        }</span> else<span class="cov8" title="1"> {
                cmp := r.comparator(r.upperBound, otherImpl.upperBound)
                if cmp &lt; 0 </span><span class="cov8" title="1">{
                        upperBound = r.upperBound
                        upperType = r.upperType
                }</span> else<span class="cov0" title="0"> if cmp &gt; 0 </span><span class="cov0" title="0">{
                        upperBound = otherImpl.upperBound
                        upperType = otherImpl.upperType
                }</span> else<span class="cov0" title="0"> {
                        // Same bound, use the more restrictive type
                        upperBound = r.upperBound
                        if r.upperType == Open || otherImpl.upperType == Open </span><span class="cov0" title="0">{
                                upperType = Open
                        }</span> else<span class="cov0" title="0"> {
                                upperType = Closed
                        }</span>
                }
                <span class="cov8" title="1">hasUpper = true</span>
        }
        
        // Check if the intersection is valid
        <span class="cov8" title="1">if hasLower &amp;&amp; hasUpper </span><span class="cov8" title="1">{
                cmp := r.comparator(lowerBound, upperBound)
                if cmp &gt; 0 || (cmp == 0 &amp;&amp; (lowerType == Open || upperType == Open)) </span><span class="cov0" title="0">{
                        // Empty intersection
                        return &amp;rangeImpl[T]{
                                hasLowerBound: true,
                                lowerBound:    lowerBound,
                                lowerType:     Open,
                                hasUpperBound: true,
                                upperBound:    lowerBound,
                                upperType:     Open,
                                comparator:    r.comparator,
                        }
                }</span>
        }
        
        <span class="cov8" title="1">result := &amp;rangeImpl[T]{
                hasLowerBound: hasLower,
                hasUpperBound: hasUpper,
                comparator:    r.comparator,
        }
        
        if hasLower </span><span class="cov8" title="1">{
                result.lowerBound = lowerBound
                result.lowerType = lowerType
        }</span>
        
        <span class="cov8" title="1">if hasUpper </span><span class="cov8" title="1">{
                result.upperBound = upperBound
                result.upperType = upperType
        }</span>
        
        <span class="cov8" title="1">return result</span>
}

// Span returns the minimal range that encloses both this range and other
func (r *rangeImpl[T]) Span(other Range[T]) Range[T] <span class="cov0" title="0">{
        otherImpl, ok := other.(*rangeImpl[T])
        if !ok </span><span class="cov0" title="0">{
                return r
        }</span>
        
        // Calculate span bounds
        <span class="cov0" title="0">var lowerBound T
        var lowerType BoundType
        var hasLower bool
        
        var upperBound T
        var upperType BoundType
        var hasUpper bool
        
        // Lower bound of span
        if !r.hasLowerBound || !otherImpl.hasLowerBound </span><span class="cov0" title="0">{
                hasLower = false
        }</span> else<span class="cov0" title="0"> {
                cmp := r.comparator(r.lowerBound, otherImpl.lowerBound)
                if cmp &lt; 0 </span><span class="cov0" title="0">{
                        lowerBound = r.lowerBound
                        lowerType = r.lowerType
                }</span> else<span class="cov0" title="0"> if cmp &gt; 0 </span><span class="cov0" title="0">{
                        lowerBound = otherImpl.lowerBound
                        lowerType = otherImpl.lowerType
                }</span> else<span class="cov0" title="0"> {
                        // Same bound, use the less restrictive type
                        lowerBound = r.lowerBound
                        if r.lowerType == Closed || otherImpl.lowerType == Closed </span><span class="cov0" title="0">{
                                lowerType = Closed
                        }</span> else<span class="cov0" title="0"> {
                                lowerType = Open
                        }</span>
                }
                <span class="cov0" title="0">hasLower = true</span>
        }
        
        // Upper bound of span
        <span class="cov0" title="0">if !r.hasUpperBound || !otherImpl.hasUpperBound </span><span class="cov0" title="0">{
                hasUpper = false
        }</span> else<span class="cov0" title="0"> {
                cmp := r.comparator(r.upperBound, otherImpl.upperBound)
                if cmp &gt; 0 </span><span class="cov0" title="0">{
                        upperBound = r.upperBound
                        upperType = r.upperType
                }</span> else<span class="cov0" title="0"> if cmp &lt; 0 </span><span class="cov0" title="0">{
                        upperBound = otherImpl.upperBound
                        upperType = otherImpl.upperType
                }</span> else<span class="cov0" title="0"> {
                        // Same bound, use the less restrictive type
                        upperBound = r.upperBound
                        if r.upperType == Closed || otherImpl.upperType == Closed </span><span class="cov0" title="0">{
                                upperType = Closed
                        }</span> else<span class="cov0" title="0"> {
                                upperType = Open
                        }</span>
                }
                <span class="cov0" title="0">hasUpper = true</span>
        }
        
        <span class="cov0" title="0">result := &amp;rangeImpl[T]{
                hasLowerBound: hasLower,
                hasUpperBound: hasUpper,
                comparator:    r.comparator,
        }
        
        if hasLower </span><span class="cov0" title="0">{
                result.lowerBound = lowerBound
                result.lowerType = lowerType
        }</span>
        
        <span class="cov0" title="0">if hasUpper </span><span class="cov0" title="0">{
                result.upperBound = upperBound
                result.upperType = upperType
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// IsEmpty returns true if this range is empty
func (r *rangeImpl[T]) IsEmpty() bool <span class="cov8" title="1">{
        if !r.hasLowerBound || !r.hasUpperBound </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">cmp := r.comparator(r.lowerBound, r.upperBound)
        return cmp &gt; 0 || (cmp == 0 &amp;&amp; (r.lowerType == Open || r.upperType == Open))</span>
}

// String returns the string representation of this range
func (r *rangeImpl[T]) String() string <span class="cov0" title="0">{
        if r.IsEmpty() </span><span class="cov0" title="0">{
                return "(empty)"
        }</span>
        
        <span class="cov0" title="0">var result string
        
        // Lower bound
        if !r.hasLowerBound </span><span class="cov0" title="0">{
                result += "(-"
        }</span> else<span class="cov0" title="0"> {
                if r.lowerType == Closed </span><span class="cov0" title="0">{
                        result += fmt.Sprintf("[%v", r.lowerBound)
                }</span> else<span class="cov0" title="0"> {
                        result += fmt.Sprintf("(%v", r.lowerBound)
                }</span>
        }
        
        <span class="cov0" title="0">result += ".."
        
        // Upper bound
        if !r.hasUpperBound </span><span class="cov0" title="0">{
                result += "+)"
        }</span> else<span class="cov0" title="0"> {
                if r.upperType == Closed </span><span class="cov0" title="0">{
                        result += fmt.Sprintf("%v]", r.upperBound)
                }</span> else<span class="cov0" title="0"> {
                        result += fmt.Sprintf("%v)", r.upperBound)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}</pre>
		
		<pre class="file" id="file27" style="display: none">package ranges

import (
        "sort"
        "strings"
        "sync"
)

// TreeRangeMap is a mutable implementation of RangeMap backed by a tree structure
type TreeRangeMap[K comparable, V any] struct {
        entries    []Entry[K, V]
        comparator Comparator[K]
        mutex      sync.RWMutex
}

// NewTreeRangeMap creates a new empty TreeRangeMap
func NewTreeRangeMap[K comparable, V any]() RangeMap[K, V] <span class="cov8" title="1">{
        return &amp;TreeRangeMap[K, V]{
                entries:    make([]Entry[K, V], 0),
                comparator: DefaultComparator[K],
        }
}</span>

// NewTreeRangeMapWithComparator creates a new TreeRangeMap with custom comparator
func NewTreeRangeMapWithComparator[K comparable, V any](cmp Comparator[K]) RangeMap[K, V] <span class="cov0" title="0">{
        return &amp;TreeRangeMap[K, V]{
                entries:    make([]Entry[K, V], 0),
                comparator: cmp,
        }
}</span>

// Size returns the number of range-value mappings in this map
func (trm *TreeRangeMap[K, V]) Size() int <span class="cov8" title="1">{
        trm.mutex.RLock()
        defer trm.mutex.RUnlock()
        return len(trm.entries)
}</span>

// IsEmpty returns true if this range map is empty
func (trm *TreeRangeMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        trm.mutex.RLock()
        defer trm.mutex.RUnlock()
        return len(trm.entries) == 0
}</span>

// Clear removes all mappings from this range map
func (trm *TreeRangeMap[K, V]) Clear() <span class="cov0" title="0">{
        trm.mutex.Lock()
        defer trm.mutex.Unlock()
        trm.entries = make([]Entry[K, V], 0)
}</span>

// String returns the string representation of this range map
func (trm *TreeRangeMap[K, V]) String() string <span class="cov0" title="0">{
        trm.mutex.RLock()
        defer trm.mutex.RUnlock()
        
        if len(trm.entries) == 0 </span><span class="cov0" title="0">{
                return "{}"
        }</span>
        
        <span class="cov0" title="0">var parts []string
        for _, entry := range trm.entries </span><span class="cov0" title="0">{
                parts = append(parts, entry.String())
        }</span>
        <span class="cov0" title="0">return "{" + strings.Join(parts, ", ") + "}"</span>
}

// Put associates the specified value with the specified range
func (trm *TreeRangeMap[K, V]) Put(rangeKey Range[K], value V) <span class="cov8" title="1">{
        if rangeKey == nil || rangeKey.IsEmpty() </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">trm.mutex.Lock()
        defer trm.mutex.Unlock()
        
        // Remove any overlapping ranges first
        trm.removeOverlapping(rangeKey)
        
        // Add the new entry
        entry := Entry[K, V]{
                Range: rangeKey,
                Value: value,
        }
        
        trm.entries = append(trm.entries, entry)
        trm.sortEntries()</span>
}

// PutRange associates the specified value with the specified range
func (trm *TreeRangeMap[K, V]) PutRange(lower K, lowerType BoundType, upper K, upperType BoundType, value V) <span class="cov0" title="0">{
        rangeKey := NewRangeWithComparator(lower, lowerType, upper, upperType, trm.comparator)
        trm.Put(rangeKey, value)
}</span>

// Get returns the value associated with the specified key, or nil if no such value exists
func (trm *TreeRangeMap[K, V]) Get(key K) (V, bool) <span class="cov8" title="1">{
        trm.mutex.RLock()
        defer trm.mutex.RUnlock()
        
        for _, entry := range trm.entries </span><span class="cov8" title="1">{
                if entry.Range.Contains(key) </span><span class="cov8" title="1">{
                        return entry.Value, true
                }</span>
        }
        
        <span class="cov8" title="1">var zero V
        return zero, false</span>
}

// GetEntry returns the range-value entry that contains the specified key
func (trm *TreeRangeMap[K, V]) GetEntry(key K) (Range[K], V, bool) <span class="cov0" title="0">{
        trm.mutex.RLock()
        defer trm.mutex.RUnlock()
        
        for _, entry := range trm.entries </span><span class="cov0" title="0">{
                if entry.Range.Contains(key) </span><span class="cov0" title="0">{
                        return entry.Range, entry.Value, true
                }</span>
        }
        
        <span class="cov0" title="0">var zeroV V
        var zeroR Range[K]
        return zeroR, zeroV, false</span>
}

// Remove removes all mappings from the specified range
func (trm *TreeRangeMap[K, V]) Remove(rangeToRemove Range[K]) <span class="cov0" title="0">{
        if rangeToRemove == nil || rangeToRemove.IsEmpty() </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">trm.mutex.Lock()
        defer trm.mutex.Unlock()
        
        var newEntries []Entry[K, V]
        
        for _, entry := range trm.entries </span><span class="cov0" title="0">{
                if !entry.Range.IsConnected(rangeToRemove) </span><span class="cov0" title="0">{
                        // No overlap, keep the entry
                        newEntries = append(newEntries, entry)
                }</span> else<span class="cov0" title="0"> if rangeToRemove.ContainsRange(entry.Range) </span><span class="cov0" title="0">{
                        // Range to remove completely contains the entry, remove it
                        continue</span>
                } else<span class="cov0" title="0"> {
                        // Partial overlap - split the range
                        splitRanges := trm.splitRange(entry.Range, rangeToRemove)
                        for _, splitRange := range splitRanges </span><span class="cov0" title="0">{
                                if !splitRange.IsEmpty() </span><span class="cov0" title="0">{
                                        newEntries = append(newEntries, Entry[K, V]{
                                                Range: splitRange,
                                                Value: entry.Value,
                                        })
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">trm.entries = newEntries
        trm.sortEntries()</span>
}

// RemoveRange removes all mappings from the specified range
func (trm *TreeRangeMap[K, V]) RemoveRange(lower K, lowerType BoundType, upper K, upperType BoundType) <span class="cov0" title="0">{
        rangeToRemove := NewRangeWithComparator(lower, lowerType, upper, upperType, trm.comparator)
        trm.Remove(rangeToRemove)
}</span>

// Span returns the minimal range that contains all ranges in this map
func (trm *TreeRangeMap[K, V]) Span() (Range[K], bool) <span class="cov0" title="0">{
        trm.mutex.RLock()
        defer trm.mutex.RUnlock()
        
        if len(trm.entries) == 0 </span><span class="cov0" title="0">{
                var zeroR Range[K]
                return zeroR, false
        }</span>
        
        <span class="cov0" title="0">if len(trm.entries) == 1 </span><span class="cov0" title="0">{
                return trm.entries[0].Range, true
        }</span>
        
        // Calculate the span of all ranges
        <span class="cov0" title="0">span := trm.entries[0].Range
        for i := 1; i &lt; len(trm.entries); i++ </span><span class="cov0" title="0">{
                span = span.Span(trm.entries[i].Range)
        }</span>
        
        <span class="cov0" title="0">return span, true</span>
}

// AsMapOfRanges returns a view of this range map as a map from ranges to values
func (trm *TreeRangeMap[K, V]) AsMapOfRanges() map[Range[K]]V <span class="cov0" title="0">{
        trm.mutex.RLock()
        defer trm.mutex.RUnlock()
        
        result := make(map[Range[K]]V)
        for _, entry := range trm.entries </span><span class="cov0" title="0">{
                result[entry.Range] = entry.Value
        }</span>
        <span class="cov0" title="0">return result</span>
}

// AsDescendingMapOfRanges returns a view of this range map as a map from ranges to values in descending order
func (trm *TreeRangeMap[K, V]) AsDescendingMapOfRanges() map[Range[K]]V <span class="cov0" title="0">{
        trm.mutex.RLock()
        defer trm.mutex.RUnlock()
        
        result := make(map[Range[K]]V)
        for i := len(trm.entries) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                entry := trm.entries[i]
                result[entry.Range] = entry.Value
        }</span>
        <span class="cov0" title="0">return result</span>
}

// SubRangeMap returns a view of the portion of this range map that intersects with the given range
func (trm *TreeRangeMap[K, V]) SubRangeMap(subRange Range[K]) RangeMap[K, V] <span class="cov0" title="0">{
        if subRange == nil || subRange.IsEmpty() </span><span class="cov0" title="0">{
                return NewTreeRangeMapWithComparator[K, V](trm.comparator)
        }</span>
        
        <span class="cov0" title="0">trm.mutex.RLock()
        defer trm.mutex.RUnlock()
        
        result := NewTreeRangeMapWithComparator[K, V](trm.comparator)
        
        for _, entry := range trm.entries </span><span class="cov0" title="0">{
                if entry.Range.IsConnected(subRange) </span><span class="cov0" title="0">{
                        intersection := entry.Range.Intersection(subRange)
                        if !intersection.IsEmpty() </span><span class="cov0" title="0">{
                                result.Put(intersection, entry.Value)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return result</span>
}

// Helper method to remove overlapping ranges
func (trm *TreeRangeMap[K, V]) removeOverlapping(rangeKey Range[K]) <span class="cov8" title="1">{
        var newEntries []Entry[K, V]
        
        for _, entry := range trm.entries </span><span class="cov0" title="0">{
                if !entry.Range.IsConnected(rangeKey) </span><span class="cov0" title="0">{
                        newEntries = append(newEntries, entry)
                }</span>
        }
        
        <span class="cov8" title="1">trm.entries = newEntries</span>
}

// Helper method to split a range by removing the overlapping part
func (trm *TreeRangeMap[K, V]) splitRange(original Range[K], toRemove Range[K]) []Range[K] <span class="cov0" title="0">{
        var result []Range[K]
        
        // If ranges don't overlap, return original
        if !original.IsConnected(toRemove) </span><span class="cov0" title="0">{
                return []Range[K]{original}
        }</span>
        
        // If toRemove completely contains original, return empty
        <span class="cov0" title="0">if toRemove.ContainsRange(original) </span><span class="cov0" title="0">{
                return []Range[K]{}
        }</span>
        
        // Get bounds of both ranges
        <span class="cov0" title="0">origLower, origLowerType, hasOrigLower := original.LowerBound()
        origUpper, origUpperType, hasOrigUpper := original.UpperBound()
        removeLower, removeLowerType, hasRemoveLower := toRemove.LowerBound()
        removeUpper, removeUpperType, hasRemoveUpper := toRemove.UpperBound()
        
        // Create left part (before the removal range)
        if hasOrigLower &amp;&amp; hasRemoveLower </span><span class="cov0" title="0">{
                cmp := trm.comparator(origLower, removeLower)
                if cmp &lt; 0 || (cmp == 0 &amp;&amp; origLowerType == Closed &amp;&amp; removeLowerType == Open) </span><span class="cov0" title="0">{
                        // There's a left part
                        var leftUpper K
                        var leftUpperType BoundType
                        
                        if removeLowerType == Closed </span><span class="cov0" title="0">{
                                leftUpper = removeLower
                                leftUpperType = Open
                        }</span> else<span class="cov0" title="0"> {
                                leftUpper = removeLower
                                leftUpperType = Closed
                        }</span>
                        
                        <span class="cov0" title="0">leftRange := NewRangeWithComparator(origLower, origLowerType, leftUpper, leftUpperType, trm.comparator)
                        if !leftRange.IsEmpty() </span><span class="cov0" title="0">{
                                result = append(result, leftRange)
                        }</span>
                }
        }
        
        // Create right part (after the removal range)
        <span class="cov0" title="0">if hasOrigUpper &amp;&amp; hasRemoveUpper </span><span class="cov0" title="0">{
                cmp := trm.comparator(removeUpper, origUpper)
                if cmp &lt; 0 || (cmp == 0 &amp;&amp; removeUpperType == Open &amp;&amp; origUpperType == Closed) </span><span class="cov0" title="0">{
                        // There's a right part
                        var rightLower K
                        var rightLowerType BoundType
                        
                        if removeUpperType == Closed </span><span class="cov0" title="0">{
                                rightLower = removeUpper
                                rightLowerType = Open
                        }</span> else<span class="cov0" title="0"> {
                                rightLower = removeUpper
                                rightLowerType = Closed
                        }</span>
                        
                        <span class="cov0" title="0">rightRange := NewRangeWithComparator(rightLower, rightLowerType, origUpper, origUpperType, trm.comparator)
                        if !rightRange.IsEmpty() </span><span class="cov0" title="0">{
                                result = append(result, rightRange)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return result</span>
}

// Helper method to compare two ranges for sorting
func (trm *TreeRangeMap[K, V]) compareRanges(a, b Range[K]) int <span class="cov0" title="0">{
        // Compare by lower bound first
        aLower, aLowerType, hasALower := a.LowerBound()
        bLower, bLowerType, hasBLower := b.LowerBound()
        
        if !hasALower &amp;&amp; !hasBLower </span><span class="cov0" title="0">{
                // Both unbounded below, compare upper bounds
                aUpper, aUpperType, hasAUpper := a.UpperBound()
                bUpper, bUpperType, hasBUpper := b.UpperBound()
                
                if !hasAUpper &amp;&amp; !hasBUpper </span><span class="cov0" title="0">{
                        return 0 // Both are (-, +)
                }</span> else<span class="cov0" title="0"> if !hasAUpper </span><span class="cov0" title="0">{
                        return 1 // a is (-, +), b is bounded above
                }</span> else<span class="cov0" title="0"> if !hasBUpper </span><span class="cov0" title="0">{
                        return -1 // a is bounded above, b is (-, +)
                }</span> else<span class="cov0" title="0"> {
                        cmp := trm.comparator(aUpper, bUpper)
                        if cmp != 0 </span><span class="cov0" title="0">{
                                return cmp
                        }</span>
                        // Same upper bound, compare types (Closed &lt; Open)
                        <span class="cov0" title="0">if aUpperType == Closed &amp;&amp; bUpperType == Open </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if aUpperType == Open &amp;&amp; bUpperType == Closed </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        } else<span class="cov0" title="0"> if !hasALower </span><span class="cov0" title="0">{
                return -1 // a is unbounded below, b is bounded
        }</span> else<span class="cov0" title="0"> if !hasBLower </span><span class="cov0" title="0">{
                return 1 // a is bounded below, b is unbounded
        }</span> else<span class="cov0" title="0"> {
                // Both have lower bounds
                cmp := trm.comparator(aLower, bLower)
                if cmp != 0 </span><span class="cov0" title="0">{
                        return cmp
                }</span>
                // Same lower bound, compare types (Closed &lt; Open)
                <span class="cov0" title="0">if aLowerType == Closed &amp;&amp; bLowerType == Open </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov0" title="0"> if aLowerType == Open &amp;&amp; bLowerType == Closed </span><span class="cov0" title="0">{
                        return 1
                }</span>
                
                // Lower bounds are identical, compare upper bounds
                <span class="cov0" title="0">aUpper, aUpperType, hasAUpper := a.UpperBound()
                bUpper, bUpperType, hasBUpper := b.UpperBound()
                
                if !hasAUpper &amp;&amp; !hasBUpper </span><span class="cov0" title="0">{
                        return 0 // Both are [x, +)
                }</span> else<span class="cov0" title="0"> if !hasAUpper </span><span class="cov0" title="0">{
                        return 1 // a is [x, +), b is [x, y]
                }</span> else<span class="cov0" title="0"> if !hasBUpper </span><span class="cov0" title="0">{
                        return -1 // a is [x, y], b is [x, +)
                }</span> else<span class="cov0" title="0"> {
                        cmp := trm.comparator(aUpper, bUpper)
                        if cmp != 0 </span><span class="cov0" title="0">{
                                return cmp
                        }</span>
                        // Same upper bound, compare types (Open &lt; Closed)
                        <span class="cov0" title="0">if aUpperType == Open &amp;&amp; bUpperType == Closed </span><span class="cov0" title="0">{
                                return -1
                        }</span> else<span class="cov0" title="0"> if aUpperType == Closed &amp;&amp; bUpperType == Open </span><span class="cov0" title="0">{
                                return 1
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }
        }
}

// Helper method to sort entries by range
func (trm *TreeRangeMap[K, V]) sortEntries() <span class="cov8" title="1">{
        sort.Slice(trm.entries, func(i, j int) bool </span><span class="cov0" title="0">{
                return trm.compareRanges(trm.entries[i].Range, trm.entries[j].Range) &lt; 0
        }</span>)
}</pre>
		
		<pre class="file" id="file28" style="display: none">package ranges

import (
        "sort"
        "strings"
        "sync"
)

// TreeRangeSet is a RangeSet implementation based on a TreeMap
// It maintains ranges in sorted order and provides efficient range operations
type TreeRangeSet[T comparable] struct {
        ranges     []Range[T]
        comparator Comparator[T]
        mutex      sync.RWMutex
}

// NewTreeRangeSet creates a new TreeRangeSet with default comparator
func NewTreeRangeSet[T comparable]() RangeSet[T] <span class="cov8" title="1">{
        return &amp;TreeRangeSet[T]{
                ranges:     make([]Range[T], 0),
                comparator: DefaultComparator[T],
        }
}</span>

// NewTreeRangeSetWithComparator creates a new TreeRangeSet with custom comparator
func NewTreeRangeSetWithComparator[T comparable](cmp Comparator[T]) RangeSet[T] <span class="cov0" title="0">{
        return &amp;TreeRangeSet[T]{
                ranges:     make([]Range[T], 0),
                comparator: cmp,
        }
}</span>

// Size returns the number of ranges in this set
func (ts *TreeRangeSet[T]) Size() int <span class="cov8" title="1">{
        ts.mutex.RLock()
        defer ts.mutex.RUnlock()
        return len(ts.ranges)
}</span>

// IsEmpty returns true if this range set is empty
func (ts *TreeRangeSet[T]) IsEmpty() bool <span class="cov8" title="1">{
        ts.mutex.RLock()
        defer ts.mutex.RUnlock()
        return len(ts.ranges) == 0
}</span>

// Clear removes all ranges from this set
func (ts *TreeRangeSet[T]) Clear() <span class="cov0" title="0">{
        ts.mutex.Lock()
        defer ts.mutex.Unlock()
        ts.ranges = ts.ranges[:0]
}</span>

// String returns the string representation of this range set
func (ts *TreeRangeSet[T]) String() string <span class="cov0" title="0">{
        ts.mutex.RLock()
        defer ts.mutex.RUnlock()
        
        if len(ts.ranges) == 0 </span><span class="cov0" title="0">{
                return "{}"
        }</span>
        
        <span class="cov0" title="0">var parts []string
        for _, r := range ts.ranges </span><span class="cov0" title="0">{
                parts = append(parts, r.String())
        }</span>
        <span class="cov0" title="0">return "{" + strings.Join(parts, ", ") + "}"</span>
}

// Add adds a range to this range set
func (ts *TreeRangeSet[T]) Add(rangeToAdd Range[T]) <span class="cov8" title="1">{
        if rangeToAdd == nil || rangeToAdd.IsEmpty() </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">ts.mutex.Lock()
        defer ts.mutex.Unlock()
        
        ts.addInternal(rangeToAdd)</span>
}

// AddRange adds a range defined by bounds to this range set
func (ts *TreeRangeSet[T]) AddRange(lower T, lowerType BoundType, upper T, upperType BoundType) <span class="cov0" title="0">{
        rangeToAdd := NewRangeWithComparator(lower, lowerType, upper, upperType, ts.comparator)
        ts.Add(rangeToAdd)
}</span>

// addInternal adds a range without locking (internal use)
func (ts *TreeRangeSet[T]) addInternal(rangeToAdd Range[T]) <span class="cov8" title="1">{
        if len(ts.ranges) == 0 </span><span class="cov8" title="1">{
                ts.ranges = append(ts.ranges, rangeToAdd)
                return
        }</span>
        
        // Find overlapping and adjacent ranges
        <span class="cov0" title="0">var toMerge []Range[T]
        var newRanges []Range[T]
        
        for _, existing := range ts.ranges </span><span class="cov0" title="0">{
                if existing.IsConnected(rangeToAdd) </span><span class="cov0" title="0">{
                        toMerge = append(toMerge, existing)
                }</span> else<span class="cov0" title="0"> {
                        newRanges = append(newRanges, existing)
                }</span>
        }
        
        // Merge all connected ranges
        <span class="cov0" title="0">merged := rangeToAdd
        for _, r := range toMerge </span><span class="cov0" title="0">{
                merged = merged.Span(r)
        }</span>
        
        // Insert the merged range in the correct position
        <span class="cov0" title="0">newRanges = append(newRanges, merged)
        ts.ranges = ts.sortRanges(newRanges)</span>
}

// Remove removes a range from this range set
func (ts *TreeRangeSet[T]) Remove(rangeToRemove Range[T]) <span class="cov0" title="0">{
        if rangeToRemove == nil || rangeToRemove.IsEmpty() </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">ts.mutex.Lock()
        defer ts.mutex.Unlock()
        
        ts.removeInternal(rangeToRemove)</span>
}

// RemoveRange removes a range defined by bounds from this range set
func (ts *TreeRangeSet[T]) RemoveRange(lower T, lowerType BoundType, upper T, upperType BoundType) <span class="cov0" title="0">{
        rangeToRemove := NewRangeWithComparator(lower, lowerType, upper, upperType, ts.comparator)
        ts.Remove(rangeToRemove)
}</span>

// removeInternal removes a range without locking (internal use)
func (ts *TreeRangeSet[T]) removeInternal(rangeToRemove Range[T]) <span class="cov0" title="0">{
        var newRanges []Range[T]
        
        for _, existing := range ts.ranges </span><span class="cov0" title="0">{
                intersection := existing.Intersection(rangeToRemove)
                if intersection.IsEmpty() </span><span class="cov0" title="0">{
                        // No intersection, keep the existing range
                        newRanges = append(newRanges, existing)
                }</span> else<span class="cov0" title="0"> {
                        // There's an intersection, we need to split the existing range
                        remainders := ts.subtractRange(existing, rangeToRemove)
                        newRanges = append(newRanges, remainders...)
                }</span>
        }
        
        <span class="cov0" title="0">ts.ranges = newRanges</span>
}

// subtractRange subtracts rangeToRemove from existing and returns the remaining ranges
func (ts *TreeRangeSet[T]) subtractRange(existing, rangeToRemove Range[T]) []Range[T] <span class="cov0" title="0">{
        var result []Range[T]
        
        existingLower, existingLowerType, hasExistingLower := existing.LowerBound()
        existingUpper, existingUpperType, hasExistingUpper := existing.UpperBound()
        removeLower, removeLowerType, hasRemoveLower := rangeToRemove.LowerBound()
        removeUpper, removeUpperType, hasRemoveUpper := rangeToRemove.UpperBound()
        
        // Left remainder: from existing lower to remove lower
        if hasExistingLower &amp;&amp; hasRemoveLower </span><span class="cov0" title="0">{
                cmp := ts.comparator(existingLower, removeLower)
                if cmp &lt; 0 || (cmp == 0 &amp;&amp; existingLowerType == Closed &amp;&amp; removeLowerType == Open) </span><span class="cov0" title="0">{
                        // Create left remainder
                        var upperType BoundType
                        if removeLowerType == Closed </span><span class="cov0" title="0">{
                                upperType = Open
                        }</span> else<span class="cov0" title="0"> {
                                upperType = Closed
                        }</span>
                        <span class="cov0" title="0">leftRange := &amp;rangeImpl[T]{
                                hasLowerBound: true,
                                lowerBound:    existingLower,
                                lowerType:     existingLowerType,
                                hasUpperBound: true,
                                upperBound:    removeLower,
                                upperType:     upperType,
                                comparator:    ts.comparator,
                        }
                        if !leftRange.IsEmpty() </span><span class="cov0" title="0">{
                                result = append(result, leftRange)
                        }</span>
                }
        } else<span class="cov0" title="0"> if hasExistingLower &amp;&amp; !hasRemoveLower </span>{<span class="cov0" title="0">
                // Remove range has no lower bound, so no left remainder
        }</span>
        
        // Right remainder: from remove upper to existing upper
        <span class="cov0" title="0">if hasExistingUpper &amp;&amp; hasRemoveUpper </span><span class="cov0" title="0">{
                cmp := ts.comparator(removeUpper, existingUpper)
                if cmp &lt; 0 || (cmp == 0 &amp;&amp; removeUpperType == Open &amp;&amp; existingUpperType == Closed) </span><span class="cov0" title="0">{
                        // Create right remainder
                        var lowerType BoundType
                        if removeUpperType == Closed </span><span class="cov0" title="0">{
                                lowerType = Open
                        }</span> else<span class="cov0" title="0"> {
                                lowerType = Closed
                        }</span>
                        <span class="cov0" title="0">rightRange := &amp;rangeImpl[T]{
                                hasLowerBound: true,
                                lowerBound:    removeUpper,
                                lowerType:     lowerType,
                                hasUpperBound: true,
                                upperBound:    existingUpper,
                                upperType:     existingUpperType,
                                comparator:    ts.comparator,
                        }
                        if !rightRange.IsEmpty() </span><span class="cov0" title="0">{
                                result = append(result, rightRange)
                        }</span>
                }
        } else<span class="cov0" title="0"> if hasExistingUpper &amp;&amp; !hasRemoveUpper </span>{<span class="cov0" title="0">
                // Remove range has no upper bound, so no right remainder
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// ContainsValue returns true if the value is contained in any range in this set
func (ts *TreeRangeSet[T]) ContainsValue(value T) bool <span class="cov8" title="1">{
        ts.mutex.RLock()
        defer ts.mutex.RUnlock()
        
        for _, r := range ts.ranges </span><span class="cov8" title="1">{
                if r.Contains(value) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ContainsRange returns true if the range is entirely contained in this set
func (ts *TreeRangeSet[T]) ContainsRange(rangeToCheck Range[T]) bool <span class="cov0" title="0">{
        if rangeToCheck == nil || rangeToCheck.IsEmpty() </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">ts.mutex.RLock()
        defer ts.mutex.RUnlock()
        
        for _, r := range ts.ranges </span><span class="cov0" title="0">{
                if r.ContainsRange(rangeToCheck) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Encloses returns true if this range set encloses the other range set
func (ts *TreeRangeSet[T]) Encloses(other RangeSet[T]) bool <span class="cov0" title="0">{
        if other == nil || other.IsEmpty() </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">otherRanges := other.AsRanges()
        for _, r := range otherRanges </span><span class="cov0" title="0">{
                if !ts.ContainsRange(r) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// AsRanges returns a view of the disconnected ranges that make up this range set
func (ts *TreeRangeSet[T]) AsRanges() []Range[T] <span class="cov0" title="0">{
        ts.mutex.RLock()
        defer ts.mutex.RUnlock()
        
        result := make([]Range[T], len(ts.ranges))
        copy(result, ts.ranges)
        return result
}</span>

// Complement returns the complement of this range set
func (ts *TreeRangeSet[T]) Complement() RangeSet[T] <span class="cov0" title="0">{
        ts.mutex.RLock()
        defer ts.mutex.RUnlock()
        
        complement := NewTreeRangeSetWithComparator(ts.comparator)
        
        if len(ts.ranges) == 0 </span><span class="cov0" title="0">{
                // If this set is empty, complement is all values
                complement.Add(All[T]())
                return complement
        }</span>
        
        // Add range from - to first range's lower bound
        <span class="cov0" title="0">firstRange := ts.ranges[0]
        if lower, lowerType, hasLower := firstRange.LowerBound(); hasLower </span><span class="cov0" title="0">{
                var upperType BoundType
                if lowerType == Closed </span><span class="cov0" title="0">{
                        upperType = Open
                }</span> else<span class="cov0" title="0"> {
                        upperType = Closed
                }</span>
                <span class="cov0" title="0">beforeFirst := &amp;rangeImpl[T]{
                        hasLowerBound: false,
                        hasUpperBound: true,
                        upperBound:    lower,
                        upperType:     upperType,
                        comparator:    ts.comparator,
                }
                if !beforeFirst.IsEmpty() </span><span class="cov0" title="0">{
                        complement.Add(beforeFirst)
                }</span>
        }
        
        // Add ranges between consecutive ranges
        <span class="cov0" title="0">for i := 0; i &lt; len(ts.ranges)-1; i++ </span><span class="cov0" title="0">{
                current := ts.ranges[i]
                next := ts.ranges[i+1]
                
                currentUpper, currentUpperType, hasCurrentUpper := current.UpperBound()
                nextLower, nextLowerType, hasNextLower := next.LowerBound()
                
                if hasCurrentUpper &amp;&amp; hasNextLower </span><span class="cov0" title="0">{
                        var lowerType, upperType BoundType
                        if currentUpperType == Closed </span><span class="cov0" title="0">{
                                lowerType = Open
                        }</span> else<span class="cov0" title="0"> {
                                lowerType = Closed
                        }</span>
                        <span class="cov0" title="0">if nextLowerType == Closed </span><span class="cov0" title="0">{
                                upperType = Open
                        }</span> else<span class="cov0" title="0"> {
                                upperType = Closed
                        }</span>
                        
                        <span class="cov0" title="0">between := &amp;rangeImpl[T]{
                                hasLowerBound: true,
                                lowerBound:    currentUpper,
                                lowerType:     lowerType,
                                hasUpperBound: true,
                                upperBound:    nextLower,
                                upperType:     upperType,
                                comparator:    ts.comparator,
                        }
                        if !between.IsEmpty() </span><span class="cov0" title="0">{
                                complement.Add(between)
                        }</span>
                }
        }
        
        // Add range from last range's upper bound to +
        <span class="cov0" title="0">lastRange := ts.ranges[len(ts.ranges)-1]
        if upper, upperType, hasUpper := lastRange.UpperBound(); hasUpper </span><span class="cov0" title="0">{
                var lowerType BoundType
                if upperType == Closed </span><span class="cov0" title="0">{
                        lowerType = Open
                }</span> else<span class="cov0" title="0"> {
                        lowerType = Closed
                }</span>
                <span class="cov0" title="0">afterLast := &amp;rangeImpl[T]{
                        hasLowerBound: true,
                        lowerBound:    upper,
                        lowerType:     lowerType,
                        hasUpperBound: false,
                        comparator:    ts.comparator,
                }
                if !afterLast.IsEmpty() </span><span class="cov0" title="0">{
                        complement.Add(afterLast)
                }</span>
        }
        
        <span class="cov0" title="0">return complement</span>
}

// Union returns the union of this range set with another
func (ts *TreeRangeSet[T]) Union(other RangeSet[T]) RangeSet[T] <span class="cov0" title="0">{
        result := NewTreeRangeSetWithComparator(ts.comparator)
        
        // Add all ranges from this set
        for _, r := range ts.AsRanges() </span><span class="cov0" title="0">{
                result.Add(r)
        }</span>
        
        // Add all ranges from other set
        <span class="cov0" title="0">for _, r := range other.AsRanges() </span><span class="cov0" title="0">{
                result.Add(r)
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// Intersection returns the intersection of this range set with another
func (ts *TreeRangeSet[T]) Intersection(other RangeSet[T]) RangeSet[T] <span class="cov0" title="0">{
        result := NewTreeRangeSetWithComparator(ts.comparator)
        
        thisRanges := ts.AsRanges()
        otherRanges := other.AsRanges()
        
        for _, thisRange := range thisRanges </span><span class="cov0" title="0">{
                for _, otherRange := range otherRanges </span><span class="cov0" title="0">{
                        intersection := thisRange.Intersection(otherRange)
                        if !intersection.IsEmpty() </span><span class="cov0" title="0">{
                                result.Add(intersection)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return result</span>
}

// Difference returns the difference of this range set with another
func (ts *TreeRangeSet[T]) Difference(other RangeSet[T]) RangeSet[T] <span class="cov0" title="0">{
        result := NewTreeRangeSetWithComparator(ts.comparator)
        
        // Start with all ranges from this set
        for _, r := range ts.AsRanges() </span><span class="cov0" title="0">{
                result.Add(r)
        }</span>
        
        // Remove all ranges from other set
        <span class="cov0" title="0">for _, r := range other.AsRanges() </span><span class="cov0" title="0">{
                result.Remove(r)
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// sortRanges sorts ranges by their lower bounds
func (ts *TreeRangeSet[T]) sortRanges(ranges []Range[T]) []Range[T] <span class="cov0" title="0">{
        sort.Slice(ranges, func(i, j int) bool </span><span class="cov0" title="0">{
                rangeI := ranges[i]
                rangeJ := ranges[j]
                
                lowerI, _, hasLowerI := rangeI.LowerBound()
                lowerJ, _, hasLowerJ := rangeJ.LowerBound()
                
                if !hasLowerI &amp;&amp; !hasLowerJ </span><span class="cov0" title="0">{
                        return false // Both unbounded, consider equal
                }</span>
                <span class="cov0" title="0">if !hasLowerI </span><span class="cov0" title="0">{
                        return true // Unbounded comes first
                }</span>
                <span class="cov0" title="0">if !hasLowerJ </span><span class="cov0" title="0">{
                        return false // Bounded comes after unbounded
                }</span>
                
                <span class="cov0" title="0">return ts.comparator(lowerI, lowerJ) &lt; 0</span>
        })
        
        <span class="cov0" title="0">return ranges</span>
}</pre>
		
		<pre class="file" id="file29" style="display: none">package set

import (
        "fmt"
        "math/rand"
        "strings"
        "sync"
        "time"

        "github.com/chenjianyu/collections/container/common"
)

const (
        maxLevels = 32
        p         = 0.25
)

// ConcurrentSkipListSet is a thread-safe set implementation based on skip list
// Elements are stored in sorted order
type ConcurrentSkipListSet[E comparable] struct {
        head       *skipListNode[E]
        comparator func(a, b E) int
        size       int
        mutex      sync.RWMutex
        rand       *rand.Rand
}

// skipListNode represents a node in the skip list
type skipListNode[E comparable] struct {
        value E
        next  []*skipListNode[E]
}

// NewConcurrentSkipListSet creates a new ConcurrentSkipListSet using default comparator
// Default comparator only supports int type
func NewConcurrentSkipListSet[E comparable]() *ConcurrentSkipListSet[E] <span class="cov8" title="1">{
        head := &amp;skipListNode[E]{
                next: make([]*skipListNode[E], maxLevels),
        }

        return &amp;ConcurrentSkipListSet[E]{
                head:       head,
                comparator: Compare[E],
                size:       0,
                rand:       rand.New(rand.NewSource(time.Now().UnixNano())),
        }
}</span>

// NewConcurrentSkipListSetWithComparator creates a ConcurrentSkipListSet with specified comparator
func NewConcurrentSkipListSetWithComparator[E comparable](comparator func(a, b E) int) *ConcurrentSkipListSet[E] <span class="cov8" title="1">{
        head := &amp;skipListNode[E]{
                next: make([]*skipListNode[E], maxLevels),
        }

        return &amp;ConcurrentSkipListSet[E]{
                head:       head,
                comparator: comparator,
                size:       0,
                rand:       rand.New(rand.NewSource(time.Now().UnixNano())),
        }
}</span>

// randomLevel generates a random level for new nodes
func (s *ConcurrentSkipListSet[E]) randomLevel() int <span class="cov8" title="1">{
        level := 1
        for s.rand.Float64() &lt; p &amp;&amp; level &lt; maxLevels </span><span class="cov8" title="1">{
                level++
        }</span>
        <span class="cov8" title="1">return level</span>
}

// findPredecessors finds the predecessors of the target value at each level
func (s *ConcurrentSkipListSet[E]) findPredecessors(target E) []*skipListNode[E] <span class="cov8" title="1">{
        predecessors := make([]*skipListNode[E], maxLevels)
        current := s.head

        for level := maxLevels - 1; level &gt;= 0; level-- </span><span class="cov8" title="1">{
                for current.next[level] != nil &amp;&amp; s.comparator(current.next[level].value, target) &lt; 0 </span><span class="cov8" title="1">{
                        current = current.next[level]
                }</span>
                <span class="cov8" title="1">predecessors[level] = current</span>
        }

        <span class="cov8" title="1">return predecessors</span>
}

// Add adds an element to the set
// Returns false if the set already contains the element, otherwise returns true
func (s *ConcurrentSkipListSet[E]) Add(element E) bool <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        predecessors := s.findPredecessors(element)

        // Check if element already exists
        if predecessors[0].next[0] != nil &amp;&amp; s.comparator(predecessors[0].next[0].value, element) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Create new node
        <span class="cov8" title="1">level := s.randomLevel()
        newNode := &amp;skipListNode[E]{
                value: element,
                next:  make([]*skipListNode[E], level),
        }

        // Insert the new node
        for i := 0; i &lt; level; i++ </span><span class="cov8" title="1">{
                newNode.next[i] = predecessors[i].next[i]
                predecessors[i].next[i] = newNode
        }</span>

        <span class="cov8" title="1">s.size++
        return true</span>
}

// Remove removes the specified element from the set
// Returns true if the set contained the element, otherwise returns false
func (s *ConcurrentSkipListSet[E]) Remove(element E) bool <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        predecessors := s.findPredecessors(element)

        // Check if element exists
        nodeToRemove := predecessors[0].next[0]
        if nodeToRemove == nil || s.comparator(nodeToRemove.value, element) != 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Remove the node from all levels
        <span class="cov8" title="1">for level := 0; level &lt; len(nodeToRemove.next); level++ </span><span class="cov8" title="1">{
                predecessors[level].next[level] = nodeToRemove.next[level]
        }</span>

        <span class="cov8" title="1">s.size--
        return true</span>
}

// Contains checks if the set contains the specified element
func (s *ConcurrentSkipListSet[E]) Contains(element E) bool <span class="cov8" title="1">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()

        current := s.head
        for level := maxLevels - 1; level &gt;= 0; level-- </span><span class="cov8" title="1">{
                for current.next[level] != nil &amp;&amp; s.comparator(current.next[level].value, element) &lt; 0 </span><span class="cov8" title="1">{
                        current = current.next[level]
                }</span>
        }

        <span class="cov8" title="1">next := current.next[0]
        return next != nil &amp;&amp; s.comparator(next.value, element) == 0</span>
}

// Size returns the number of elements in the set
func (s *ConcurrentSkipListSet[E]) Size() int <span class="cov8" title="1">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()
        return s.size
}</span>

// IsEmpty checks if the set is empty
func (s *ConcurrentSkipListSet[E]) IsEmpty() bool <span class="cov8" title="1">{
        return s.Size() == 0
}</span>

// Clear clears all elements from the set
func (s *ConcurrentSkipListSet[E]) Clear() <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        // Reset head node
        for i := 0; i &lt; maxLevels; i++ </span><span class="cov8" title="1">{
                s.head.next[i] = nil
        }</span>
        <span class="cov8" title="1">s.size = 0</span>
}

// ToSlice returns a slice containing all elements in the set
func (s *ConcurrentSkipListSet[E]) ToSlice() []E <span class="cov8" title="1">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()

        result := make([]E, 0, s.size)
        current := s.head.next[0]

        for current != nil </span><span class="cov8" title="1">{
                result = append(result, current.value)
                current = current.next[0]
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ForEach executes the given operation for each element in the set
func (s *ConcurrentSkipListSet[E]) ForEach(fn func(E)) <span class="cov8" title="1">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()

        current := s.head.next[0]
        for current != nil </span><span class="cov8" title="1">{
                fn(current.value)
                current = current.next[0]
        }</span>
}

// Union returns a new set containing all elements from this set and the other set
func (s *ConcurrentSkipListSet[E]) Union(other Set[E]) Set[E] <span class="cov8" title="1">{
        result := NewConcurrentSkipListSetWithComparator(s.comparator)
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                result.Add(element)
        }</span>)
        <span class="cov8" title="1">other.ForEach(func(element E) </span><span class="cov8" title="1">{
                result.Add(element)
        }</span>)
        <span class="cov8" title="1">return result</span>
}

// Intersection returns a new set containing elements that exist in both sets
func (s *ConcurrentSkipListSet[E]) Intersection(other Set[E]) Set[E] <span class="cov8" title="1">{
        result := NewConcurrentSkipListSetWithComparator(s.comparator)
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                if other.Contains(element) </span><span class="cov8" title="1">{
                        result.Add(element)
                }</span>
        })
        <span class="cov8" title="1">return result</span>
}

// Difference returns a new set containing elements that exist in this set but not in the other set
func (s *ConcurrentSkipListSet[E]) Difference(other Set[E]) Set[E] <span class="cov8" title="1">{
        result := NewConcurrentSkipListSetWithComparator(s.comparator)
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                if !other.Contains(element) </span><span class="cov8" title="1">{
                        result.Add(element)
                }</span>
        })
        <span class="cov8" title="1">return result</span>
}

// IsSubsetOf checks if this set is a subset of the other set
func (s *ConcurrentSkipListSet[E]) IsSubsetOf(other Set[E]) bool <span class="cov8" title="1">{
        if s.Size() &gt; other.Size() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">isSubset := true
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                if !other.Contains(element) </span><span class="cov0" title="0">{
                        isSubset = false
                }</span>
        })
        <span class="cov8" title="1">return isSubset</span>
}

// IsSupersetOf checks if this set is a superset of the other set
func (s *ConcurrentSkipListSet[E]) IsSupersetOf(other Set[E]) bool <span class="cov8" title="1">{
        return other.IsSubsetOf(s)
}</span>

// Iterator returns an iterator for the set
func (s *ConcurrentSkipListSet[E]) Iterator() common.Iterator[E] <span class="cov0" title="0">{
        s.mutex.RLock()
        defer s.mutex.RUnlock()

        elements := s.ToSlice()
        return &amp;concurrentSkipListSetIterator[E]{
                elements: elements,
                index:    0,
        }
}</span>

// concurrentSkipListSetIterator implements Iterator for ConcurrentSkipListSet
type concurrentSkipListSetIterator[E comparable] struct {
        elements []E
        index    int
}

// HasNext returns true if there are more elements to iterate
func (it *concurrentSkipListSetIterator[E]) HasNext() bool <span class="cov0" title="0">{
        return it.index &lt; len(it.elements)
}</span>

// Next returns the next element
func (it *concurrentSkipListSetIterator[E]) Next() (E, bool) <span class="cov0" title="0">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                var zero E
                return zero, false
        }</span>
        <span class="cov0" title="0">element := it.elements[it.index]
        it.index++
        return element, true</span>
}

// Remove removes the current element (not supported for concurrent collections)
func (it *concurrentSkipListSetIterator[E]) Remove() bool <span class="cov0" title="0">{
        return false // Not supported for concurrent collections
}</span>

// String returns the string representation of the set
func (s *ConcurrentSkipListSet[E]) String() string <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                return "{}"
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.WriteString("{")

        first := true
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                if !first </span><span class="cov8" title="1">{
                        sb.WriteString(", ")
                }</span>
                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%v", element))
                first = false</span>
        })

        <span class="cov8" title="1">sb.WriteString("}")
        return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package set provides set data structure implementations
package set

import (
        "fmt"
        "github.com/chenjianyu/collections/container/common"
        "hash/fnv"
        "strings"
)

// HashSet is a Set implementation based on hash table
type HashSet[E comparable] struct {
        buckets [][]E
        size    int
}

// New creates a new HashSet
func New[E comparable]() *HashSet[E] <span class="cov8" title="1">{
        return &amp;HashSet[E]{buckets: make([][]E, 16)}
}</span>

// FromSlice creates a new HashSet from a slice
func FromSlice[E comparable](slice []E) *HashSet[E] <span class="cov8" title="1">{
        set := New[E]()
        for _, element := range slice </span><span class="cov8" title="1">{
                set.Add(element)
        }</span>
        <span class="cov8" title="1">return set</span>
}

// Add adds an element to the set
func (s *HashSet[E]) Add(element E) bool <span class="cov8" title="1">{
        index := s.hash(element) % len(s.buckets)
        bucket := s.buckets[index]

        // Check if the element is really the same (handle hash collisions)
        for _, existing := range bucket </span><span class="cov8" title="1">{
                if existing == element </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">s.buckets[index] = append(bucket, element)
        s.size++
        return true</span>
}

// Remove removes the specified element from the set
func (s *HashSet[E]) Remove(element E) bool <span class="cov8" title="1">{
        index := s.hash(element) % len(s.buckets)
        bucket := s.buckets[index]

        for i, existing := range bucket </span><span class="cov8" title="1">{
                // Check if the element is really the same (handle hash collisions)
                if existing == element </span><span class="cov8" title="1">{
                        s.buckets[index] = append(bucket[:i], bucket[i+1:]...)
                        s.size--
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Contains checks if the set contains the specified element
func (s *HashSet[E]) Contains(element E) bool <span class="cov8" title="1">{
        index := s.hash(element) % len(s.buckets)
        bucket := s.buckets[index]

        for _, existing := range bucket </span><span class="cov8" title="1">{
                // Check if the element is really the same (handle hash collisions)
                if existing == element </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Size returns the number of elements in the set
func (s *HashSet[E]) Size() int <span class="cov8" title="1">{
        return s.size
}</span>

// IsEmpty checks if the set is empty
func (s *HashSet[E]) IsEmpty() bool <span class="cov8" title="1">{
        return s.size == 0
}</span>

// Clear empties the set
func (s *HashSet[E]) Clear() <span class="cov8" title="1">{
        s.buckets = make([][]E, 16)
        s.size = 0
}</span>

// ToSlice returns a slice containing all elements in the set
func (s *HashSet[E]) ToSlice() []E <span class="cov8" title="1">{
        result := make([]E, 0, s.size)
        for _, bucket := range s.buckets </span><span class="cov8" title="1">{
                result = append(result, bucket...)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ForEach executes the given operation on each element in the set
func (s *HashSet[E]) ForEach(fn func(E)) <span class="cov8" title="1">{
        for _, bucket := range s.buckets </span><span class="cov8" title="1">{
                for _, element := range bucket </span><span class="cov8" title="1">{
                        fn(element)
                }</span>
        }
}

// Union returns the union of this set and another set
func (s *HashSet[E]) Union(other Set[E]) Set[E] <span class="cov8" title="1">{
        result := New[E]()

        // Add all elements from this set
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                result.Add(element)
        }</span>)

        // Add all elements from the other set
        <span class="cov8" title="1">other.ForEach(func(element E) </span><span class="cov8" title="1">{
                result.Add(element)
        }</span>)

        <span class="cov8" title="1">return result</span>
}

// Intersection returns the intersection of this set and another set
func (s *HashSet[E]) Intersection(other Set[E]) Set[E] <span class="cov8" title="1">{
        result := New[E]()

        // Add elements that exist in both sets
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                if other.Contains(element) </span><span class="cov8" title="1">{
                        result.Add(element)
                }</span>
        })

        <span class="cov8" title="1">return result</span>
}

// Difference returns the difference of this set and another set
func (s *HashSet[E]) Difference(other Set[E]) Set[E] <span class="cov8" title="1">{
        result := New[E]()

        // Add elements that are in this set but not in the other set
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                if !other.Contains(element) </span><span class="cov8" title="1">{
                        result.Add(element)
                }</span>
        })

        <span class="cov8" title="1">return result</span>
}

// IsSubsetOf checks if this set is a subset of another set
func (s *HashSet[E]) IsSubsetOf(other Set[E]) bool <span class="cov8" title="1">{
        // Empty set is a subset of any set
        if s.IsEmpty() </span><span class="cov0" title="0">{
                return true
        }</span>

        // If this set is larger than the other set, it cannot be a subset
        <span class="cov8" title="1">if s.Size() &gt; other.Size() </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if every element in this set is in the other set
        <span class="cov8" title="1">for _, bucket := range s.buckets </span><span class="cov8" title="1">{
                for _, element := range bucket </span><span class="cov8" title="1">{
                        if !other.Contains(element) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// IsSupersetOf checks if this set is a superset of another set
func (s *HashSet[E]) IsSupersetOf(other Set[E]) bool <span class="cov8" title="1">{
        return other.IsSubsetOf(s)
}</span>

// String returns the string representation of the set
func (s *HashSet[E]) String() string <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                return "[]"
        }</span>

        <span class="cov8" title="1">var builder strings.Builder
        builder.WriteString("[")
        first := true
        for _, bucket := range s.buckets </span><span class="cov8" title="1">{
                for _, element := range bucket </span><span class="cov8" title="1">{
                        if !first </span><span class="cov8" title="1">{
                                builder.WriteString(", ")
                        }</span>
                        <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("%v", element))
                        first = false</span>
                }
        }
        <span class="cov8" title="1">builder.WriteString("]")
        return builder.String()</span>
}

// Iterator returns an iterator for traversing elements in the set
func (s *HashSet[E]) Iterator() common.Iterator[E] <span class="cov8" title="1">{
        return &amp;hashSetIterator[E]{
                set:      s,
                elements: s.ToSlice(),
                cursor:   0,
                lastRet:  -1,
        }
}</span>

// hashSetIterator is the iterator implementation for HashSet
type hashSetIterator[E comparable] struct {
        set      *HashSet[E]
        elements []E
        cursor   int // Index of the next element
        lastRet  int // Index of the last returned element, -1 if none
}

// HasNext checks if the iterator has a next element
func (it *hashSetIterator[E]) HasNext() bool <span class="cov8" title="1">{
        return it.cursor &lt; len(it.elements)
}</span>

// Next returns the next element in the iterator
func (it *hashSetIterator[E]) Next() (E, bool) <span class="cov8" title="1">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                var zero E
                return zero, false
        }</span>
        <span class="cov8" title="1">element := it.elements[it.cursor]
        it.lastRet = it.cursor
        it.cursor++
        return element, true</span>
}

// Remove removes the last element returned by the iterator
func (it *hashSetIterator[E]) Remove() bool <span class="cov8" title="1">{
        if it.lastRet == -1 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">removed := it.set.Remove(it.elements[it.lastRet])
        if removed </span><span class="cov8" title="1">{
                // Update the iterator's element list
                it.elements = it.set.ToSlice()
                it.cursor = 0 // Reset cursor since element list has changed
                it.lastRet = -1
        }</span>
        <span class="cov8" title="1">return removed</span>
}

// hash computes hash value for the element
func (s *HashSet[E]) hash(element E) int <span class="cov8" title="1">{
        h := fnv.New32a()
        h.Write([]byte(fmt.Sprintf("%v", element)))
        return int(h.Sum32())
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package set provides set data structure implementations
package set

import (
        "fmt"
        "hash/fnv"
        "strings"

        "github.com/chenjianyu/collections/container/common"
)

// linkedHashSetNode represents a node in the LinkedHashSet
type linkedHashSetNode[E comparable] struct {
        data E
        prev *linkedHashSetNode[E]
        next *linkedHashSetNode[E]
}

// LinkedHashSet is a Set implementation that maintains insertion order
// It combines the fast lookup of a hash table with the ordering of a linked list
type LinkedHashSet[E comparable] struct {
        buckets [][]E                         // Hash table for fast lookup
        nodeMap map[E]*linkedHashSetNode[E]   // Map from element to node for O(1) access
        head    *linkedHashSetNode[E]         // Head of the doubly linked list
        tail    *linkedHashSetNode[E]         // Tail of the doubly linked list
        size    int
}

// NewLinkedHashSet creates a new LinkedHashSet
func NewLinkedHashSet[E comparable]() *LinkedHashSet[E] <span class="cov8" title="1">{
        return &amp;LinkedHashSet[E]{
                buckets: make([][]E, 16),
                nodeMap: make(map[E]*linkedHashSetNode[E]),
        }
}</span>

// LinkedHashSetFromSlice creates a new LinkedHashSet from a slice
func LinkedHashSetFromSlice[E comparable](slice []E) *LinkedHashSet[E] <span class="cov8" title="1">{
        set := NewLinkedHashSet[E]()
        for _, element := range slice </span><span class="cov8" title="1">{
                set.Add(element)
        }</span>
        <span class="cov8" title="1">return set</span>
}

// hash computes the hash value for an element
func (s *LinkedHashSet[E]) hash(element E) uint32 <span class="cov8" title="1">{
        h := fnv.New32a()
        h.Write([]byte(fmt.Sprintf("%v", element)))
        return h.Sum32()
}</span>

// Add adds an element to the set
func (s *LinkedHashSet[E]) Add(element E) bool <span class="cov8" title="1">{
        // Check if element already exists
        if _, exists := s.nodeMap[element]; exists </span><span class="cov8" title="1">{
                return false
        }</span>

        // Add to hash table
        <span class="cov8" title="1">index := s.hash(element) % uint32(len(s.buckets))
        s.buckets[index] = append(s.buckets[index], element)

        // Create new node and add to linked list
        newNode := &amp;linkedHashSetNode[E]{data: element}
        s.nodeMap[element] = newNode

        if s.head == nil </span><span class="cov8" title="1">{
                // First element
                s.head = newNode
                s.tail = newNode
        }</span> else<span class="cov8" title="1"> {
                // Add to tail
                s.tail.next = newNode
                newNode.prev = s.tail
                s.tail = newNode
        }</span>

        <span class="cov8" title="1">s.size++

        // Resize if load factor is too high
        if s.size &gt; len(s.buckets)*2 </span><span class="cov8" title="1">{
                s.resize()
        }</span>

        <span class="cov8" title="1">return true</span>
}

// Remove removes the specified element from the set
func (s *LinkedHashSet[E]) Remove(element E) bool <span class="cov8" title="1">{
        node, exists := s.nodeMap[element]
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>

        // Remove from hash table
        <span class="cov8" title="1">index := s.hash(element) % uint32(len(s.buckets))
        bucket := s.buckets[index]
        for i, existing := range bucket </span><span class="cov8" title="1">{
                if existing == element </span><span class="cov8" title="1">{
                        s.buckets[index] = append(bucket[:i], bucket[i+1:]...)
                        break</span>
                }
        }

        // Remove from linked list
        <span class="cov8" title="1">if node.prev != nil </span><span class="cov8" title="1">{
                node.prev.next = node.next
        }</span> else<span class="cov8" title="1"> {
                s.head = node.next
        }</span>

        <span class="cov8" title="1">if node.next != nil </span><span class="cov8" title="1">{
                node.next.prev = node.prev
        }</span> else<span class="cov0" title="0"> {
                s.tail = node.prev
        }</span>

        // Remove from node map
        <span class="cov8" title="1">delete(s.nodeMap, element)
        s.size--

        return true</span>
}

// Contains checks if the set contains the specified element
func (s *LinkedHashSet[E]) Contains(element E) bool <span class="cov8" title="1">{
        _, exists := s.nodeMap[element]
        return exists
}</span>

// Size returns the number of elements in the set
func (s *LinkedHashSet[E]) Size() int <span class="cov8" title="1">{
        return s.size
}</span>

// IsEmpty checks if the set is empty
func (s *LinkedHashSet[E]) IsEmpty() bool <span class="cov8" title="1">{
        return s.size == 0
}</span>

// Clear empties the set
func (s *LinkedHashSet[E]) Clear() <span class="cov8" title="1">{
        s.buckets = make([][]E, 16)
        s.nodeMap = make(map[E]*linkedHashSetNode[E])
        s.head = nil
        s.tail = nil
        s.size = 0
}</span>

// ToSlice returns a slice containing all elements in insertion order
func (s *LinkedHashSet[E]) ToSlice() []E <span class="cov8" title="1">{
        result := make([]E, 0, s.size)
        current := s.head
        for current != nil </span><span class="cov8" title="1">{
                result = append(result, current.data)
                current = current.next
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ForEach executes the given operation on each element in insertion order
func (s *LinkedHashSet[E]) ForEach(f func(E)) <span class="cov8" title="1">{
        current := s.head
        for current != nil </span><span class="cov8" title="1">{
                f(current.data)
                current = current.next
        }</span>
}

// Union returns the union of this set and another set
func (s *LinkedHashSet[E]) Union(other Set[E]) Set[E] <span class="cov8" title="1">{
        result := NewLinkedHashSet[E]()

        // Add all elements from this set (maintains order)
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                result.Add(element)
        }</span>)

        // Add all elements from the other set
        <span class="cov8" title="1">other.ForEach(func(element E) </span><span class="cov8" title="1">{
                result.Add(element)
        }</span>)

        <span class="cov8" title="1">return result</span>
}

// Intersection returns the intersection of this set and another set
func (s *LinkedHashSet[E]) Intersection(other Set[E]) Set[E] <span class="cov8" title="1">{
        result := NewLinkedHashSet[E]()

        // Add elements that exist in both sets (maintains order from this set)
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                if other.Contains(element) </span><span class="cov8" title="1">{
                        result.Add(element)
                }</span>
        })

        <span class="cov8" title="1">return result</span>
}

// Difference returns the difference of this set and another set
func (s *LinkedHashSet[E]) Difference(other Set[E]) Set[E] <span class="cov8" title="1">{
        result := NewLinkedHashSet[E]()

        // Add elements that are in this set but not in the other set
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                if !other.Contains(element) </span><span class="cov8" title="1">{
                        result.Add(element)
                }</span>
        })

        <span class="cov8" title="1">return result</span>
}

// IsSubsetOf checks if this set is a subset of another set
func (s *LinkedHashSet[E]) IsSubsetOf(other Set[E]) bool <span class="cov8" title="1">{
        // Empty set is a subset of any set
        if s.IsEmpty() </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if all elements in this set are in the other set
        <span class="cov8" title="1">isSubset := true
        s.ForEach(func(element E) </span><span class="cov8" title="1">{
                if !other.Contains(element) </span><span class="cov8" title="1">{
                        isSubset = false
                }</span>
        })

        <span class="cov8" title="1">return isSubset</span>
}

// IsSupersetOf checks if this set is a superset of another set
func (s *LinkedHashSet[E]) IsSupersetOf(other Set[E]) bool <span class="cov8" title="1">{
        return other.IsSubsetOf(s)
}</span>

// String returns the string representation of the set in insertion order
func (s *LinkedHashSet[E]) String() string <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                return "[]"
        }</span>

        <span class="cov8" title="1">var builder strings.Builder
        builder.WriteString("[")
        current := s.head
        first := true
        for current != nil </span><span class="cov8" title="1">{
                if !first </span><span class="cov8" title="1">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("%v", current.data))
                first = false
                current = current.next</span>
        }
        <span class="cov8" title="1">builder.WriteString("]")
        return builder.String()</span>
}

// Iterator returns an iterator for traversing elements in insertion order
func (s *LinkedHashSet[E]) Iterator() common.Iterator[E] <span class="cov8" title="1">{
        return &amp;linkedHashSetIterator[E]{
                set:     s,
                current: s.head,
                lastRet: nil,
        }
}</span>

// resize increases the capacity of the hash table
func (s *LinkedHashSet[E]) resize() <span class="cov8" title="1">{
        oldBuckets := s.buckets
        s.buckets = make([][]E, len(oldBuckets)*2)

        // Rehash all elements
        for _, bucket := range oldBuckets </span><span class="cov8" title="1">{
                for _, element := range bucket </span><span class="cov8" title="1">{
                        index := s.hash(element) % uint32(len(s.buckets))
                        s.buckets[index] = append(s.buckets[index], element)
                }</span>
        }
}

// linkedHashSetIterator is the iterator implementation for LinkedHashSet
type linkedHashSetIterator[E comparable] struct {
        set     *LinkedHashSet[E]
        current *linkedHashSetNode[E]
        lastRet *linkedHashSetNode[E]
}

// HasNext checks if the iterator has a next element
func (it *linkedHashSetIterator[E]) HasNext() bool <span class="cov8" title="1">{
        return it.current != nil
}</span>

// Next returns the next element in insertion order
func (it *linkedHashSetIterator[E]) Next() (E, bool) <span class="cov8" title="1">{
        if !it.HasNext() </span><span class="cov8" title="1">{
                var zero E
                return zero, false
        }</span>

        <span class="cov8" title="1">element := it.current.data
        it.lastRet = it.current
        it.current = it.current.next
        return element, true</span>
}

// Remove removes the last element returned by the iterator
func (it *linkedHashSetIterator[E]) Remove() bool <span class="cov8" title="1">{
        if it.lastRet == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">removed := it.set.Remove(it.lastRet.data)
        it.lastRet = nil
        return removed</span>
}</pre>
		
		<pre class="file" id="file32" style="display: none">package set

import (
        "fmt"
        "strings"

        "github.com/chenjianyu/collections/container/common"
)

// Compare compares two comparable type values
// Note: This function only supports int type, for other types please use custom comparator
func Compare[E any](a, b E) int <span class="cov8" title="1">{
        // Try to convert to int type
        cmpA, okA := any(a).(int)
        cmpB, okB := any(b).(int)
        if okA &amp;&amp; okB </span><span class="cov8" title="1">{
                if cmpA == cmpB </span><span class="cov8" title="1">{
                        return 0
                }</span> else<span class="cov8" title="1"> if cmpA &lt; cmpB </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> {
                        return 1
                }</span>
        }
        // For non-int types, return 0 (equal)
        <span class="cov0" title="0">return 0</span>
}

// TreeSet is a set implementation based on red-black tree
// Elements are stored in sorted order
type TreeSet[E comparable] struct {
        root       *treeNode[E]
        size       int
        comparator func(a, b E) int
}

// treeNode represents a node in the red-black tree
type treeNode[E comparable] struct {
        value  E
        color  bool // true for red, false for black
        left   *treeNode[E]
        right  *treeNode[E]
        parent *treeNode[E]
}

// NewTreeSet creates a new TreeSet using default comparator
// Default comparator only supports int type
func NewTreeSet[E comparable]() *TreeSet[E] <span class="cov0" title="0">{
        return &amp;TreeSet[E]{
                root:       nil,
                size:       0,
                comparator: Compare[E],
        }
}</span>

// NewTreeSetWithComparator creates a new TreeSet using custom comparator
func NewTreeSetWithComparator[E comparable](comparator func(a, b E) int) *TreeSet[E] <span class="cov0" title="0">{
        return &amp;TreeSet[E]{
                root:       nil,
                size:       0,
                comparator: comparator,
        }
}</span>

// Size returns the number of elements in the set
func (ts *TreeSet[E]) Size() int <span class="cov0" title="0">{
        return ts.size
}</span>

// IsEmpty checks if the set is empty
func (ts *TreeSet[E]) IsEmpty() bool <span class="cov0" title="0">{
        return ts.size == 0
}</span>

// Clear clears all elements from the set
func (ts *TreeSet[E]) Clear() <span class="cov0" title="0">{
        ts.root = nil
        ts.size = 0
}</span>

// Contains checks if the set contains the specified element
func (ts *TreeSet[E]) Contains(element E) bool <span class="cov0" title="0">{
        return ts.findNode(element) != nil
}</span>

// Add adds an element to the set
// Returns false if the set already contains the element, otherwise returns true
func (ts *TreeSet[E]) Add(element E) bool <span class="cov0" title="0">{
        if ts.root == nil </span><span class="cov0" title="0">{
                ts.root = &amp;treeNode[E]{
                        value: element,
                        color: false, // root is always black
                }
                ts.size++
                return true
        }</span>

        <span class="cov0" title="0">node := ts.root
        for </span><span class="cov0" title="0">{
                cmp := ts.comparator(element, node.value)
                if cmp == 0 </span><span class="cov0" title="0">{
                        return false // element already exists
                }</span> else<span class="cov0" title="0"> if cmp &lt; 0 </span><span class="cov0" title="0">{
                        if node.left == nil </span><span class="cov0" title="0">{
                                newNode := &amp;treeNode[E]{
                                        value:  element,
                                        color:  true, // new node is red
                                        parent: node,
                                }
                                node.left = newNode
                                ts.insertFixup(newNode)
                                ts.size++
                                return true
                        }</span>
                        <span class="cov0" title="0">node = node.left</span>
                } else<span class="cov0" title="0"> {
                        if node.right == nil </span><span class="cov0" title="0">{
                                newNode := &amp;treeNode[E]{
                                        value:  element,
                                        color:  true, // new node is red
                                        parent: node,
                                }
                                node.right = newNode
                                ts.insertFixup(newNode)
                                ts.size++
                                return true
                        }</span>
                        <span class="cov0" title="0">node = node.right</span>
                }
        }
}

// Remove removes the specified element from the set
// Returns true if the set contained the element, otherwise returns false
func (ts *TreeSet[E]) Remove(element E) bool <span class="cov0" title="0">{
        node := ts.findNode(element)
        if node == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">ts.deleteNode(node)
        ts.size--
        return true</span>
}

// ToSlice returns a slice containing all elements in the set
func (ts *TreeSet[E]) ToSlice() []E <span class="cov0" title="0">{
        result := make([]E, 0, ts.size)
        ts.inorderTraversal(ts.root, func(value E) </span><span class="cov0" title="0">{
                result = append(result, value)
        }</span>)
        <span class="cov0" title="0">return result</span>
}

// Union returns a new set containing all elements from this set and the other set
func (ts *TreeSet[E]) Union(other Set[E]) Set[E] <span class="cov0" title="0">{
        result := NewTreeSetWithComparator(ts.comparator)
        ts.ForEach(func(element E) </span><span class="cov0" title="0">{
                result.Add(element)
        }</span>)
        <span class="cov0" title="0">other.ForEach(func(element E) </span><span class="cov0" title="0">{
                result.Add(element)
        }</span>)
        <span class="cov0" title="0">return result</span>
}

// Intersection returns a new set containing elements that exist in both sets
func (ts *TreeSet[E]) Intersection(other Set[E]) Set[E] <span class="cov0" title="0">{
        result := NewTreeSetWithComparator(ts.comparator)
        ts.ForEach(func(element E) </span><span class="cov0" title="0">{
                if other.Contains(element) </span><span class="cov0" title="0">{
                        result.Add(element)
                }</span>
        })
        <span class="cov0" title="0">return result</span>
}

// Difference returns a new set containing elements that exist in this set but not in the other set
func (ts *TreeSet[E]) Difference(other Set[E]) Set[E] <span class="cov0" title="0">{
        result := NewTreeSetWithComparator(ts.comparator)
        ts.ForEach(func(element E) </span><span class="cov0" title="0">{
                if !other.Contains(element) </span><span class="cov0" title="0">{
                        result.Add(element)
                }</span>
        })
        <span class="cov0" title="0">return result</span>
}

// IsSubsetOf checks if this set is a subset of the other set
func (ts *TreeSet[E]) IsSubsetOf(other Set[E]) bool <span class="cov0" title="0">{
        if ts.Size() &gt; other.Size() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">isSubset := true
        ts.ForEach(func(element E) </span><span class="cov0" title="0">{
                if !other.Contains(element) </span><span class="cov0" title="0">{
                        isSubset = false
                }</span>
        })
        <span class="cov0" title="0">return isSubset</span>
}

// IsSupersetOf checks if this set is a superset of the other set
func (ts *TreeSet[E]) IsSupersetOf(other Set[E]) bool <span class="cov0" title="0">{
        return other.IsSubsetOf(ts)
}</span>

// ForEach executes the given operation for each element in the set
func (ts *TreeSet[E]) ForEach(fn func(E)) <span class="cov0" title="0">{
        ts.inorderTraversal(ts.root, fn)
}</span>

// Iterator returns an iterator for the set
func (ts *TreeSet[E]) Iterator() common.Iterator[E] <span class="cov0" title="0">{
        elements := ts.ToSlice()
        return &amp;treeSetIterator[E]{
                elements: elements,
                index:    0,
        }
}</span>

// treeSetIterator implements Iterator for TreeSet
type treeSetIterator[E comparable] struct {
        elements []E
        index    int
}

// HasNext returns true if there are more elements to iterate
func (it *treeSetIterator[E]) HasNext() bool <span class="cov0" title="0">{
        return it.index &lt; len(it.elements)
}</span>

// Next returns the next element
func (it *treeSetIterator[E]) Next() (E, bool) <span class="cov0" title="0">{
        if !it.HasNext() </span><span class="cov0" title="0">{
                var zero E
                return zero, false
        }</span>
        <span class="cov0" title="0">element := it.elements[it.index]
        it.index++
        return element, true</span>
}

// Remove removes the current element (not supported)
func (it *treeSetIterator[E]) Remove() bool <span class="cov0" title="0">{
        return false // Not supported
}</span>

// String returns the string representation of the set
func (ts *TreeSet[E]) String() string <span class="cov0" title="0">{
        if ts.IsEmpty() </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("{")

        first := true
        ts.ForEach(func(element E) </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        sb.WriteString(", ")
                }</span>
                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("%v", element))
                first = false</span>
        })

        <span class="cov0" title="0">sb.WriteString("}")
        return sb.String()</span>
}

// Internal method: find node with specified value
func (ts *TreeSet[E]) findNode(element E) *treeNode[E] <span class="cov0" title="0">{
        node := ts.root
        for node != nil </span><span class="cov0" title="0">{
                cmp := ts.comparator(element, node.value)
                if cmp == 0 </span><span class="cov0" title="0">{
                        return node
                }</span> else<span class="cov0" title="0"> if cmp &lt; 0 </span><span class="cov0" title="0">{
                        node = node.left
                }</span> else<span class="cov0" title="0"> {
                        node = node.right
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Internal method: in-order traversal
func (ts *TreeSet[E]) inorderTraversal(node *treeNode[E], fn func(E)) <span class="cov0" title="0">{
        if node != nil </span><span class="cov0" title="0">{
                ts.inorderTraversal(node.left, fn)
                fn(node.value)
                ts.inorderTraversal(node.right, fn)
        }</span>
}

// Internal method: left rotation
func (ts *TreeSet[E]) rotateLeft(node *treeNode[E]) <span class="cov0" title="0">{
        right := node.right
        node.right = right.left
        if right.left != nil </span><span class="cov0" title="0">{
                right.left.parent = node
        }</span>
        <span class="cov0" title="0">right.parent = node.parent
        if node.parent == nil </span><span class="cov0" title="0">{
                ts.root = right
        }</span> else<span class="cov0" title="0"> if node == node.parent.left </span><span class="cov0" title="0">{
                node.parent.left = right
        }</span> else<span class="cov0" title="0"> {
                node.parent.right = right
        }</span>
        <span class="cov0" title="0">right.left = node
        node.parent = right</span>
}

// Internal method: right rotation
func (ts *TreeSet[E]) rotateRight(node *treeNode[E]) <span class="cov0" title="0">{
        left := node.left
        node.left = left.right
        if left.right != nil </span><span class="cov0" title="0">{
                left.right.parent = node
        }</span>
        <span class="cov0" title="0">left.parent = node.parent
        if node.parent == nil </span><span class="cov0" title="0">{
                ts.root = left
        }</span> else<span class="cov0" title="0"> if node == node.parent.right </span><span class="cov0" title="0">{
                node.parent.right = left
        }</span> else<span class="cov0" title="0"> {
                node.parent.left = left
        }</span>
        <span class="cov0" title="0">left.right = node
        node.parent = left</span>
}

// Internal method: fix red-black tree properties after insertion
func (ts *TreeSet[E]) insertFixup(node *treeNode[E]) <span class="cov0" title="0">{
        for node.parent != nil &amp;&amp; node.parent.color </span><span class="cov0" title="0">{
                if node.parent == node.parent.parent.left </span><span class="cov0" title="0">{
                        uncle := node.parent.parent.right
                        if uncle != nil &amp;&amp; uncle.color </span><span class="cov0" title="0">{
                                node.parent.color = false
                                uncle.color = false
                                node.parent.parent.color = true
                                node = node.parent.parent
                        }</span> else<span class="cov0" title="0"> {
                                if node == node.parent.right </span><span class="cov0" title="0">{
                                        node = node.parent
                                        ts.rotateLeft(node)
                                }</span>
                                <span class="cov0" title="0">node.parent.color = false
                                node.parent.parent.color = true
                                ts.rotateRight(node.parent.parent)</span>
                        }
                } else<span class="cov0" title="0"> {
                        uncle := node.parent.parent.left
                        if uncle != nil &amp;&amp; uncle.color </span><span class="cov0" title="0">{
                                node.parent.color = false
                                uncle.color = false
                                node.parent.parent.color = true
                                node = node.parent.parent
                        }</span> else<span class="cov0" title="0"> {
                                if node == node.parent.left </span><span class="cov0" title="0">{
                                        node = node.parent
                                        ts.rotateRight(node)
                                }</span>
                                <span class="cov0" title="0">node.parent.color = false
                                node.parent.parent.color = true
                                ts.rotateLeft(node.parent.parent)</span>
                        }
                }
        }
        <span class="cov0" title="0">ts.root.color = false</span>
}

// Internal method: delete node
func (ts *TreeSet[E]) deleteNode(node *treeNode[E]) <span class="cov0" title="0">{
        var y *treeNode[E]
        var x *treeNode[E]

        if node.left == nil || node.right == nil </span><span class="cov0" title="0">{
                y = node
        }</span> else<span class="cov0" title="0"> {
                y = ts.successor(node)
        }</span>

        <span class="cov0" title="0">if y.left != nil </span><span class="cov0" title="0">{
                x = y.left
        }</span> else<span class="cov0" title="0"> {
                x = y.right
        }</span>

        <span class="cov0" title="0">if x != nil </span><span class="cov0" title="0">{
                x.parent = y.parent
        }</span>

        <span class="cov0" title="0">if y.parent == nil </span><span class="cov0" title="0">{
                ts.root = x
        }</span> else<span class="cov0" title="0"> if y == y.parent.left </span><span class="cov0" title="0">{
                y.parent.left = x
        }</span> else<span class="cov0" title="0"> {
                y.parent.right = x
        }</span>

        <span class="cov0" title="0">if y != node </span><span class="cov0" title="0">{
                node.value = y.value
        }</span>

        <span class="cov0" title="0">if !y.color &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ts.deleteFixup(x)
        }</span>
}

// Internal method: find successor node
func (ts *TreeSet[E]) successor(node *treeNode[E]) *treeNode[E] <span class="cov0" title="0">{
        if node.right != nil </span><span class="cov0" title="0">{
                node = node.right
                for node.left != nil </span><span class="cov0" title="0">{
                        node = node.left
                }</span>
                <span class="cov0" title="0">return node</span>
        }

        <span class="cov0" title="0">parent := node.parent
        for parent != nil &amp;&amp; node == parent.right </span><span class="cov0" title="0">{
                node = parent
                parent = parent.parent
        }</span>
        <span class="cov0" title="0">return parent</span>
}

// Internal method: fix red-black tree properties after deletion
func (ts *TreeSet[E]) deleteFixup(node *treeNode[E]) <span class="cov0" title="0">{
        for node != ts.root &amp;&amp; !node.color </span><span class="cov0" title="0">{
                if node == node.parent.left </span><span class="cov0" title="0">{
                        sibling := node.parent.right
                        if sibling.color </span><span class="cov0" title="0">{
                                sibling.color = false
                                node.parent.color = true
                                ts.rotateLeft(node.parent)
                                sibling = node.parent.right
                        }</span>
                        <span class="cov0" title="0">if (sibling.left == nil || !sibling.left.color) &amp;&amp;
                                (sibling.right == nil || !sibling.right.color) </span><span class="cov0" title="0">{
                                sibling.color = true
                                node = node.parent
                        }</span> else<span class="cov0" title="0"> {
                                if sibling.right == nil || !sibling.right.color </span><span class="cov0" title="0">{
                                        if sibling.left != nil </span><span class="cov0" title="0">{
                                                sibling.left.color = false
                                        }</span>
                                        <span class="cov0" title="0">sibling.color = true
                                        ts.rotateRight(sibling)
                                        sibling = node.parent.right</span>
                                }
                                <span class="cov0" title="0">sibling.color = node.parent.color
                                node.parent.color = false
                                if sibling.right != nil </span><span class="cov0" title="0">{
                                        sibling.right.color = false
                                }</span>
                                <span class="cov0" title="0">ts.rotateLeft(node.parent)
                                node = ts.root</span>
                        }
                } else<span class="cov0" title="0"> {
                        sibling := node.parent.left
                        if sibling.color </span><span class="cov0" title="0">{
                                sibling.color = false
                                node.parent.color = true
                                ts.rotateRight(node.parent)
                                sibling = node.parent.left
                        }</span>
                        <span class="cov0" title="0">if (sibling.right == nil || !sibling.right.color) &amp;&amp;
                                (sibling.left == nil || !sibling.left.color) </span><span class="cov0" title="0">{
                                sibling.color = true
                                node = node.parent
                        }</span> else<span class="cov0" title="0"> {
                                if sibling.left == nil || !sibling.left.color </span><span class="cov0" title="0">{
                                        if sibling.right != nil </span><span class="cov0" title="0">{
                                                sibling.right.color = false
                                        }</span>
                                        <span class="cov0" title="0">sibling.color = true
                                        ts.rotateLeft(sibling)
                                        sibling = node.parent.left</span>
                                }
                                <span class="cov0" title="0">sibling.color = node.parent.color
                                node.parent.color = false
                                if sibling.left != nil </span><span class="cov0" title="0">{
                                        sibling.left.color = false
                                }</span>
                                <span class="cov0" title="0">ts.rotateRight(node.parent)
                                node = ts.root</span>
                        }
                }
        }
        <span class="cov0" title="0">node.color = false</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package stack provides stack data structure implementations
package stack

import (
        "fmt"
        "strings"
        "github.com/chenjianyu/collections/container/common"
)

// ArrayStack is a stack implementation based on slices
type ArrayStack[E any] struct {
        elements []E
        maxCap   int // Maximum capacity, 0 means unbounded
}

// New creates a new unbounded ArrayStack
func New[E any]() *ArrayStack[E] <span class="cov8" title="1">{
        return &amp;ArrayStack[E]{
                elements: make([]E, 0),
                maxCap:   0,
        }
}</span>

// WithCapacity creates an ArrayStack with specified maximum capacity
func WithCapacity[E any](capacity int) *ArrayStack[E] <span class="cov8" title="1">{
        return &amp;ArrayStack[E]{
                elements: make([]E, 0, capacity),
                maxCap:   capacity,
        }
}</span>

// FromSlice creates a new ArrayStack from a slice
// The first element in the slice will be the bottom element, the last element will be the top element
func FromSlice[E any](slice []E) *ArrayStack[E] <span class="cov0" title="0">{
        elements := make([]E, len(slice))
        copy(elements, slice)
        return &amp;ArrayStack[E]{
                elements: elements,
                maxCap:   0,
        }
}</span>

// Size returns the number of elements in the stack
func (s *ArrayStack[E]) Size() int <span class="cov8" title="1">{
        return len(s.elements)
}</span>

// IsEmpty checks if the stack is empty
func (s *ArrayStack[E]) IsEmpty() bool <span class="cov8" title="1">{
        return len(s.elements) == 0
}</span>

// isFull checks if the stack is full
func (s *ArrayStack[E]) isFull() bool <span class="cov8" title="1">{
        return s.maxCap &gt; 0 &amp;&amp; len(s.elements) &gt;= s.maxCap
}</span>

// Clear empties the stack
func (s *ArrayStack[E]) Clear() <span class="cov8" title="1">{
        s.elements = s.elements[:0]
}</span>

// Contains checks if the stack contains the specified element
func (s *ArrayStack[E]) Contains(element E) bool <span class="cov8" title="1">{
        for _, e := range s.elements </span><span class="cov8" title="1">{
                if any(e) == any(element) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ForEach executes the given operation on each element in the stack
// Traversal order is from bottom to top
func (s *ArrayStack[E]) ForEach(fn func(E)) <span class="cov8" title="1">{
        for _, element := range s.elements </span><span class="cov8" title="1">{
                fn(element)
        }</span>
}

// String returns the string representation of the stack
func (s *ArrayStack[E]) String() string <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                return "[]"
        }</span>

        <span class="cov8" title="1">var builder strings.Builder
        builder.WriteString("[")
        for i, element := range s.elements </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        builder.WriteString(", ")
                }</span>
                <span class="cov8" title="1">builder.WriteString(fmt.Sprintf("%v", element))</span>
        }
        <span class="cov8" title="1">builder.WriteString("]")
        return builder.String()</span>
}

// Push pushes an element onto the top of the stack
func (s *ArrayStack[E]) Push(element E) error <span class="cov8" title="1">{
        if s.isFull() </span><span class="cov8" title="1">{
                return common.FullContainerError("ArrayStack", s.maxCap)
        }</span>
        <span class="cov8" title="1">s.elements = append(s.elements, element)
        return nil</span>
}

// Pop removes and returns the element at the top of the stack
func (s *ArrayStack[E]) Pop() (E, error) <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                var zero E
                return zero, common.EmptyContainerError("ArrayStack")
        }</span>

        <span class="cov8" title="1">index := len(s.elements) - 1
        element := s.elements[index]
        s.elements = s.elements[:index]
        return element, nil</span>
}

// Peek returns the element at the top of the stack without removing it
func (s *ArrayStack[E]) Peek() (E, error) <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                var zero E
                return zero, common.EmptyContainerError("ArrayStack")
        }</span>
        <span class="cov8" title="1">return s.elements[len(s.elements)-1], nil</span>
}

// Search searches for an element in the stack
func (s *ArrayStack[E]) Search(element E) int <span class="cov0" title="0">{
        for i := len(s.elements) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if any(s.elements[i]) == any(element) </span><span class="cov0" title="0">{
                        return len(s.elements) - i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// ToSlice returns a slice containing all elements in the stack
func (s *ArrayStack[E]) ToSlice() []E <span class="cov8" title="1">{
        result := make([]E, len(s.elements))
        copy(result, s.elements)
        return result
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
